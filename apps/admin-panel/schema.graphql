# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Point {
  lat: Float!
  lng: Float!
  heading: Int
}

type AppConfigInfo {
  logo: String
  name: String
  color: String
}

type License {
  buyerName: String!
  licenseType: LicenseType!
  supportExpireDate: DateTime!
  connectedApps: [AppType!]!
  platformAddons: [PlatformAddOn!]!
}

enum LicenseType {
  Regular
  Extended
  Bronze
  Silver
  Gold
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

enum AppType {
  Taxi
  Shop
  Parking
}

enum PlatformAddOn {
  FleetAddOn
}

type CurrentConfiguration {
  purchaseCode: String
  backendMapsAPIKey: String
  adminPanelAPIKey: String
  firebaseProjectPrivateKey: String
  versionNumber: String
  companyLogo: String
  companyName: String
  taxi: AppConfigInfo
  shop: AppConfigInfo
  parking: AppConfigInfo
  mysqlHost: String
  mysqlPort: Int
  mysqlUser: String
  mysqlPassword: String
  mysqlDatabase: String
  redisHost: String
  redisPort: Int
  redisPassword: String
  redisDb: Int
}

type UpdatePurchaseCodeResult {
  status: UpdatePurchaseCodeStatus!
  message: String
  data: LicenseInformation
  clients: [UpdatePurchaseCodeClient!]
}

enum UpdatePurchaseCodeStatus {
  OK
  INVALID
  OVERUSED
  CLIENT_FOUND
}

type UpdatePurchaseCodeClient {
  id: ID!
  enabled: Boolean!
  ip: String!
  port: Float!
  token: String!
  purchaseId: ID!
  firstVerifiedAt: DateTime!
  lastVerifiedAt: DateTime!
}

type LicenseInformation {
  license: License
  benefits: [String!]
  drawbacks: [String!]
  availableUpgrades: [AvaialbeUpgrade!]
}

type AvaialbeUpgrade {
  type: String!
  price: Float!
  benefits: [String!]!
}

type UpdateConfigResult {
  status: UpdateConfigStatus!
  message: String
}

enum UpdateConfigStatus {
  OK
  INVALID
}

type ConfigInformation {
  isValid: Boolean!
  config: CurrentConfiguration
}

type DateRangeMultiplier {
  startDate: Float!
  endDate: Float!
  multiply: Float!
}

type DistanceMultiplier {
  distanceFrom: Float!
  distanceTo: Float!
  multiply: Float!
}

type TimeMultiplier {
  startTime: String!
  endTime: String!
  multiply: Float!
}

type WeekdayMultiplier {
  weekday: Weekday!
  multiply: Float!
}

enum Weekday {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}

type WeekdaySchedule {
  weekday: Weekday!
  openingHours: [TimeRange!]!
}

type TimeRange {
  open: String!
  close: String!
}

type ExportResult {
  url: String!
}

type IncomeResultItem {
  time: String!
  sum: Float!
  currency: String!
}

type RegistrationResultItem {
  time: String!
  count: Int!
}

type RequestResultItem {
  time: String!
  count: Int!
  status: OrderStatus!
}

enum OrderStatus {
  Requested
  NotFound
  NoCloseFound
  Found
  DriverAccepted
  Arrived
  WaitingForPrePay
  DriverCanceled
  RiderCanceled
  Started
  WaitingForPostPay
  WaitingForReview
  Finished
  Booked
  Expired
}

type TotalDailyPair {
  total: Int!
  daily: Float!
}

type ProviderTransaction {
  id: ID!
  createdAt: DateTime!
  action: TransactionAction!
  deductType: ProviderDeductTransactionType!
  rechargeType: ProviderRechargeTransactionType!
  expenseType: ProviderExpenseType!
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  operatorId: ID!
  requestId: ID!
  parkOrderId: ID!
  shopOrderCartId: ID!
}

enum TransactionAction {
  Recharge
  Deduct
}

enum ProviderDeductTransactionType {
  Withdraw
  Expense
  Refund
}

enum ProviderRechargeTransactionType {
  Commission
}

enum ProviderExpenseType {
  TechnologyDevelopment
  PlatformMaintenance
  SoftwareLicense
  Hosting
  CloudServices
  Marketing
}

type ProviderWallet {
  id: ID!
  balance: Float!
  currency: String!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

type OffsetPageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean
}

type ProviderTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ProviderTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ProviderTransactionAggregateGroupBy {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ProviderTransactionCountAggregate {
  id: Int
  action: Int
  deductType: Int
  rechargeType: Int
  expenseType: Int
  amount: Int
  currency: Int
  operatorId: Int
  requestId: Int
  parkOrderId: Int
  shopOrderCartId: Int
}

type ProviderTransactionSumAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type ProviderTransactionAvgAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type ProviderTransactionMinAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ProviderTransactionMaxAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ProviderTransactionAggregateResponse {
  groupBy: ProviderTransactionAggregateGroupBy
  count: ProviderTransactionCountAggregate
  sum: ProviderTransactionSumAggregate
  avg: ProviderTransactionAvgAggregate
  min: ProviderTransactionMinAggregate
  max: ProviderTransactionMaxAggregate
}

type Address {
  id: ID!
  title: String!
  type: RiderAddressType!
  details: String
  location: Point!
  riderId: ID!
}

enum RiderAddressType {
  Home
  Work
  Partner
  Gym
  Parent
  Cafe
  Park
  Other
}

type AddressConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Address!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type Announcement {
  id: ID!
  title: String!
  description: String!
  url: String
  userType: [AnnouncementUserType!]!
  appType: AppType
  startAt: DateTime!
  expireAt: DateTime!
}

enum AnnouncementUserType {
  Driver
  Rider
  Operator
}

type AnnouncementDeleteResponse {
  id: ID
  title: String
  description: String
  url: String
  userType: [AnnouncementUserType!]
  appType: AppType
  startAt: DateTime
  expireAt: DateTime
}

type AnnouncementConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Announcement!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type OperatorRole {
  id: ID!
  title: String!
  permissions: [OperatorPermission!]!
  taxiPermissions: [TaxiPermission!]!
  shopPermissions: [ShopPermission!]!
  parkingPermissions: [ParkingPermission!]!
  allowedApps: [AppType!]!
}

enum OperatorPermission {
  Drivers_View
  Drivers_Edit
  Riders_View
  Riders_Edit
  Regions_View
  Regions_Edit
  Services_View
  Services_Edit
  Complaints_View
  Complaints_Edit
  Coupons_View
  Coupons_Edit
  Announcements_View
  Announcements_Edit
  Requests_View
  Fleets_View
  Fleets_Edit
  Gateways_View
  Gateways_Edit
  Users_View
  Users_Edit
  Cars_View
  Cars_Edit
  FleetWallet_View
  FleetWallet_Edit
  ProviderWallet_View
  ProviderWallet_Edit
  DriverWallet_View
  DriverWallet_Edit
  RiderWallet_View
  RiderWallet_Edit
  ReviewParameter_Edit
  Payouts_View
  Payouts_Edit
  GiftBatch_View
  GiftBatch_Create
  GiftBatch_ViewCodes
  SMSProviders_View
  SMSProviders_Edit
}

enum TaxiPermission {
  DRIVER_VIEW
  DRIVER_EDIT
  ORDER_VIEW
  ORDER_EDIT
  REGION_VIEW
  REGION_EDIT
  VEHICLE_VIEW
  VEHICLE_EDIT
  FLEET_VIEW
  FLEET_EDIT
  PRICING_VIEW
  PRICING_EDIT
}

enum ShopPermission {
  SHOP_VIEW
  SHOP_EDIT
  ORDER_VIEW
  ORDER_EDIT
}

enum ParkingPermission {
  PARKING_VIEW
  PARKING_EDIT
  ORDER_VIEW
  ORDER_EDIT
}

type Media {
  id: ID!
  address: String!
  base64: String
}

type SessionInfo {
  createdAt: DateTime!
  lastActivityAt: DateTime
  ip: String
  ipLocation: String
  deviceName: String
  appType: AppType!
  devicePlatform: DevicePlatform!
  deviceType: DeviceType!
  token: String!
}

enum DevicePlatform {
  Android
  Ios
  Web
  MacOS
  Windows
  Linux
}

enum DeviceType {
  DESKTOP
  MOBILE
}

type OperatorSession {
  id: ID!
  sessionInfo: SessionInfo!
  operatorId: ID!
}

type Operator {
  id: ID!
  firstName: String!
  createdAt: DateTime
  updatedAt: DateTime
  lastName: String!
  userName: String!
  mobileNumber: String!
  lastActivity: DateTime
  enabledNotifications: [EnabledNotification!]!
  isBlocked: Boolean!
  email: String!
  roleId: ID!
  role: OperatorRole
  media: Media
  sessions(
    """Specify to filter the records returned."""
    filter: OperatorSessionFilter! = {}

    """Specify to sort results."""
    sorting: [OperatorSessionSort!]! = []
  ): [OperatorSession!]!
}

enum EnabledNotification {
  SOS
  SupportRequest
  NewOrder
  UserPendingVerification
}

input OperatorSessionFilter {
  and: [OperatorSessionFilter!]
  or: [OperatorSessionFilter!]
  id: IDFilterComparison
  operatorId: IDFilterComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input OperatorSessionSort {
  field: OperatorSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OperatorSessionSortFields {
  id
  operatorId
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type OperatorRoleDeleteResponse {
  id: ID
  title: String
  permissions: [OperatorPermission!]
  taxiPermissions: [TaxiPermission!]
  shopPermissions: [ShopPermission!]
  parkingPermissions: [ParkingPermission!]
  allowedApps: [AppType!]
}

type OperatorDeleteResponse {
  id: ID
  firstName: String
  createdAt: DateTime
  updatedAt: DateTime
  lastName: String
  userName: String
  mobileNumber: String
  lastActivity: DateTime
  enabledNotifications: [EnabledNotification!]
  isBlocked: Boolean
  email: String
  roleId: ID
}

type OperatorConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Operator!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TokenObject {
  token: String!
}

type CarColor {
  id: ID!
  name: String!
}

type CarModel {
  id: ID!
  name: String!
}

type CarModelDeleteResponse {
  id: ID
  name: String
}

type CarModelConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [CarModel!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CarColorDeleteResponse {
  id: ID
  name: String
}

type CarColorConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [CarColor!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaxiSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
  complaintId: ID!
  actor: Operator!
  assignedToStaffs: [Operator!]!
  unassignedFromStaffs: [Operator!]!
}

enum ComplaintActivityType {
  Create
  AssignToOperator
  UnassignFromOperators
  Update
  Resolved
  StatusChange
  Comment
}

enum ComplaintStatus {
  Submitted
  UnderInvestigation
  Resolved
}

type TaxiSupportRequest {
  id: ID!
  inscriptionTimestamp: DateTime!
  requestedByDriver: Boolean!
  subject: String!
  content: String
  status: ComplaintStatus!
  requestId: ID!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxiSupportRequestActivityAggregateFilter
  ): [TaxiSupportRequestActivitiesAggregateResponse!]!
  assignedToStaffsAggregate(
    """Filter to find records to aggregate on"""
    filter: OperatorAggregateFilter
  ): [TaxiSupportRequestAssignedToStaffsAggregateResponse!]!
  order: Order!
  activities(
    """Specify to filter the records returned."""
    filter: TaxiSupportRequestActivityFilter! = {}

    """Specify to sort results."""
    sorting: [TaxiSupportRequestActivitySort!]! = []
  ): [TaxiSupportRequestActivity!]!
  assignedToStaffs: [Operator!]!
}

input TaxiSupportRequestActivityAggregateFilter {
  and: [TaxiSupportRequestActivityAggregateFilter!]
  or: [TaxiSupportRequestActivityAggregateFilter!]
  id: IDFilterComparison
  complaintId: IDFilterComparison
}

input OperatorAggregateFilter {
  and: [OperatorAggregateFilter!]
  or: [OperatorAggregateFilter!]
  id: IDFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  userName: StringFieldComparison
  mobileNumber: StringFieldComparison
  isBlocked: BooleanFieldComparison
  email: StringFieldComparison
  roleId: IDFilterComparison
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input TaxiSupportRequestActivityFilter {
  and: [TaxiSupportRequestActivityFilter!]
  or: [TaxiSupportRequestActivityFilter!]
  id: IDFilterComparison
  complaintId: IDFilterComparison
}

input TaxiSupportRequestActivitySort {
  field: TaxiSupportRequestActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxiSupportRequestActivitySortFields {
  id
  complaintId
}

type RiderAddress {
  id: ID!
  type: RiderAddressType!
  title: String!
  details: String
  location: Point!
  riderId: ID!
}

type RiderWallet {
  id: ID!
  balance: Float!
  currency: String!
  riderId: ID!
  rider: Rider
}

type ParkingWallet {
  id: ID!
  balance: Float!
  currency: String!
  customerId: ID!
  customer: Rider!
}

type Rider {
  id: ID!
  status: RiderStatus!
  firstName: String!
  lastName: String!

  """
  Country ISO code. For example "GB" for United Kingdom, "CA" for Canada, "AU" for Australia, etc.
  """
  countryIso: String
  lastActivityAt: DateTime
  mobileNumber: String!
  registrationTimestamp: DateTime!
  email: String
  gender: Gender
  isResident: Boolean
  idNumber: String
  addressesAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderAddressAggregateFilter
  ): [RiderAddressesAggregateResponse!]!
  walletAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderWalletAggregateFilter
  ): [RiderWalletAggregateResponse!]!
  parkingWalletsAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingWalletAggregateFilter
  ): [RiderParkingWalletsAggregateResponse!]!
  transactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [RiderTransactionsAggregateResponse!]!
  ordersAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): [RiderOrdersAggregateResponse!]!
  media: Media
  addresses(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderAddressFilter! = {}

    """Specify to sort results."""
    sorting: [RiderAddressSort!]! = []
  ): RiderAddressesConnection!
  wallet(
    """Specify to filter the records returned."""
    filter: RiderWalletFilter! = {}

    """Specify to sort results."""
    sorting: [RiderWalletSort!]! = []
  ): [RiderWallet!]!
  parkingWallets(
    """Specify to filter the records returned."""
    filter: ParkingWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingWalletSort!]! = []
  ): [ParkingWallet!]!
  transactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): RiderTransactionsConnection!
  orders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter! = {}

    """Specify to sort results."""
    sorting: [OrderSort!]! = []
  ): RiderOrdersConnection!
}

enum RiderStatus {
  Enabled
  Disabled
}

enum Gender {
  Male
  Female
  Unknown
}

input RiderAddressAggregateFilter {
  and: [RiderAddressAggregateFilter!]
  or: [RiderAddressAggregateFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input RiderWalletAggregateFilter {
  and: [RiderWalletAggregateFilter!]
  or: [RiderWalletAggregateFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
}

input FloatFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: FloatFieldComparisonBetween
  notBetween: FloatFieldComparisonBetween
}

input FloatFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input ParkingWalletAggregateFilter {
  and: [ParkingWalletAggregateFilter!]
  or: [ParkingWalletAggregateFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  customerId: IDFilterComparison
}

input RiderTransactionAggregateFilter {
  and: [RiderTransactionAggregateFilter!]
  or: [RiderTransactionAggregateFilter!]
  id: IDFilterComparison
  action: TransactionActionFilterComparison
  createdAt: DateFieldComparison
  deductType: RiderDeductTransactionTypeFilterComparison
  rechargeType: RiderRechargeTransactionTypeFilterComparison
  status: TransactionStatusFilterComparison
  amount: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  savedPaymentMethodId: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  shopOrderId: IDFilterComparison
  parkOrderParkOwnerId: IDFilterComparison
  parkOrderCustomerId: IDFilterComparison
}

input TransactionActionFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TransactionAction
  neq: TransactionAction
  gt: TransactionAction
  gte: TransactionAction
  lt: TransactionAction
  lte: TransactionAction
  like: TransactionAction
  notLike: TransactionAction
  iLike: TransactionAction
  notILike: TransactionAction
  in: [TransactionAction!]
  notIn: [TransactionAction!]
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

input RiderDeductTransactionTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: RiderDeductTransactionType
  neq: RiderDeductTransactionType
  gt: RiderDeductTransactionType
  gte: RiderDeductTransactionType
  lt: RiderDeductTransactionType
  lte: RiderDeductTransactionType
  like: RiderDeductTransactionType
  notLike: RiderDeductTransactionType
  iLike: RiderDeductTransactionType
  notILike: RiderDeductTransactionType
  in: [RiderDeductTransactionType!]
  notIn: [RiderDeductTransactionType!]
}

enum RiderDeductTransactionType {
  OrderFee
  ParkingFee
  CancellationFee
  Withdraw
  Correction
}

input RiderRechargeTransactionTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: RiderRechargeTransactionType
  neq: RiderRechargeTransactionType
  gt: RiderRechargeTransactionType
  gte: RiderRechargeTransactionType
  lt: RiderRechargeTransactionType
  lte: RiderRechargeTransactionType
  like: RiderRechargeTransactionType
  notLike: RiderRechargeTransactionType
  iLike: RiderRechargeTransactionType
  notILike: RiderRechargeTransactionType
  in: [RiderRechargeTransactionType!]
  notIn: [RiderRechargeTransactionType!]
}

enum RiderRechargeTransactionType {
  BankTransfer
  Gift
  Correction
  InAppPayment
}

input TransactionStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TransactionStatus
  neq: TransactionStatus
  gt: TransactionStatus
  gte: TransactionStatus
  lt: TransactionStatus
  lte: TransactionStatus
  like: TransactionStatus
  notLike: TransactionStatus
  iLike: TransactionStatus
  notILike: TransactionStatus
  in: [TransactionStatus!]
  notIn: [TransactionStatus!]
}

enum TransactionStatus {
  Processing
  Done
  Canceled
  Rejected
}

input OrderAggregateFilter {
  and: [OrderAggregateFilter!]
  or: [OrderAggregateFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input OrderStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: OrderStatus
  neq: OrderStatus
  gt: OrderStatus
  gte: OrderStatus
  lt: OrderStatus
  lte: OrderStatus
  like: OrderStatus
  notLike: OrderStatus
  iLike: OrderStatus
  notILike: OrderStatus
  in: [OrderStatus!]
  notIn: [OrderStatus!]
}

input IntFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Int
  neq: Int
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  in: [Int!]
  notIn: [Int!]
  between: IntFieldComparisonBetween
  notBetween: IntFieldComparisonBetween
}

input IntFieldComparisonBetween {
  lower: Int!
  upper: Int!
}

input PaymentModeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PaymentMode
  neq: PaymentMode
  gt: PaymentMode
  gte: PaymentMode
  lt: PaymentMode
  lte: PaymentMode
  like: PaymentMode
  notLike: PaymentMode
  iLike: PaymentMode
  notILike: PaymentMode
  in: [PaymentMode!]
  notIn: [PaymentMode!]
}

"""The means of payment for an order."""
enum PaymentMode {
  Cash
  SavedPaymentMethod
  PaymentGateway
  Wallet
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

input RiderAddressFilter {
  and: [RiderAddressFilter!]
  or: [RiderAddressFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input RiderAddressSort {
  field: RiderAddressSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderAddressSortFields {
  id
  riderId
}

input RiderWalletFilter {
  and: [RiderWalletFilter!]
  or: [RiderWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
}

input RiderWalletSort {
  field: RiderWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderWalletSortFields {
  id
  balance
  currency
  riderId
}

input ParkingWalletFilter {
  and: [ParkingWalletFilter!]
  or: [ParkingWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  customerId: IDFilterComparison
}

input ParkingWalletSort {
  field: ParkingWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingWalletSortFields {
  id
  balance
  currency
  customerId
}

input RiderTransactionFilter {
  and: [RiderTransactionFilter!]
  or: [RiderTransactionFilter!]
  id: IDFilterComparison
  action: TransactionActionFilterComparison
  createdAt: DateFieldComparison
  deductType: RiderDeductTransactionTypeFilterComparison
  rechargeType: RiderRechargeTransactionTypeFilterComparison
  status: TransactionStatusFilterComparison
  amount: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  savedPaymentMethodId: IDFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  shopOrderId: IDFilterComparison
  parkOrderParkOwnerId: IDFilterComparison
  parkOrderCustomerId: IDFilterComparison
}

input RiderTransactionSort {
  field: RiderTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderTransactionSortFields {
  id
  action
  createdAt
  deductType
  rechargeType
  status
  amount
  currency
  riderId
  paymentGatewayId
  savedPaymentMethodId
  operatorId
  requestId
  shopOrderId
  parkOrderParkOwnerId
  parkOrderCustomerId
}

input OrderFilter {
  and: [OrderFilter!]
  or: [OrderFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input OrderSort {
  field: OrderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderSortFields {
  id
  createdOn
  status
  distanceBest
  durationBest
  costBest
  costAfterCoupon
  currency
  riderId
  paymentMode
  driverId
  regionId
  fleetId
  serviceId
}

type SavedPaymentMethod {
  id: ID!
  title: String!
  lastFour: String
  isDefault: Boolean!
  type: SavedPaymentMethodType!
  providerBrand: ProviderBrand
  expiryDate: DateTime
  holderName: String
}

"""Saved payment method type"""
enum SavedPaymentMethodType {
  CARD
  BANK_ACCOUNT
}

"""Brand of the provider wether bank name or card provider"""
enum ProviderBrand {
  Visa
  Mastercard
  Amex
  Discover
  Diners
  EftPosAu
  JCB
  UnionPay
  Unknown
}

type RiderTransaction {
  id: ID!
  action: TransactionAction!
  createdAt: DateTime!
  deductType: RiderDeductTransactionType!
  rechargeType: RiderRechargeTransactionType!
  status: TransactionStatus!
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  riderId: ID!
  paymentGatewayId: ID!
  savedPaymentMethodId: ID!
  operatorId: ID!
  requestId: ID!
  shopOrderId: ID!
  parkOrderParkOwnerId: ID!
  parkOrderCustomerId: ID!
  operator: Operator
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  rider: Rider!
}

type PaymentGateway {
  id: ID!
  enabled: Boolean!
  title: String!
  type: PaymentGatewayType!
  publicKey: String
  privateKey: String!
  merchantId: String
  saltKey: String
  mediaId: ID!
  riderTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [PaymentGatewayRiderTransactionsAggregateResponse!]!
  media: Media
  riderTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): PaymentGatewayRiderTransactionsConnection!
}

enum PaymentGatewayType {
  Stripe
  BrainTree
  PayPal
  Paytm
  Razorpay
  Paystack
  PayU
  Instamojo
  Flutterwave
  PayGate
  MIPS
  MercadoPago
  AmazonPaymentServices
  MyTMoney
  WayForPay
  MyFatoorah
  SberBank
  BinancePay
  OpenPix
  PayTR
  CustomLink
}

type PayoutMethod {
  id: ID!
  enabled: Boolean!
  currency: String!
  name: String!
  description: String
  type: PayoutMethodType!
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: String
  mediaId: ID!
  balance: Float
  media: Media
  driverTransactions: DriverTransaction!
}

"""The type of payout method"""
enum PayoutMethodType {
  Stripe
  BankTransfer
}

type PayoutAccount {
  id: ID!
  name: String!
  type: SavedPaymentMethodType!
  last4: String!
  currency: String!
  payoutMethodId: ID!
  isDefault: Boolean!
  accountNumber: String
  routingNumber: String
  accountHolderName: String
  bankName: String
  branchName: String
  accountHolderAddress: String
  accountHolderCity: String
  accountHolderState: String
  accountHolderZip: String
  accountHolderCountry: String
  accountHolderPhone: String
  accountHolderDateOfBirth: DateTime
  isVerified: Boolean!
  payoutMethod: PayoutMethod!
}

type FeedbackParameter {
  id: ID!
  title: String!
  isGood: Boolean!
  feedbacksAggregate(
    """Filter to find records to aggregate on"""
    filter: FeedbackParameterAggregateFilter
  ): [FeedbackParameterFeedbacksAggregateResponse!]!
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [FeedbackParameterSort!]! = []
  ): FeedbackParameterFeedbacksConnection!
}

input FeedbackParameterAggregateFilter {
  and: [FeedbackParameterAggregateFilter!]
  or: [FeedbackParameterAggregateFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input FeedbackParameterFilter {
  and: [FeedbackParameterFilter!]
  or: [FeedbackParameterFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input FeedbackParameterSort {
  field: FeedbackParameterSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FeedbackParameterSortFields {
  id
  title
  isGood
}

type Feedback {
  id: ID!
  score: Int!
  reviewTimestamp: DateTime!
  description: String
  driverId: ID!
  requestId: ID!
  parametersAggregate(
    """Filter to find records to aggregate on"""
    filter: FeedbackParameterAggregateFilter
  ): [FeedbackParametersAggregateResponse!]!
  driver: Driver!
  request: Order!
  parameters(
    """Specify to filter the records returned."""
    filter: FeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [FeedbackParameterSort!]! = []
  ): [FeedbackParameter!]!
}

type DriverWallet {
  id: ID!
  balance: Float!
  currency: String!
  driverId: ID!
  driver: Driver
}

type DriverSession {
  id: ID!
  sessionInfo: SessionInfo!
  driverId: ID!
}

type DriverDocumentRetentionPolicy {
  id: ID!
  title: String!
  deleteAfterDays: Int!
}

type DriverDocument {
  id: ID!
  title: String!
  isEnabled: Boolean!
  isRequired: Boolean!
  hasExpiryDate: Boolean!
  notificationDaysBeforeExpiry: Int!
  numberOfImages: Int!
  retentionPolicies(
    """Specify to filter the records returned."""
    filter: DriverDocumentRetentionPolicyFilter! = {}

    """Specify to sort results."""
    sorting: [DriverDocumentRetentionPolicySort!]! = []
  ): [DriverDocumentRetentionPolicy!]!
}

input DriverDocumentRetentionPolicyFilter {
  and: [DriverDocumentRetentionPolicyFilter!]
  or: [DriverDocumentRetentionPolicyFilter!]
  id: IDFilterComparison
}

input DriverDocumentRetentionPolicySort {
  field: DriverDocumentRetentionPolicySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverDocumentRetentionPolicySortFields {
  id
}

type DriverToDriverDocument {
  id: ID!
  driverId: ID!
  driverDocumentId: ID!
  mediaId: ID!
  retentionPolicyId: ID!
  expiresAt: DateTime
  driver: Driver!
  driverDocument: DriverDocument!
  media: Media!
  retentionPolicy: DriverDocumentRetentionPolicy
}

type DriverServicesServiceDTO {
  driverId: ID!
  serviceId: ID!
  driverEnabled: Boolean!
  service: Service!
}

type Driver {
  id: ID!
  fleetId: ID!
  firstName: String
  lastName: String!
  mobileNumber: String!
  countryIso: String
  certificateNumber: String
  canDeliver: Boolean!
  maxDeliveryPackageSize: DeliveryPackageSize!
  email: String
  carProductionYear: Int!
  carId: ID!
  carColorId: ID!
  carPlate: String
  status: DriverStatus!
  gender: Gender
  rating: Float!
  reviewCount: Int!
  registrationTimestamp: DateTime!
  lastSeenTimestamp: DateTime
  accountNumber: String
  bankName: String
  bankRoutingNumber: String
  bankSwift: String
  address: String
  softRejectionNote: String
  mediaId: ID!
  feedbacksAggregate(
    """Filter to find records to aggregate on"""
    filter: FeedbackAggregateFilter
  ): [DriverFeedbacksAggregateResponse!]!
  walletAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverWalletAggregateFilter
  ): [DriverWalletAggregateResponse!]!
  sessionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverSessionAggregateFilter
  ): [DriverSessionsAggregateResponse!]!
  enabledServicesAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverServicesServiceDTOAggregateFilter
  ): [DriverEnabledServicesAggregateResponse!]!
  driverToDriverDocumentsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverToDriverDocumentAggregateFilter
  ): [DriverDriverToDriverDocumentsAggregateResponse!]!
  transactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [DriverTransactionsAggregateResponse!]!
  ordersAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): [DriverOrdersAggregateResponse!]!
  payoutAccountsAggregate(
    """Filter to find records to aggregate on"""
    filter: PayoutAccountAggregateFilter
  ): [DriverPayoutAccountsAggregateResponse!]!
  media: Media
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [FeedbackSort!]! = []
  ): DriverFeedbacksConnection!
  wallet(
    """Specify to filter the records returned."""
    filter: DriverWalletFilter! = {}

    """Specify to sort results."""
    sorting: [DriverWalletSort!]! = []
  ): [DriverWallet!]!
  sessions(
    """Specify to filter the records returned."""
    filter: DriverSessionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverSessionSort!]! = []
  ): [DriverSession!]!
  enabledServices(
    """Specify to filter the records returned."""
    filter: DriverServicesServiceDTOFilter! = {}

    """Specify to sort results."""
    sorting: [DriverServicesServiceDTOSort!]! = []
  ): [DriverServicesServiceDTO!]!
  driverToDriverDocuments(
    """Specify to filter the records returned."""
    filter: DriverToDriverDocumentFilter! = {}

    """Specify to sort results."""
    sorting: [DriverToDriverDocumentSort!]! = []
  ): [DriverToDriverDocument!]!
  transactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): DriverTransactionsConnection!
  orders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter! = {}

    """Specify to sort results."""
    sorting: [OrderSort!]! = []
  ): DriverOrdersConnection!
  payoutAccounts(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: PayoutAccountFilter! = {}

    """Specify to sort results."""
    sorting: [PayoutAccountSort!]! = []
  ): DriverPayoutAccountsConnection!
}

enum DeliveryPackageSize {
  Small
  Medium
  Large
}

enum DriverStatus {
  Online
  Offline
  Blocked
  InService
  WaitingDocuments
  PendingApproval
  SoftReject
  HardReject
}

input FeedbackAggregateFilter {
  and: [FeedbackAggregateFilter!]
  or: [FeedbackAggregateFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
  requestId: IDFilterComparison
  request: FeedbackAggregateFilterOrderAggregateFilter
  parameters: FeedbackAggregateFilterFeedbackParameterAggregateFilter
}

input FeedbackAggregateFilterOrderAggregateFilter {
  and: [FeedbackAggregateFilterOrderAggregateFilter!]
  or: [FeedbackAggregateFilterOrderAggregateFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input FeedbackAggregateFilterFeedbackParameterAggregateFilter {
  and: [FeedbackAggregateFilterFeedbackParameterAggregateFilter!]
  or: [FeedbackAggregateFilterFeedbackParameterAggregateFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input DriverWalletAggregateFilter {
  and: [DriverWalletAggregateFilter!]
  or: [DriverWalletAggregateFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
}

input DriverSessionAggregateFilter {
  and: [DriverSessionAggregateFilter!]
  or: [DriverSessionAggregateFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
}

input DriverServicesServiceDTOAggregateFilter {
  and: [DriverServicesServiceDTOAggregateFilter!]
  or: [DriverServicesServiceDTOAggregateFilter!]
  driverId: IDFilterComparison
  serviceId: IDFilterComparison
}

input DriverToDriverDocumentAggregateFilter {
  and: [DriverToDriverDocumentAggregateFilter!]
  or: [DriverToDriverDocumentAggregateFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
}

input DriverTransactionAggregateFilter {
  and: [DriverTransactionAggregateFilter!]
  or: [DriverTransactionAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  action: TransactionActionFilterComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  payoutMethod: DriverTransactionAggregateFilterPayoutMethodAggregateFilter
}

input NumberFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: NumberFieldComparisonBetween
  notBetween: NumberFieldComparisonBetween
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input DriverTransactionAggregateFilterPayoutMethodAggregateFilter {
  and: [DriverTransactionAggregateFilterPayoutMethodAggregateFilter!]
  or: [DriverTransactionAggregateFilterPayoutMethodAggregateFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

input PayoutMethodTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PayoutMethodType
  neq: PayoutMethodType
  gt: PayoutMethodType
  gte: PayoutMethodType
  lt: PayoutMethodType
  lte: PayoutMethodType
  like: PayoutMethodType
  notLike: PayoutMethodType
  iLike: PayoutMethodType
  notILike: PayoutMethodType
  in: [PayoutMethodType!]
  notIn: [PayoutMethodType!]
}

input PayoutAccountAggregateFilter {
  and: [PayoutAccountAggregateFilter!]
  or: [PayoutAccountAggregateFilter!]
  id: IDFilterComparison
  isDefault: BooleanFieldComparison
}

input FeedbackFilter {
  and: [FeedbackFilter!]
  or: [FeedbackFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
  requestId: IDFilterComparison
  request: FeedbackFilterOrderFilter
  parameters: FeedbackFilterFeedbackParameterFilter
}

input FeedbackFilterOrderFilter {
  and: [FeedbackFilterOrderFilter!]
  or: [FeedbackFilterOrderFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input FeedbackFilterFeedbackParameterFilter {
  and: [FeedbackFilterFeedbackParameterFilter!]
  or: [FeedbackFilterFeedbackParameterFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  isGood: BooleanFieldComparison
}

input FeedbackSort {
  field: FeedbackSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FeedbackSortFields {
  id
  driverId
  requestId
}

input DriverWalletFilter {
  and: [DriverWalletFilter!]
  or: [DriverWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
}

input DriverWalletSort {
  field: DriverWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverWalletSortFields {
  id
  balance
  currency
  driverId
}

input DriverSessionFilter {
  and: [DriverSessionFilter!]
  or: [DriverSessionFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
}

input DriverSessionSort {
  field: DriverSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverSessionSortFields {
  id
  driverId
}

input DriverServicesServiceDTOFilter {
  and: [DriverServicesServiceDTOFilter!]
  or: [DriverServicesServiceDTOFilter!]
  driverId: IDFilterComparison
  serviceId: IDFilterComparison
}

input DriverServicesServiceDTOSort {
  field: DriverServicesServiceDTOSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverServicesServiceDTOSortFields {
  driverId
  serviceId
}

input DriverToDriverDocumentFilter {
  and: [DriverToDriverDocumentFilter!]
  or: [DriverToDriverDocumentFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison
}

input DriverToDriverDocumentSort {
  field: DriverToDriverDocumentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverToDriverDocumentSortFields {
  id
  driverId
}

input DriverTransactionFilter {
  and: [DriverTransactionFilter!]
  or: [DriverTransactionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  action: TransactionActionFilterComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  payoutMethod: DriverTransactionFilterPayoutMethodFilter
}

input DriverTransactionFilterPayoutMethodFilter {
  and: [DriverTransactionFilterPayoutMethodFilter!]
  or: [DriverTransactionFilterPayoutMethodFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

input DriverTransactionSort {
  field: DriverTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverTransactionSortFields {
  id
  createdAt
  action
  status
  amount
  currency
  driverId
  paymentGatewayId
  payoutSessionId
  payoutAccountId
  payoutMethodId
  payoutSessionMethodId
}

input PayoutAccountFilter {
  and: [PayoutAccountFilter!]
  or: [PayoutAccountFilter!]
  id: IDFilterComparison
  isDefault: BooleanFieldComparison
}

input PayoutAccountSort {
  field: PayoutAccountSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PayoutAccountSortFields {
  id
  isDefault
}

type DriverTransaction {
  id: ID!
  createdAt: DateTime!
  action: TransactionAction!
  status: TransactionStatus!
  deductType: DriverDeductTransactionType
  rechargeType: DriverRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  driverId: ID!
  paymentGatewayId: ID!
  payoutSessionId: ID!
  payoutAccountId: ID!
  payoutMethodId: ID!
  payoutSessionMethodId: ID!
  operatorId: ID!
  requestId: ID!
  description: String
  operator: Operator
  driver: Driver
  payoutAccount: PayoutAccount
  payoutMethod: PayoutMethod
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
}

enum DriverDeductTransactionType {
  Withdraw
  Commission
  Correction
}

enum DriverRechargeTransactionType {
  OrderFee
  BankTransfer
  InAppPayment
  Gift
}

type FleetTransaction {
  id: ID!
  transactionTimestamp: DateTime!
  status: TransactionStatus!
  action: TransactionAction!
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  operatorId: ID!
  requestId: ID!
  fleetId: ID!
  operator: Operator
}

type OrderMessage {
  id: ID!
  sentAt: DateTime!
  sentByDriver: Boolean!
  status: MessageStatus!
  content: String!
}

enum MessageStatus {
  Sent
  Delivered
  Seen
}

type RequestActivity {
  id: ID!
  createdAt: DateTime!
  type: RequestActivityType!
}

enum RequestActivityType {
  RequestedByOperator
  BookedByOperator
  RequestedByRider
  BookedByRider
  DriverAccepted
  ArrivedToPickupPoint
  CanceledByDriver
  CanceledByRider
  CanceledByOperator
  Started
  ArrivedToDestination
  Paid
  Reviewed
  Expired
}

type ZonePrice {
  id: ID!
  name: String!
  from: [[Point!]!]!
  to: [[Point!]!]!
  cost: Float!
  timeMultipliers: [TimeMultiplier!]!
  fleets(
    """Specify to filter the records returned."""
    filter: FleetFilter! = {}

    """Specify to sort results."""
    sorting: [FleetSort!]! = []
  ): [Fleet!]!
  services(
    """Specify to filter the records returned."""
    filter: ServiceFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

input FleetFilter {
  and: [FleetFilter!]
  or: [FleetFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
}

input FleetSort {
  field: FleetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetSortFields {
  id
  name
}

input ServiceFilter {
  and: [ServiceFilter!]
  or: [ServiceFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  categoryId: IDFilterComparison
}

input ServiceSort {
  field: ServiceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceSortFields {
  id
  name
  categoryId
}

type FleetWallet {
  id: ID!
  balance: Float!
  currency: String!
  fleetId: ID!
  fleet: Fleet!
}

type Fleet {
  id: ID!
  name: String!
  createdAt: DateTime
  isBlocked: Boolean!
  phoneNumber: String!
  mobileNumber: String!
  userName: String
  password: String
  accountNumber: String!
  commissionSharePercent: Float!
  commissionShareFlat: Float!
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[Point!]!]
  driversAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverAggregateFilter
  ): [FleetDriversAggregateResponse!]!
  profilePicture: Media
  wallet(
    """Specify to filter the records returned."""
    filter: FleetWalletFilter! = {}

    """Specify to sort results."""
    sorting: [FleetWalletSort!]! = []
  ): [FleetWallet!]!
  transactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FleetTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [FleetTransactionSort!]! = []
  ): FleetTransactionsConnection!
  zonePrices(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZonePriceFilter! = {}

    """Specify to sort results."""
    sorting: [ZonePriceSort!]! = []
  ): FleetZonePricesConnection!
  drivers(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverFilter! = {}

    """Specify to sort results."""
    sorting: [DriverSort!]! = []
  ): FleetDriversConnection!
}

input DriverAggregateFilter {
  and: [DriverAggregateFilter!]
  or: [DriverAggregateFilter!]
  id: IDFilterComparison
  fleetId: IDFilterComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  maxDeliveryPackageSize: DeliveryPackageSizeFilterComparison
  carId: IDFilterComparison
  carColorId: IDFilterComparison
  status: DriverStatusFilterComparison
  gender: GenderFilterComparison
  rating: NumberFieldComparison
  reviewCount: IntFieldComparison
}

input DeliveryPackageSizeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: DeliveryPackageSize
  neq: DeliveryPackageSize
  gt: DeliveryPackageSize
  gte: DeliveryPackageSize
  lt: DeliveryPackageSize
  lte: DeliveryPackageSize
  like: DeliveryPackageSize
  notLike: DeliveryPackageSize
  iLike: DeliveryPackageSize
  notILike: DeliveryPackageSize
  in: [DeliveryPackageSize!]
  notIn: [DeliveryPackageSize!]
}

input DriverStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: DriverStatus
  neq: DriverStatus
  gt: DriverStatus
  gte: DriverStatus
  lt: DriverStatus
  lte: DriverStatus
  like: DriverStatus
  notLike: DriverStatus
  iLike: DriverStatus
  notILike: DriverStatus
  in: [DriverStatus!]
  notIn: [DriverStatus!]
}

input GenderFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: Gender
  neq: Gender
  gt: Gender
  gte: Gender
  lt: Gender
  lte: Gender
  like: Gender
  notLike: Gender
  iLike: Gender
  notILike: Gender
  in: [Gender!]
  notIn: [Gender!]
}

input FleetWalletFilter {
  and: [FleetWalletFilter!]
  or: [FleetWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  fleetId: IDFilterComparison
}

input FleetWalletSort {
  field: FleetWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetWalletSortFields {
  id
  balance
  currency
  fleetId
}

input FleetTransactionFilter {
  and: [FleetTransactionFilter!]
  or: [FleetTransactionFilter!]
  id: IDFilterComparison
  status: TransactionStatusFilterComparison
  action: TransactionActionFilterComparison
  deductType: ProviderDeductTransactionTypeFilterComparison
  rechargeType: ProviderRechargeTransactionTypeFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  fleetId: IDFilterComparison
}

input ProviderDeductTransactionTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ProviderDeductTransactionType
  neq: ProviderDeductTransactionType
  gt: ProviderDeductTransactionType
  gte: ProviderDeductTransactionType
  lt: ProviderDeductTransactionType
  lte: ProviderDeductTransactionType
  like: ProviderDeductTransactionType
  notLike: ProviderDeductTransactionType
  iLike: ProviderDeductTransactionType
  notILike: ProviderDeductTransactionType
  in: [ProviderDeductTransactionType!]
  notIn: [ProviderDeductTransactionType!]
}

input ProviderRechargeTransactionTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ProviderRechargeTransactionType
  neq: ProviderRechargeTransactionType
  gt: ProviderRechargeTransactionType
  gte: ProviderRechargeTransactionType
  lt: ProviderRechargeTransactionType
  lte: ProviderRechargeTransactionType
  like: ProviderRechargeTransactionType
  notLike: ProviderRechargeTransactionType
  iLike: ProviderRechargeTransactionType
  notILike: ProviderRechargeTransactionType
  in: [ProviderRechargeTransactionType!]
  notIn: [ProviderRechargeTransactionType!]
}

input FleetTransactionSort {
  field: FleetTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetTransactionSortFields {
  id
  status
  action
  deductType
  rechargeType
  operatorId
  requestId
  fleetId
}

input ZonePriceFilter {
  and: [ZonePriceFilter!]
  or: [ZonePriceFilter!]
  id: IDFilterComparison
}

input ZonePriceSort {
  field: ZonePriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ZonePriceSortFields {
  id
}

input DriverFilter {
  and: [DriverFilter!]
  or: [DriverFilter!]
  id: IDFilterComparison
  fleetId: IDFilterComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  maxDeliveryPackageSize: DeliveryPackageSizeFilterComparison
  carId: IDFilterComparison
  carColorId: IDFilterComparison
  status: DriverStatusFilterComparison
  gender: GenderFilterComparison
  rating: NumberFieldComparison
  reviewCount: IntFieldComparison
}

input DriverSort {
  field: DriverSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverSortFields {
  id
  fleetId
  lastName
  mobileNumber
  maxDeliveryPackageSize
  carId
  carColorId
  status
  gender
  rating
  reviewCount
}

type ServiceOption {
  id: ID!
  name: String!
  type: ServiceOptionType!
  additionalFee: Float
  icon: ServiceOptionIcon!
}

enum ServiceOptionType {
  Free
  Paid
  TwoWay
}

enum ServiceOptionIcon {
  Pet
  TwoWay
  Luggage
  PackageDelivery
  Shopping
  Custom1
  Custom2
  Custom3
  Custom4
  Custom5
}

type Order {
  id: ID!
  createdOn: DateTime!
  startTimestamp: DateTime
  finishTimestamp: DateTime
  status: OrderStatus!
  distanceBest: Int!
  durationBest: Int!
  costBest: Float!
  costAfterCoupon: Float!
  waitCost: Float!
  rideOptionsCost: Float!
  taxCost: Float!
  serviceCost: Float!
  currency: String!
  destinationArrivedTo: Int!
  waitMinutes: Float!
  addresses: [String!]!
  points: [Point!]!
  expectedTimestamp: DateTime
  riderId: ID!
  paymentMode: PaymentMode!
  driverId: ID!
  regionId: ID
  fleetId: ID
  serviceId: ID
  directions: [Point!]
  complaintsAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxiSupportRequestAggregateFilter
  ): [OrderComplaintsAggregateResponse!]!
  conversationAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderMessageAggregateFilter
  ): [OrderConversationAggregateResponse!]!
  riderTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [OrderRiderTransactionsAggregateResponse!]!
  driverTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [OrderDriverTransactionsAggregateResponse!]!
  fleetTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: FleetTransactionAggregateFilter
  ): [OrderFleetTransactionsAggregateResponse!]!
  providerTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProviderTransactionAggregateFilter
  ): [OrderProviderTransactionsAggregateResponse!]!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: RequestActivityAggregateFilter
  ): [OrderActivitiesAggregateResponse!]!
  optionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ServiceOptionAggregateFilter
  ): [OrderOptionsAggregateResponse!]!
  driver: Driver
  rider: Rider
  service: Service
  coupon: Coupon
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  fleet: Fleet
  complaints(
    """Specify to filter the records returned."""
    filter: TaxiSupportRequestFilter! = {}

    """Specify to sort results."""
    sorting: [TaxiSupportRequestSort!]! = []
  ): [TaxiSupportRequest!]!
  conversation(
    """Specify to filter the records returned."""
    filter: OrderMessageFilter! = {}

    """Specify to sort results."""
    sorting: [OrderMessageSort!]! = []
  ): [OrderMessage!]!
  riderTransactions(
    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): [RiderTransaction!]!
  driverTransactions(
    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): [DriverTransaction!]!
  fleetTransactions(
    """Specify to filter the records returned."""
    filter: FleetTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [FleetTransactionSort!]! = []
  ): [FleetTransaction!]!
  providerTransactions(
    """Specify to filter the records returned."""
    filter: ProviderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ProviderTransactionSort!]! = []
  ): [ProviderTransaction!]!
  activities(
    """Specify to filter the records returned."""
    filter: RequestActivityFilter! = {}

    """Specify to sort results."""
    sorting: [RequestActivitySort!]! = []
  ): [RequestActivity!]!
  options(
    """Specify to filter the records returned."""
    filter: ServiceOptionFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceOptionSort!]! = []
  ): [ServiceOption!]!
}

input TaxiSupportRequestAggregateFilter {
  and: [TaxiSupportRequestAggregateFilter!]
  or: [TaxiSupportRequestAggregateFilter!]
  id: IDFilterComparison
  requestedByDriver: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  requestId: IDFilterComparison
  order: TaxiSupportRequestAggregateFilterOrderAggregateFilter
}

input ComplaintStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ComplaintStatus
  neq: ComplaintStatus
  gt: ComplaintStatus
  gte: ComplaintStatus
  lt: ComplaintStatus
  lte: ComplaintStatus
  like: ComplaintStatus
  notLike: ComplaintStatus
  iLike: ComplaintStatus
  notILike: ComplaintStatus
  in: [ComplaintStatus!]
  notIn: [ComplaintStatus!]
}

input TaxiSupportRequestAggregateFilterOrderAggregateFilter {
  and: [TaxiSupportRequestAggregateFilterOrderAggregateFilter!]
  or: [TaxiSupportRequestAggregateFilterOrderAggregateFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input OrderMessageAggregateFilter {
  and: [OrderMessageAggregateFilter!]
  or: [OrderMessageAggregateFilter!]
  id: IDFilterComparison
}

input FleetTransactionAggregateFilter {
  and: [FleetTransactionAggregateFilter!]
  or: [FleetTransactionAggregateFilter!]
  id: IDFilterComparison
  status: TransactionStatusFilterComparison
  action: TransactionActionFilterComparison
  deductType: ProviderDeductTransactionTypeFilterComparison
  rechargeType: ProviderRechargeTransactionTypeFilterComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  fleetId: IDFilterComparison
}

input ProviderTransactionAggregateFilter {
  and: [ProviderTransactionAggregateFilter!]
  or: [ProviderTransactionAggregateFilter!]
  id: IDFilterComparison
  action: TransactionActionFilterComparison
  deductType: ProviderDeductTransactionTypeFilterComparison
  rechargeType: ProviderRechargeTransactionTypeFilterComparison
  expenseType: ProviderExpenseTypeFilterComparison
  amount: NumberFieldComparison
  currency: StringFieldComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  parkOrderId: IDFilterComparison
  shopOrderCartId: IDFilterComparison
}

input ProviderExpenseTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ProviderExpenseType
  neq: ProviderExpenseType
  gt: ProviderExpenseType
  gte: ProviderExpenseType
  lt: ProviderExpenseType
  lte: ProviderExpenseType
  like: ProviderExpenseType
  notLike: ProviderExpenseType
  iLike: ProviderExpenseType
  notILike: ProviderExpenseType
  in: [ProviderExpenseType!]
  notIn: [ProviderExpenseType!]
}

input RequestActivityAggregateFilter {
  and: [RequestActivityAggregateFilter!]
  or: [RequestActivityAggregateFilter!]
  id: IDFilterComparison
}

input ServiceOptionAggregateFilter {
  and: [ServiceOptionAggregateFilter!]
  or: [ServiceOptionAggregateFilter!]
  id: IDFilterComparison
}

input TaxiSupportRequestFilter {
  and: [TaxiSupportRequestFilter!]
  or: [TaxiSupportRequestFilter!]
  id: IDFilterComparison
  requestedByDriver: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  requestId: IDFilterComparison
  order: TaxiSupportRequestFilterOrderFilter
}

input TaxiSupportRequestFilterOrderFilter {
  and: [TaxiSupportRequestFilterOrderFilter!]
  or: [TaxiSupportRequestFilterOrderFilter!]
  id: IDFilterComparison
  createdOn: DateFieldComparison
  status: OrderStatusFilterComparison
  distanceBest: IntFieldComparison
  durationBest: IntFieldComparison
  costBest: FloatFieldComparison
  costAfterCoupon: FloatFieldComparison
  currency: StringFieldComparison
  riderId: IDFilterComparison
  paymentMode: PaymentModeFilterComparison
  driverId: IDFilterComparison
  regionId: IDFilterComparison
  fleetId: IDFilterComparison
  serviceId: IDFilterComparison
}

input TaxiSupportRequestSort {
  field: TaxiSupportRequestSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxiSupportRequestSortFields {
  id
  requestedByDriver
  status
  requestId
}

input OrderMessageFilter {
  and: [OrderMessageFilter!]
  or: [OrderMessageFilter!]
  id: IDFilterComparison
}

input OrderMessageSort {
  field: OrderMessageSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderMessageSortFields {
  id
}

input ProviderTransactionFilter {
  and: [ProviderTransactionFilter!]
  or: [ProviderTransactionFilter!]
  id: IDFilterComparison
  action: TransactionActionFilterComparison
  deductType: ProviderDeductTransactionTypeFilterComparison
  rechargeType: ProviderRechargeTransactionTypeFilterComparison
  expenseType: ProviderExpenseTypeFilterComparison
  amount: NumberFieldComparison
  currency: StringFieldComparison
  operatorId: IDFilterComparison
  requestId: IDFilterComparison
  parkOrderId: IDFilterComparison
  shopOrderCartId: IDFilterComparison
}

input ProviderTransactionSort {
  field: ProviderTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProviderTransactionSortFields {
  id
  action
  deductType
  rechargeType
  expenseType
  amount
  currency
  operatorId
  requestId
  parkOrderId
  shopOrderCartId
}

input RequestActivityFilter {
  and: [RequestActivityFilter!]
  or: [RequestActivityFilter!]
  id: IDFilterComparison
}

input RequestActivitySort {
  field: RequestActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RequestActivitySortFields {
  id
}

input ServiceOptionFilter {
  and: [ServiceOptionFilter!]
  or: [ServiceOptionFilter!]
  id: IDFilterComparison
}

input ServiceOptionSort {
  field: ServiceOptionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceOptionSortFields {
  id
}

type RegionCategory {
  id: ID!
  name: String!
  currency: String!
  regionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RegionAggregateFilter
  ): [RegionCategoryRegionsAggregateResponse!]!
  regions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RegionFilter! = {}

    """Specify to sort results."""
    sorting: [RegionSort!]! = []
  ): RegionCategoryRegionsConnection!
}

input RegionAggregateFilter {
  and: [RegionAggregateFilter!]
  or: [RegionAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  currency: StringFieldComparison
  categoryId: IDFilterComparison
}

input RegionFilter {
  and: [RegionFilter!]
  or: [RegionFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  currency: StringFieldComparison
  categoryId: IDFilterComparison
}

input RegionSort {
  field: RegionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RegionSortFields {
  id
  name
  currency
  categoryId
}

type Region {
  id: ID!
  name: String!
  currency: String!
  enabled: Boolean!
  location: [[Point!]!]!
  categoryId: ID!
  taxiOrdersAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): [RegionTaxiOrdersAggregateResponse!]!
  category: RegionCategory
  taxiOrders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter! = {}

    """Specify to sort results."""
    sorting: [OrderSort!]! = []
  ): RegionTaxiOrdersConnection!
}

type Service {
  id: ID!
  name: String!
  description: String
  orderTypes: [TaxiOrderType!]!
  personCapacity: Int!
  categoryId: ID!
  baseFare: Float!
  roundingFactor: Float
  perHundredMeters: Float!
  perMinuteDrive: Float!
  perMinuteWait: Float!
  prepayPercent: Float!
  minimumFee: Float!
  searchRadius: Int!
  paymentMethod: ServicePaymentMethod!
  cancellationTotalFee: Float!
  cancellationDriverShare: Float!
  providerSharePercent: Int!
  providerShareFlat: Float!
  twoWayAvailable: Boolean!
  maximumDestinationDistance: Int!
  timeMultipliers: [TimeMultiplier!]!
  distanceMultipliers: [DistanceMultiplier!]!
  weekdayMultipliers: [WeekdayMultiplier!]!
  dateRangeMultipliers: [DateRangeMultiplier!]!
  mediaId: ID!
  media: Media!
  regions(
    """Specify to filter the records returned."""
    filter: RegionFilter! = {}

    """Specify to sort results."""
    sorting: [RegionSort!]! = []
  ): [Region!]!
  options(
    """Specify to filter the records returned."""
    filter: ServiceOptionFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceOptionSort!]! = []
  ): [ServiceOption!]!
}

"""
Different types of taxi orders, including ride, rideshare, parcel delivery, food delivery, and shop delivery.
"""
enum TaxiOrderType {
  Ride
  Rideshare
  ParcelDelivery
  FoodDelivery
  ShopDelivery
}

enum ServicePaymentMethod {
  CashCredit
  OnlyCredit
  OnlyCash
}

type Coupon {
  id: ID!
  code: String!
  title: String!
  description: String!
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  minimumCost: Float!
  maximumCost: Float!
  startAt: DateTime!
  expireAt: DateTime!
  discountPercent: Int!
  discountFlat: Int!
  creditGift: Float!
  isEnabled: Boolean!
  isFirstTravelOnly: Boolean!
  allowedServices(
    """Specify to filter the records returned."""
    filter: ServiceFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

type CampaignCode {
  id: ID!
  code: String!
  customerId: ID!
  campaignId: ID!
  customer: Rider
}

type Campaign {
  id: ID!
  name: String!
  description: String
  appType: [AppType!]!
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  minimumCost: Float!
  maximumCost: Float!
  startAt: DateTime!
  expireAt: DateTime
  currency: String!
  discountPercent: Float!
  discountFlat: Float!
  isEnabled: Boolean!
  isFirstTravelOnly: Boolean!
  codesAggregate(
    """Filter to find records to aggregate on"""
    filter: CampaignCodeAggregateFilter
  ): [CampaignCodesAggregateResponse!]!
  codes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CampaignCodeFilter! = {}

    """Specify to sort results."""
    sorting: [CampaignCodeSort!]! = []
  ): CampaignCodesConnection!
}

input CampaignCodeAggregateFilter {
  and: [CampaignCodeAggregateFilter!]
  or: [CampaignCodeAggregateFilter!]
  id: IDFilterComparison
  customerId: IDFilterComparison
  campaignId: IDFilterComparison
}

input CampaignCodeFilter {
  and: [CampaignCodeFilter!]
  or: [CampaignCodeFilter!]
  id: IDFilterComparison
  customerId: IDFilterComparison
  campaignId: IDFilterComparison
}

input CampaignCodeSort {
  field: CampaignCodeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CampaignCodeSortFields {
  id
  customerId
  campaignId
}

type CouponDeleteResponse {
  id: ID
  code: String
  title: String
  description: String
  manyUsersCanUse: Int
  manyTimesUserCanUse: Int
  minimumCost: Float
  maximumCost: Float
  startAt: DateTime
  expireAt: DateTime
  discountPercent: Int
  discountFlat: Int
  creditGift: Float
  isEnabled: Boolean
  isFirstTravelOnly: Boolean
}

type CouponConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Coupon!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CampaignDeleteResponse {
  id: ID
  name: String
  description: String
  appType: [AppType!]
  manyUsersCanUse: Int
  manyTimesUserCanUse: Int
  minimumCost: Float
  maximumCost: Float
  startAt: DateTime
  expireAt: DateTime
  currency: String
  discountPercent: Float
  discountFlat: Float
  isEnabled: Boolean
  isFirstTravelOnly: Boolean
}

type CampaignConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Campaign!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CampaignCodesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [CampaignCode!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CampaignCodesAggregateGroupBy {
  id: ID
  customerId: ID
  campaignId: ID
}

type CampaignCodesCountAggregate {
  id: Int
  customerId: Int
  campaignId: Int
}

type CampaignCodesSumAggregate {
  id: Float
  customerId: Float
  campaignId: Float
}

type CampaignCodesAvgAggregate {
  id: Float
  customerId: Float
  campaignId: Float
}

type CampaignCodesMinAggregate {
  id: ID
  customerId: ID
  campaignId: ID
}

type CampaignCodesMaxAggregate {
  id: ID
  customerId: ID
  campaignId: ID
}

type CampaignCodesAggregateResponse {
  groupBy: CampaignCodesAggregateGroupBy
  count: CampaignCodesCountAggregate
  sum: CampaignCodesSumAggregate
  avg: CampaignCodesAvgAggregate
  min: CampaignCodesMinAggregate
  max: CampaignCodesMaxAggregate
}

type CampaignCodeConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [CampaignCode!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type OnlineDriver {
  location: Point!
  driverId: ID!
  lastUpdatedAt: DateTime!
}

type OnlineDriverWithData {
  id: ID!
  location: Point!
  lastUpdatedAt: DateTime!
  firstName: String
  lastName: String
  avatarUrl: String
  mobileNumber: String!
  status: DriverStatus!
  gender: Gender
  rating: Int!
  reviewCount: Int!
}

type FeedbackParameterAggregate {
  count: ID!
  title: String!
  isGood: Boolean!
}

type DriverNote {
  id: ID!
  createdAt: DateTime!
  driverId: ID!
  note: String!
  staff: Operator!
}

type DriverConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Driver!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverAggregateGroupBy {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type DriverCountAggregate {
  id: Int
  fleetId: Int
  lastName: Int
  mobileNumber: Int
  maxDeliveryPackageSize: Int
  carId: Int
  carColorId: Int
  status: Int
  gender: Int
  rating: Int
  reviewCount: Int
}

type DriverSumAggregate {
  id: Float
  fleetId: Float
  carId: Float
  carColorId: Float
  rating: Float
  reviewCount: Float
}

type DriverAvgAggregate {
  id: Float
  fleetId: Float
  carId: Float
  carColorId: Float
  rating: Float
  reviewCount: Float
}

type DriverMinAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type DriverMaxAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type DriverAggregateResponse {
  groupBy: DriverAggregateGroupBy
  count: DriverCountAggregate
  sum: DriverSumAggregate
  avg: DriverAvgAggregate
  min: DriverMinAggregate
  max: DriverMaxAggregate
}

type DriverPayoutAccountsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [PayoutAccount!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverOrdersConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Order!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverFeedbacksConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Feedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverPayoutAccountsAggregateGroupBy {
  id: ID
  isDefault: Boolean
}

type DriverPayoutAccountsCountAggregate {
  id: Int
  isDefault: Int
}

type DriverPayoutAccountsSumAggregate {
  id: Float
}

type DriverPayoutAccountsAvgAggregate {
  id: Float
}

type DriverPayoutAccountsMinAggregate {
  id: ID
}

type DriverPayoutAccountsMaxAggregate {
  id: ID
}

type DriverPayoutAccountsAggregateResponse {
  groupBy: DriverPayoutAccountsAggregateGroupBy
  count: DriverPayoutAccountsCountAggregate
  sum: DriverPayoutAccountsSumAggregate
  avg: DriverPayoutAccountsAvgAggregate
  min: DriverPayoutAccountsMinAggregate
  max: DriverPayoutAccountsMaxAggregate
}

type DriverOrdersAggregateGroupBy {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type DriverOrdersCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  distanceBest: Int
  durationBest: Int
  costBest: Int
  costAfterCoupon: Int
  currency: Int
  riderId: Int
  paymentMode: Int
  driverId: Int
  regionId: Int
  fleetId: Int
  serviceId: Int
}

type DriverOrdersSumAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type DriverOrdersAvgAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type DriverOrdersMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type DriverOrdersMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type DriverOrdersAggregateResponse {
  groupBy: DriverOrdersAggregateGroupBy
  count: DriverOrdersCountAggregate
  sum: DriverOrdersSumAggregate
  avg: DriverOrdersAvgAggregate
  min: DriverOrdersMinAggregate
  max: DriverOrdersMaxAggregate
}

type DriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type DriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type DriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type DriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type DriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type DriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type DriverTransactionsAggregateResponse {
  groupBy: DriverTransactionsAggregateGroupBy
  count: DriverTransactionsCountAggregate
  sum: DriverTransactionsSumAggregate
  avg: DriverTransactionsAvgAggregate
  min: DriverTransactionsMinAggregate
  max: DriverTransactionsMaxAggregate
}

type DriverDriverToDriverDocumentsAggregateGroupBy {
  id: ID
  driverId: ID
}

type DriverDriverToDriverDocumentsCountAggregate {
  id: Int
  driverId: Int
}

type DriverDriverToDriverDocumentsSumAggregate {
  id: Float
  driverId: Float
}

type DriverDriverToDriverDocumentsAvgAggregate {
  id: Float
  driverId: Float
}

type DriverDriverToDriverDocumentsMinAggregate {
  id: ID
  driverId: ID
}

type DriverDriverToDriverDocumentsMaxAggregate {
  id: ID
  driverId: ID
}

type DriverDriverToDriverDocumentsAggregateResponse {
  groupBy: DriverDriverToDriverDocumentsAggregateGroupBy
  count: DriverDriverToDriverDocumentsCountAggregate
  sum: DriverDriverToDriverDocumentsSumAggregate
  avg: DriverDriverToDriverDocumentsAvgAggregate
  min: DriverDriverToDriverDocumentsMinAggregate
  max: DriverDriverToDriverDocumentsMaxAggregate
}

type DriverEnabledServicesAggregateGroupBy {
  driverId: ID
  serviceId: ID
}

type DriverEnabledServicesCountAggregate {
  driverId: Int
  serviceId: Int
}

type DriverEnabledServicesSumAggregate {
  driverId: Float
  serviceId: Float
}

type DriverEnabledServicesAvgAggregate {
  driverId: Float
  serviceId: Float
}

type DriverEnabledServicesMinAggregate {
  driverId: ID
  serviceId: ID
}

type DriverEnabledServicesMaxAggregate {
  driverId: ID
  serviceId: ID
}

type DriverEnabledServicesAggregateResponse {
  groupBy: DriverEnabledServicesAggregateGroupBy
  count: DriverEnabledServicesCountAggregate
  sum: DriverEnabledServicesSumAggregate
  avg: DriverEnabledServicesAvgAggregate
  min: DriverEnabledServicesMinAggregate
  max: DriverEnabledServicesMaxAggregate
}

type DriverSessionsAggregateGroupBy {
  id: ID
  driverId: ID
}

type DriverSessionsCountAggregate {
  id: Int
  driverId: Int
}

type DriverSessionsSumAggregate {
  id: Float
  driverId: Float
}

type DriverSessionsAvgAggregate {
  id: Float
  driverId: Float
}

type DriverSessionsMinAggregate {
  id: ID
  driverId: ID
}

type DriverSessionsMaxAggregate {
  id: ID
  driverId: ID
}

type DriverSessionsAggregateResponse {
  groupBy: DriverSessionsAggregateGroupBy
  count: DriverSessionsCountAggregate
  sum: DriverSessionsSumAggregate
  avg: DriverSessionsAvgAggregate
  min: DriverSessionsMinAggregate
  max: DriverSessionsMaxAggregate
}

type DriverWalletAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletCountAggregate {
  id: Int
  balance: Int
  currency: Int
  driverId: Int
}

type DriverWalletSumAggregate {
  id: Float
  balance: Float
  driverId: Float
}

type DriverWalletAvgAggregate {
  id: Float
  balance: Float
  driverId: Float
}

type DriverWalletMinAggregate {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletMaxAggregate {
  id: ID
  balance: Float
  currency: String
  driverId: ID
}

type DriverWalletAggregateResponse {
  groupBy: DriverWalletAggregateGroupBy
  count: DriverWalletCountAggregate
  sum: DriverWalletSumAggregate
  avg: DriverWalletAvgAggregate
  min: DriverWalletMinAggregate
  max: DriverWalletMaxAggregate
}

type DriverFeedbacksAggregateGroupBy {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksCountAggregate {
  id: Int
  driverId: Int
  requestId: Int
}

type DriverFeedbacksSumAggregate {
  id: Float
  driverId: Float
  requestId: Float
}

type DriverFeedbacksAvgAggregate {
  id: Float
  driverId: Float
  requestId: Float
}

type DriverFeedbacksMinAggregate {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksMaxAggregate {
  id: ID
  driverId: ID
  requestId: ID
}

type DriverFeedbacksAggregateResponse {
  groupBy: DriverFeedbacksAggregateGroupBy
  count: DriverFeedbacksCountAggregate
  sum: DriverFeedbacksSumAggregate
  avg: DriverFeedbacksAvgAggregate
  min: DriverFeedbacksMinAggregate
  max: DriverFeedbacksMaxAggregate
}

type DriverNoteConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverNote!]!
}

type DriverWalletConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverWallet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverSessionDeleteResponse {
  id: ID
  sessionInfo: SessionInfo
  driverId: ID
}

type DriverTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverTransactionAggregateGroupBy {
  id: ID
  createdAt(by: GroupBy! = DAY): DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

"""Group by"""
enum GroupBy {
  DAY
  WEEK
  MONTH
  YEAR
}

type DriverTransactionCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type DriverTransactionSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type DriverTransactionAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type DriverTransactionMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type DriverTransactionMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type DriverTransactionAggregateResponse {
  groupBy: DriverTransactionAggregateGroupBy
  count: DriverTransactionCountAggregate
  sum: DriverTransactionSumAggregate
  avg: DriverTransactionAvgAggregate
  min: DriverTransactionMinAggregate
  max: DriverTransactionMaxAggregate
}

type FeedbackConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Feedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FeedbackParametersAggregateGroupBy {
  id: ID
  title: String
  isGood: Boolean
}

type FeedbackParametersCountAggregate {
  id: Int
  title: Int
  isGood: Int
}

type FeedbackParametersSumAggregate {
  id: Float
}

type FeedbackParametersAvgAggregate {
  id: Float
}

type FeedbackParametersMinAggregate {
  id: ID
  title: String
}

type FeedbackParametersMaxAggregate {
  id: ID
  title: String
}

type FeedbackParametersAggregateResponse {
  groupBy: FeedbackParametersAggregateGroupBy
  count: FeedbackParametersCountAggregate
  sum: FeedbackParametersSumAggregate
  avg: FeedbackParametersAvgAggregate
  min: FeedbackParametersMinAggregate
  max: FeedbackParametersMaxAggregate
}

type FeedbackParameterDeleteResponse {
  id: ID
  title: String
  isGood: Boolean
}

type FeedbackParameterFeedbacksConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [FeedbackParameter!]!
}

type FeedbackParameterFeedbacksAggregateGroupBy {
  id: ID
  title: String
  isGood: Boolean
}

type FeedbackParameterFeedbacksCountAggregate {
  id: Int
  title: Int
  isGood: Int
}

type FeedbackParameterFeedbacksSumAggregate {
  id: Float
}

type FeedbackParameterFeedbacksAvgAggregate {
  id: Float
}

type FeedbackParameterFeedbacksMinAggregate {
  id: ID
  title: String
}

type FeedbackParameterFeedbacksMaxAggregate {
  id: ID
  title: String
}

type FeedbackParameterFeedbacksAggregateResponse {
  groupBy: FeedbackParameterFeedbacksAggregateGroupBy
  count: FeedbackParameterFeedbacksCountAggregate
  sum: FeedbackParameterFeedbacksSumAggregate
  avg: FeedbackParameterFeedbacksAvgAggregate
  min: FeedbackParameterFeedbacksMinAggregate
  max: FeedbackParameterFeedbacksMaxAggregate
}

type FleetStaffSession {
  id: ID!
  sessionInfo: SessionInfo!
  fleetStaffId: ID!
}

type FleetStaff {
  id: ID!
  registeredAt: DateTime!
  firstName: String!
  lastName: String!
  phoneNumber: String!
  mobileNumber: String!
  email: String
  lastActivityAt: DateTime
  isBlocked: Boolean!
  address: String
  userName: String!
  password: String!
  permissionOrder: FleetStaffPermissionOrder!
  permissionFinancial: FleetStaffPermissionOrder!
  fleetId: ID!
  profileImage: Media
}

enum FleetStaffPermissionOrder {
  CAN_VIEW
  CAN_EDIT
}

type FleetDeleteResponse {
  id: ID
  name: String
  createdAt: DateTime
  isBlocked: Boolean
  phoneNumber: String
  mobileNumber: String
  userName: String
  password: String
  accountNumber: String
  commissionSharePercent: Float
  commissionShareFlat: Float
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[Point!]!]
}

type FleetConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Fleet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetDriversConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Driver!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetZonePricesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ZonePrice!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [FleetTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetDriversAggregateGroupBy {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type FleetDriversCountAggregate {
  id: Int
  fleetId: Int
  lastName: Int
  mobileNumber: Int
  maxDeliveryPackageSize: Int
  carId: Int
  carColorId: Int
  status: Int
  gender: Int
  rating: Int
  reviewCount: Int
}

type FleetDriversSumAggregate {
  id: Float
  fleetId: Float
  carId: Float
  carColorId: Float
  rating: Float
  reviewCount: Float
}

type FleetDriversAvgAggregate {
  id: Float
  fleetId: Float
  carId: Float
  carColorId: Float
  rating: Float
  reviewCount: Float
}

type FleetDriversMinAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type FleetDriversMaxAggregate {
  id: ID
  fleetId: ID
  lastName: String
  mobileNumber: String
  maxDeliveryPackageSize: DeliveryPackageSize
  carId: ID
  carColorId: ID
  status: DriverStatus
  gender: Gender
  rating: Float
  reviewCount: Int
}

type FleetDriversAggregateResponse {
  groupBy: FleetDriversAggregateGroupBy
  count: FleetDriversCountAggregate
  sum: FleetDriversSumAggregate
  avg: FleetDriversAvgAggregate
  min: FleetDriversMinAggregate
  max: FleetDriversMaxAggregate
}

type FleetWalletConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [FleetWallet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetWalletAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  fleetId: ID
}

type FleetWalletCountAggregate {
  id: Int
  balance: Int
  currency: Int
  fleetId: Int
}

type FleetWalletSumAggregate {
  id: Float
  balance: Float
  fleetId: Float
}

type FleetWalletAvgAggregate {
  id: Float
  balance: Float
  fleetId: Float
}

type FleetWalletMinAggregate {
  id: ID
  balance: Float
  currency: String
  fleetId: ID
}

type FleetWalletMaxAggregate {
  id: ID
  balance: Float
  currency: String
  fleetId: ID
}

type FleetWalletAggregateResponse {
  groupBy: FleetWalletAggregateGroupBy
  count: FleetWalletCountAggregate
  sum: FleetWalletSumAggregate
  avg: FleetWalletAvgAggregate
  min: FleetWalletMinAggregate
  max: FleetWalletMaxAggregate
}

type FleetTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [FleetTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FleetTransactionAggregateGroupBy {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type FleetTransactionCountAggregate {
  id: Int
  status: Int
  action: Int
  deductType: Int
  rechargeType: Int
  operatorId: Int
  requestId: Int
  fleetId: Int
}

type FleetTransactionSumAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type FleetTransactionAvgAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type FleetTransactionMinAggregate {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type FleetTransactionMaxAggregate {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type FleetTransactionAggregateResponse {
  groupBy: FleetTransactionAggregateGroupBy
  count: FleetTransactionCountAggregate
  sum: FleetTransactionSumAggregate
  avg: FleetTransactionAvgAggregate
  min: FleetTransactionMinAggregate
  max: FleetTransactionMaxAggregate
}

type FleetStaffDeleteResponse {
  id: ID
  registeredAt: DateTime
  firstName: String
  lastName: String
  phoneNumber: String
  mobileNumber: String
  email: String
  lastActivityAt: DateTime
  isBlocked: Boolean
  address: String
  userName: String
  password: String
  permissionOrder: FleetStaffPermissionOrder
  permissionFinancial: FleetStaffPermissionOrder
  fleetId: ID
}

type FleetStaffConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [FleetStaff!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ServiceWithCost {
  id: ID!
  name: String!
  description: String
  personCapacity: Int
  cost: Float!
  media: Media!
  options: [ServiceOption!]!
}

type ServiceCategoryWithCost {
  id: ID!
  name: String!
  services: ServiceWithCost!
}

type CalculateFare {
  currency: String!
  distance: Int!
  duration: Int!
  services: [ServiceCategoryWithCost!]!
  error: CalculateFareError
}

enum CalculateFareError {
  RegionUnsupported
  NoServiceInRegion
}

type OrderCancelReason {
  id: ID!
  title: String!
  isEnabled: Boolean!
  userType: AnnouncementUserType!
  ordersAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): [OrderCancelReasonOrdersAggregateResponse!]!
  orders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter! = {}

    """Specify to sort results."""
    sorting: [OrderSort!]! = []
  ): OrderCancelReasonOrdersConnection!
}

type TaxiOrderNote {
  id: ID!
  createdAt: DateTime!
  orderId: ID!
  note: String!
  staff: Operator!
}

type OrderConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Order!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type OrderAggregateGroupBy {
  id: ID
  createdOn(by: GroupBy! = DAY): DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  distanceBest: Int
  durationBest: Int
  costBest: Int
  costAfterCoupon: Int
  currency: Int
  riderId: Int
  paymentMode: Int
  driverId: Int
  regionId: Int
  fleetId: Int
  serviceId: Int
}

type OrderSumAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type OrderAvgAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type OrderMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderAggregateResponse {
  groupBy: OrderAggregateGroupBy
  count: OrderCountAggregate
  sum: OrderSumAggregate
  avg: OrderAvgAggregate
  min: OrderMinAggregate
  max: OrderMaxAggregate
}

type OrderOptionsAggregateGroupBy {
  id: ID
}

type OrderOptionsCountAggregate {
  id: Int
}

type OrderOptionsSumAggregate {
  id: Float
}

type OrderOptionsAvgAggregate {
  id: Float
}

type OrderOptionsMinAggregate {
  id: ID
}

type OrderOptionsMaxAggregate {
  id: ID
}

type OrderOptionsAggregateResponse {
  groupBy: OrderOptionsAggregateGroupBy
  count: OrderOptionsCountAggregate
  sum: OrderOptionsSumAggregate
  avg: OrderOptionsAvgAggregate
  min: OrderOptionsMinAggregate
  max: OrderOptionsMaxAggregate
}

type OrderActivitiesAggregateGroupBy {
  id: ID
}

type OrderActivitiesCountAggregate {
  id: Int
}

type OrderActivitiesSumAggregate {
  id: Float
}

type OrderActivitiesAvgAggregate {
  id: Float
}

type OrderActivitiesMinAggregate {
  id: ID
}

type OrderActivitiesMaxAggregate {
  id: ID
}

type OrderActivitiesAggregateResponse {
  groupBy: OrderActivitiesAggregateGroupBy
  count: OrderActivitiesCountAggregate
  sum: OrderActivitiesSumAggregate
  avg: OrderActivitiesAvgAggregate
  min: OrderActivitiesMinAggregate
  max: OrderActivitiesMaxAggregate
}

type OrderProviderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type OrderProviderTransactionsCountAggregate {
  id: Int
  action: Int
  deductType: Int
  rechargeType: Int
  expenseType: Int
  amount: Int
  currency: Int
  operatorId: Int
  requestId: Int
  parkOrderId: Int
  shopOrderCartId: Int
}

type OrderProviderTransactionsSumAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type OrderProviderTransactionsAvgAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type OrderProviderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type OrderProviderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type OrderProviderTransactionsAggregateResponse {
  groupBy: OrderProviderTransactionsAggregateGroupBy
  count: OrderProviderTransactionsCountAggregate
  sum: OrderProviderTransactionsSumAggregate
  avg: OrderProviderTransactionsAvgAggregate
  min: OrderProviderTransactionsMinAggregate
  max: OrderProviderTransactionsMaxAggregate
}

type OrderFleetTransactionsAggregateGroupBy {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsCountAggregate {
  id: Int
  status: Int
  action: Int
  deductType: Int
  rechargeType: Int
  operatorId: Int
  requestId: Int
  fleetId: Int
}

type OrderFleetTransactionsSumAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type OrderFleetTransactionsAvgAggregate {
  id: Float
  operatorId: Float
  requestId: Float
  fleetId: Float
}

type OrderFleetTransactionsMinAggregate {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsMaxAggregate {
  id: ID
  status: TransactionStatus
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  operatorId: ID
  requestId: ID
  fleetId: ID
}

type OrderFleetTransactionsAggregateResponse {
  groupBy: OrderFleetTransactionsAggregateGroupBy
  count: OrderFleetTransactionsCountAggregate
  sum: OrderFleetTransactionsSumAggregate
  avg: OrderFleetTransactionsAvgAggregate
  min: OrderFleetTransactionsMinAggregate
  max: OrderFleetTransactionsMaxAggregate
}

type OrderDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type OrderDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type OrderDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type OrderDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type OrderDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type OrderDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type OrderDriverTransactionsAggregateResponse {
  groupBy: OrderDriverTransactionsAggregateGroupBy
  count: OrderDriverTransactionsCountAggregate
  sum: OrderDriverTransactionsSumAggregate
  avg: OrderDriverTransactionsAvgAggregate
  min: OrderDriverTransactionsMinAggregate
  max: OrderDriverTransactionsMaxAggregate
}

type OrderRiderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type OrderRiderTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type OrderRiderTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type OrderRiderTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type OrderRiderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type OrderRiderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type OrderRiderTransactionsAggregateResponse {
  groupBy: OrderRiderTransactionsAggregateGroupBy
  count: OrderRiderTransactionsCountAggregate
  sum: OrderRiderTransactionsSumAggregate
  avg: OrderRiderTransactionsAvgAggregate
  min: OrderRiderTransactionsMinAggregate
  max: OrderRiderTransactionsMaxAggregate
}

type OrderConversationAggregateGroupBy {
  id: ID
}

type OrderConversationCountAggregate {
  id: Int
}

type OrderConversationSumAggregate {
  id: Float
}

type OrderConversationAvgAggregate {
  id: Float
}

type OrderConversationMinAggregate {
  id: ID
}

type OrderConversationMaxAggregate {
  id: ID
}

type OrderConversationAggregateResponse {
  groupBy: OrderConversationAggregateGroupBy
  count: OrderConversationCountAggregate
  sum: OrderConversationSumAggregate
  avg: OrderConversationAvgAggregate
  min: OrderConversationMinAggregate
  max: OrderConversationMaxAggregate
}

type OrderComplaintsAggregateGroupBy {
  id: ID
  requestedByDriver: Boolean
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsCountAggregate {
  id: Int
  requestedByDriver: Int
  status: Int
  requestId: Int
}

type OrderComplaintsSumAggregate {
  id: Float
  requestId: Float
}

type OrderComplaintsAvgAggregate {
  id: Float
  requestId: Float
}

type OrderComplaintsMinAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsMaxAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type OrderComplaintsAggregateResponse {
  groupBy: OrderComplaintsAggregateGroupBy
  count: OrderComplaintsCountAggregate
  sum: OrderComplaintsSumAggregate
  avg: OrderComplaintsAvgAggregate
  min: OrderComplaintsMinAggregate
  max: OrderComplaintsMaxAggregate
}

type OrderCancelReasonDeleteResponse {
  id: ID
  title: String
  isEnabled: Boolean
  userType: AnnouncementUserType
}

type OrderCancelReasonConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [OrderCancelReason!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type OrderCancelReasonOrdersConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Order!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type OrderCancelReasonOrdersAggregateGroupBy {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderCancelReasonOrdersCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  distanceBest: Int
  durationBest: Int
  costBest: Int
  costAfterCoupon: Int
  currency: Int
  riderId: Int
  paymentMode: Int
  driverId: Int
  regionId: Int
  fleetId: Int
  serviceId: Int
}

type OrderCancelReasonOrdersSumAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type OrderCancelReasonOrdersAvgAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type OrderCancelReasonOrdersMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderCancelReasonOrdersMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type OrderCancelReasonOrdersAggregateResponse {
  groupBy: OrderCancelReasonOrdersAggregateGroupBy
  count: OrderCancelReasonOrdersCountAggregate
  sum: OrderCancelReasonOrdersSumAggregate
  avg: OrderCancelReasonOrdersAvgAggregate
  min: OrderCancelReasonOrdersMinAggregate
  max: OrderCancelReasonOrdersMaxAggregate
}

type TaxiOrderNoteConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [TaxiOrderNote!]!
}

type PaymentGatewayDeleteResponse {
  id: ID
  enabled: Boolean
  title: String
  type: PaymentGatewayType
  publicKey: String
  privateKey: String
  merchantId: String
  saltKey: String
  mediaId: ID
}

type PaymentGatewayConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [PaymentGateway!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PaymentGatewayRiderTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PaymentGatewayRiderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type PaymentGatewayRiderTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type PaymentGatewayRiderTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type PaymentGatewayRiderTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type PaymentGatewayRiderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type PaymentGatewayRiderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type PaymentGatewayRiderTransactionsAggregateResponse {
  groupBy: PaymentGatewayRiderTransactionsAggregateGroupBy
  count: PaymentGatewayRiderTransactionsCountAggregate
  sum: PaymentGatewayRiderTransactionsSumAggregate
  avg: PaymentGatewayRiderTransactionsAvgAggregate
  min: PaymentGatewayRiderTransactionsMinAggregate
  max: PaymentGatewayRiderTransactionsMaxAggregate
}

type TaxiPayoutSessionPayoutMethodDetail {
  id: ID!
  status: PayoutSessionStatus!
  driverTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAggregateResponse!]!
  payoutMethod: PayoutMethod!
  driverTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): TaxiPayoutSessionPayoutMethodDetailDriverTransactionsConnection!
}

enum PayoutSessionStatus {
  PENDING
  IN_PROGRESS
  PAID
  FAILED
  CANCELLED
}

type TaxiPayoutSession {
  id: ID!
  createdAt: DateTime!
  processedAt: DateTime
  description: String
  status: PayoutSessionStatus!
  totalAmount: Float!
  currency: String!
  driverTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [TaxiPayoutSessionDriverTransactionsAggregateResponse!]!
  driverTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): TaxiPayoutSessionDriverTransactionsConnection!
  payoutMethodDetails(
    """Specify to filter the records returned."""
    filter: TaxiPayoutSessionPayoutMethodDetailFilter! = {}

    """Specify to sort results."""
    sorting: [TaxiPayoutSessionPayoutMethodDetailSort!]! = []
  ): [TaxiPayoutSessionPayoutMethodDetail!]!
  payoutMethods(
    """Specify to filter the records returned."""
    filter: PayoutMethodFilter! = {}

    """Specify to sort results."""
    sorting: [PayoutMethodSort!]! = []
  ): [PayoutMethod!]!
}

input TaxiPayoutSessionPayoutMethodDetailFilter {
  and: [TaxiPayoutSessionPayoutMethodDetailFilter!]
  or: [TaxiPayoutSessionPayoutMethodDetailFilter!]
  id: IDFilterComparison
}

input TaxiPayoutSessionPayoutMethodDetailSort {
  field: TaxiPayoutSessionPayoutMethodDetailSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxiPayoutSessionPayoutMethodDetailSortFields {
  id
}

input PayoutMethodFilter {
  and: [PayoutMethodFilter!]
  or: [PayoutMethodFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
  driverTransactions: PayoutMethodFilterDriverTransactionFilter
}

input PayoutMethodFilterDriverTransactionFilter {
  and: [PayoutMethodFilterDriverTransactionFilter!]
  or: [PayoutMethodFilterDriverTransactionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  action: TransactionActionFilterComparison
  status: TransactionStatusFilterComparison
  amount: NumberFieldComparison
  currency: StringFieldComparison
  driverId: IDFilterComparison
  paymentGatewayId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
}

input PayoutMethodSort {
  field: PayoutMethodSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PayoutMethodSortFields {
  id
  enabled
  currency
  name
  type
}

type PayoutStatistics {
  pendingAmount: Float!
  lastPayoutAmount: Float!
  usersDefaultPayoutMethodStats: [PayoutMethodStats!]!
  currency: String!
}

type PayoutMethodStats {
  payoutMethod: PayoutMethod
  totalCount: Int!
}

type TaxiPayoutSessionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [TaxiPayoutSession!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaxiPayoutSessionDriverTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaxiPayoutSessionDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type TaxiPayoutSessionDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type TaxiPayoutSessionDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type TaxiPayoutSessionDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionDriverTransactionsAggregateResponse {
  groupBy: TaxiPayoutSessionDriverTransactionsAggregateGroupBy
  count: TaxiPayoutSessionDriverTransactionsCountAggregate
  sum: TaxiPayoutSessionDriverTransactionsSumAggregate
  avg: TaxiPayoutSessionDriverTransactionsAvgAggregate
  min: TaxiPayoutSessionDriverTransactionsMinAggregate
  max: TaxiPayoutSessionDriverTransactionsMaxAggregate
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DriverTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAggregateResponse {
  groupBy: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAggregateGroupBy
  count: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsCountAggregate
  sum: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsSumAggregate
  avg: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsAvgAggregate
  min: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsMinAggregate
  max: TaxiPayoutSessionPayoutMethodDetailDriverTransactionsMaxAggregate
}

type ItemVariant {
  id: ID!
  name: String!
  description: String
  price: Float!
  item: Item!
}

type ItemOption {
  id: ID!
  name: String!
  description: String
  price: Float!
}

type RatingAggregate {
  rating: Int
  reviewCount: Int!
}

type ShopFeedbackParameter {
  id: ID!
  isGood: Boolean!
  name: String!
}

type ShopOrderStatusHistory {
  id: ID!
  status: ShopOrderStatus!
  expectedBy: DateTime
  updatedAt: DateTime
  orderId: ID!
  orderCart: ShopOrderCart!
}

"""The status of the shop order"""
enum ShopOrderStatus {
  New
  Processing
  PaymentPending
  PaymentFailed
  OnHold
  ReadyForPickup
  OutForDelivery
  Completed
  Cancelled
  Returned
  Refunded
}

type ShopOrder {
  id: ID!
  createdAt: DateTime!
  status: ShopOrderStatus!
  subTotal: Float!
  currency: String!
  deliveryFee: Float!
  deliveryMethod: DeliveryMethod!
  deliveryDirections: [Point!]
  paymentMethod: PaymentMode!
  customerId: ID!
  tax: Float!
  discount: Float!
  serviceFee: Float!
  total: Float!
  estimatedDeliveryTime: DateTime
  fullfillmentTime: DateTime
  cartsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopOrderCartAggregateFilter
  ): [ShopOrderCartsAggregateResponse!]!
  riderTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [ShopOrderRiderTransactionsAggregateResponse!]!
  driverTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [ShopOrderDriverTransactionsAggregateResponse!]!
  statusHistoriesAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopOrderStatusHistoryAggregateFilter
  ): [ShopOrderStatusHistoriesAggregateResponse!]!
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  deliveryAddress: Address!
  customer: Rider!
  carts(
    """Specify to filter the records returned."""
    filter: ShopOrderCartFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderCartSort!]! = []
  ): [ShopOrderCart!]!
  riderTransactions(
    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): [RiderTransaction!]!
  driverTransactions(
    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): [DriverTransaction!]!
  statusHistories(
    """Specify to filter the records returned."""
    filter: ShopOrderStatusHistoryFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderStatusHistorySort!]! = []
  ): [ShopOrderStatusHistory!]!
}

enum DeliveryMethod {
  BATCH
  SPLIT
  SCHEDULED
}

input ShopOrderCartAggregateFilter {
  and: [ShopOrderCartAggregateFilter!]
  or: [ShopOrderCartAggregateFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  order: ShopOrderCartAggregateFilterShopOrderAggregateFilter
}

input ShopOrderCartAggregateFilterShopOrderAggregateFilter {
  and: [ShopOrderCartAggregateFilterShopOrderAggregateFilter!]
  or: [ShopOrderCartAggregateFilterShopOrderAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
}

input ShopOrderStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ShopOrderStatus
  neq: ShopOrderStatus
  gt: ShopOrderStatus
  gte: ShopOrderStatus
  lt: ShopOrderStatus
  lte: ShopOrderStatus
  like: ShopOrderStatus
  notLike: ShopOrderStatus
  iLike: ShopOrderStatus
  notILike: ShopOrderStatus
  in: [ShopOrderStatus!]
  notIn: [ShopOrderStatus!]
}

input DeliveryMethodFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: DeliveryMethod
  neq: DeliveryMethod
  gt: DeliveryMethod
  gte: DeliveryMethod
  lt: DeliveryMethod
  lte: DeliveryMethod
  like: DeliveryMethod
  notLike: DeliveryMethod
  iLike: DeliveryMethod
  notILike: DeliveryMethod
  in: [DeliveryMethod!]
  notIn: [DeliveryMethod!]
}

input ShopOrderStatusHistoryAggregateFilter {
  and: [ShopOrderStatusHistoryAggregateFilter!]
  or: [ShopOrderStatusHistoryAggregateFilter!]
  id: IDFilterComparison
  orderId: IDFilterComparison
}

input ShopOrderCartFilter {
  and: [ShopOrderCartFilter!]
  or: [ShopOrderCartFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  order: ShopOrderCartFilterShopOrderFilter
}

input ShopOrderCartFilterShopOrderFilter {
  and: [ShopOrderCartFilterShopOrderFilter!]
  or: [ShopOrderCartFilterShopOrderFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
}

input ShopOrderCartSort {
  field: ShopOrderCartSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopOrderCartSortFields {
  id
  shopId
}

input ShopOrderStatusHistoryFilter {
  and: [ShopOrderStatusHistoryFilter!]
  or: [ShopOrderStatusHistoryFilter!]
  id: IDFilterComparison
  orderId: IDFilterComparison
}

input ShopOrderStatusHistorySort {
  field: ShopOrderStatusHistorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopOrderStatusHistorySortFields {
  id
  orderId
}

type ShopOrderCartItem {
  id: ID!
  priceEach: Float!
  quantity: Int!
  canceledQuantity: Int!
  itemVariant: ItemVariant!
  options(
    """Specify to filter the records returned."""
    filter: ItemOptionFilter! = {}

    """Specify to sort results."""
    sorting: [ItemOptionSort!]! = []
  ): [ItemOption!]!
}

input ItemOptionFilter {
  and: [ItemOptionFilter!]
  or: [ItemOptionFilter!]
  id: IDFilterComparison
}

input ItemOptionSort {
  field: ItemOptionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ItemOptionSortFields {
  id
}

type ShopOrderCart {
  id: ID!
  subtotal: Float!
  shopId: ID!
  shop: Shop!
  order: ShopOrder!
  shopTransactions(
    """Specify to filter the records returned."""
    filter: ShopTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopTransactionSort!]! = []
  ): [ShopTransaction!]!
  providerTransactions(
    """Specify to filter the records returned."""
    filter: ProviderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ProviderTransactionSort!]! = []
  ): [ProviderTransaction!]!
  feedbacks(
    """Specify to filter the records returned."""
    filter: ShopFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ShopFeedbackSort!]! = []
  ): [ShopFeedback!]
  items(
    """Specify to filter the records returned."""
    filter: ShopOrderCartItemFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderCartItemSort!]! = []
  ): [ShopOrderCartItem!]!
}

input ShopTransactionFilter {
  and: [ShopTransactionFilter!]
  or: [ShopTransactionFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  status: TransactionStatusFilterComparison
  appType: AppTypeFilterComparison
  type: TransactionTypeFilterComparison
  debitType: ShopTransactionDebitTypeFilterComparison
  creditType: ShopTransactionCreditTypeFilterComparison
  currency: StringFieldComparison
  amount: NumberFieldComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  payoutMethod: ShopTransactionFilterPayoutMethodFilter
}

input AppTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: AppType
  neq: AppType
  gt: AppType
  gte: AppType
  lt: AppType
  lte: AppType
  like: AppType
  notLike: AppType
  iLike: AppType
  notILike: AppType
  in: [AppType!]
  notIn: [AppType!]
}

input TransactionTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TransactionType
  neq: TransactionType
  gt: TransactionType
  gte: TransactionType
  lt: TransactionType
  lte: TransactionType
  like: TransactionType
  notLike: TransactionType
  iLike: TransactionType
  notILike: TransactionType
  in: [TransactionType!]
  notIn: [TransactionType!]
}

enum TransactionType {
  Debit
  Credit
}

input ShopTransactionDebitTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ShopTransactionDebitType
  neq: ShopTransactionDebitType
  gt: ShopTransactionDebitType
  gte: ShopTransactionDebitType
  lt: ShopTransactionDebitType
  lte: ShopTransactionDebitType
  like: ShopTransactionDebitType
  notLike: ShopTransactionDebitType
  iLike: ShopTransactionDebitType
  notILike: ShopTransactionDebitType
  in: [ShopTransactionDebitType!]
  notIn: [ShopTransactionDebitType!]
}

enum ShopTransactionDebitType {
  Commission
  Correction
  Payout
  Refund
}

input ShopTransactionCreditTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ShopTransactionCreditType
  neq: ShopTransactionCreditType
  gt: ShopTransactionCreditType
  gte: ShopTransactionCreditType
  lt: ShopTransactionCreditType
  lte: ShopTransactionCreditType
  like: ShopTransactionCreditType
  notLike: ShopTransactionCreditType
  iLike: ShopTransactionCreditType
  notILike: ShopTransactionCreditType
  in: [ShopTransactionCreditType!]
  notIn: [ShopTransactionCreditType!]
}

enum ShopTransactionCreditType {
  SaleRevenue
  Correction
}

input ShopTransactionFilterPayoutMethodFilter {
  and: [ShopTransactionFilterPayoutMethodFilter!]
  or: [ShopTransactionFilterPayoutMethodFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

input ShopTransactionSort {
  field: ShopTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopTransactionSortFields {
  id
  shopId
  status
  appType
  type
  debitType
  creditType
  currency
  amount
  payoutSessionId
  payoutAccountId
  payoutMethodId
  payoutSessionMethodId
}

input ShopFeedbackFilter {
  and: [ShopFeedbackFilter!]
  or: [ShopFeedbackFilter!]
  id: IDFilterComparison
  comment: StringFieldComparison
  status: ReviewStatusFilterComparison
  shopId: IDFilterComparison
  customerId: IDFilterComparison
  orderCart: ShopFeedbackFilterShopOrderCartFilter
}

input ReviewStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ReviewStatus
  neq: ReviewStatus
  gt: ReviewStatus
  gte: ReviewStatus
  lt: ReviewStatus
  lte: ReviewStatus
  like: ReviewStatus
  notLike: ReviewStatus
  iLike: ReviewStatus
  notILike: ReviewStatus
  in: [ReviewStatus!]
  notIn: [ReviewStatus!]
}

enum ReviewStatus {
  Pending
  Approved
  ApprovedUnpublished
  Rejected
  Overridden
}

input ShopFeedbackFilterShopOrderCartFilter {
  and: [ShopFeedbackFilterShopOrderCartFilter!]
  or: [ShopFeedbackFilterShopOrderCartFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
}

input ShopFeedbackSort {
  field: ShopFeedbackSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopFeedbackSortFields {
  id
  comment
  status
  shopId
  customerId
}

input ShopOrderCartItemFilter {
  and: [ShopOrderCartItemFilter!]
  or: [ShopOrderCartItemFilter!]
  id: IDFilterComparison
}

input ShopOrderCartItemSort {
  field: ShopOrderCartItemSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopOrderCartItemSortFields {
  id
}

type ShopFeedback {
  id: ID!

  """The score of the review, from 0 to 100"""
  score: Int!
  comment: String!
  status: ReviewStatus!
  createdAt: DateTime!
  shopId: ID!
  customerId: ID!
  orderCart: ShopOrderCart!
  parameters(
    """Specify to filter the records returned."""
    filter: ShopFeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [ShopFeedbackParameterSort!]! = []
  ): [ShopFeedbackParameter!]!
}

input ShopFeedbackParameterFilter {
  and: [ShopFeedbackParameterFilter!]
  or: [ShopFeedbackParameterFilter!]
  id: IDFilterComparison
}

input ShopFeedbackParameterSort {
  field: ShopFeedbackParameterSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopFeedbackParameterSortFields {
  id
}

type Item {
  id: ID!
  name: String!
  description: String

  """The base price of the item"""
  basePrice: Float!
  ratingAggregate: RatingAggregate!
  shopId: ID!

  """The stock quantity"""
  stockQuantity: Int!
  discountPercentage: Int!
  discountedQuantity: Int!
  discountUntil: DateTime
  usedDiscountedQuantity: Int!
  image: Media
  variants(
    """Specify to filter the records returned."""
    filter: ItemVariantFilter! = {}

    """Specify to sort results."""
    sorting: [ItemVariantSort!]! = []
  ): [ItemVariant!]!
  options(
    """Specify to filter the records returned."""
    filter: ItemOptionFilter! = {}

    """Specify to sort results."""
    sorting: [ItemOptionSort!]! = []
  ): [ItemOption!]!
  categories(
    """Specify to filter the records returned."""
    filter: ItemCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ItemCategorySort!]! = []
  ): [ItemCategory!]!
  presets(
    """Specify to filter the records returned."""
    filter: ShopItemPresetFilter! = {}

    """Specify to sort results."""
    sorting: [ShopItemPresetSort!]! = []
  ): [ShopItemPreset!]!
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ShopFeedbackSort!]! = []
  ): ItemFeedbacksConnection!
}

input ItemVariantFilter {
  and: [ItemVariantFilter!]
  or: [ItemVariantFilter!]
  id: IDFilterComparison
}

input ItemVariantSort {
  field: ItemVariantSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ItemVariantSortFields {
  id
}

input ItemCategoryFilter {
  and: [ItemCategoryFilter!]
  or: [ItemCategoryFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
  presets: ItemCategoryFilterShopItemPresetFilter
  items: ItemCategoryFilterItemFilter
}

input ItemCategoryFilterShopItemPresetFilter {
  and: [ItemCategoryFilterShopItemPresetFilter!]
  or: [ItemCategoryFilterShopItemPresetFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ItemCategoryFilterItemFilter {
  and: [ItemCategoryFilterItemFilter!]
  or: [ItemCategoryFilterItemFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ItemCategorySort {
  field: ItemCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ItemCategorySortFields {
  id
  name
  shopId
}

input ShopItemPresetFilter {
  and: [ShopItemPresetFilter!]
  or: [ShopItemPresetFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
  items: ShopItemPresetFilterItemFilter
  itemCategories: ShopItemPresetFilterItemCategoryFilter
}

input ShopItemPresetFilterItemFilter {
  and: [ShopItemPresetFilterItemFilter!]
  or: [ShopItemPresetFilterItemFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopItemPresetFilterItemCategoryFilter {
  and: [ShopItemPresetFilterItemCategoryFilter!]
  or: [ShopItemPresetFilterItemCategoryFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopItemPresetSort {
  field: ShopItemPresetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopItemPresetSortFields {
  id
  name
  shopId
}

type ItemCategory {
  id: ID!
  name: String!
  shopId: ID!
  items(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ItemFilter! = {}

    """Specify to sort results."""
    sorting: [ItemSort!]! = []
  ): ItemCategoryItemsConnection!
  presets(
    """Specify to filter the records returned."""
    filter: ShopItemPresetFilter! = {}

    """Specify to sort results."""
    sorting: [ShopItemPresetSort!]! = []
  ): [ShopItemPreset!]!
}

input ItemFilter {
  and: [ItemFilter!]
  or: [ItemFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ItemSort {
  field: ItemSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ItemSortFields {
  id
  name
  shopId
}

type ShopItemPreset {
  id: ID!
  name: String!
  shopId: ID!
  weeklySchedule: [WeekdaySchedule!]!
  itemCategories(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ItemCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ItemCategorySort!]! = []
  ): ShopItemPresetItemCategoriesConnection!
  items(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ItemFilter! = {}

    """Specify to sort results."""
    sorting: [ItemSort!]! = []
  ): ShopItemPresetItemsConnection!
}

type ShopCategory {
  id: ID!
  name: String!
  status: ShopCategoryStatus!
  image: Media
  shops(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSort!]! = []
  ): ShopCategoryShopsConnection!
}

enum ShopCategoryStatus {
  Enabled
  Disabled
}

input ShopFilter {
  and: [ShopFilter!]
  or: [ShopFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopStatusFilterComparison
  ratingAggregate: ShopFilterRatingAggregateFilter
  categories: ShopFilterShopCategoryFilter
  itemPresets: ShopFilterShopItemPresetFilter
}

input ShopStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ShopStatus
  neq: ShopStatus
  gt: ShopStatus
  gte: ShopStatus
  lt: ShopStatus
  lte: ShopStatus
  like: ShopStatus
  notLike: ShopStatus
  iLike: ShopStatus
  notILike: ShopStatus
  in: [ShopStatus!]
  notIn: [ShopStatus!]
}

"""The status of the shop"""
enum ShopStatus {
  PendingSubmission
  PendingApproval
  Active
  Inactive
  Deleted
  Blocked
}

input ShopFilterRatingAggregateFilter {
  and: [ShopFilterRatingAggregateFilter!]
  or: [ShopFilterRatingAggregateFilter!]
  rating: IntFieldComparison
}

input ShopFilterShopCategoryFilter {
  and: [ShopFilterShopCategoryFilter!]
  or: [ShopFilterShopCategoryFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopCategoryStatusFilterComparison
}

input ShopCategoryStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ShopCategoryStatus
  neq: ShopCategoryStatus
  gt: ShopCategoryStatus
  gte: ShopCategoryStatus
  lt: ShopCategoryStatus
  lte: ShopCategoryStatus
  like: ShopCategoryStatus
  notLike: ShopCategoryStatus
  iLike: ShopCategoryStatus
  notILike: ShopCategoryStatus
  in: [ShopCategoryStatus!]
  notIn: [ShopCategoryStatus!]
}

input ShopFilterShopItemPresetFilter {
  and: [ShopFilterShopItemPresetFilter!]
  or: [ShopFilterShopItemPresetFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopSort {
  field: ShopSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopSortFields {
  id
  name
  status
  ratingAggregate
}

type ShopSession {
  id: ID!
  createdAt: DateTime!
  deviceName: String
  ipLocation: String
  lastActivityAt: DateTime
  shopId: ID!
  appType: AppType!
  devicePlatform: DevicePlatform!
  deviceType: DeviceType!
}

type ShopWallet {
  id: ID!
  balance: Float!
  currency: String!
  shopId: ID!
  shop: Shop!
}

type PersonalInfo {
  firstName: String
  lastName: String
  email: String
  mobileNumber: String
  gender: Gender
  address: String
}

type PhoneNumber {
  countryCode: String!
  number: String!
}

type Shop {
  id: ID!
  name: String!
  status: ShopStatus!
  mobileNumber: PhoneNumber!
  ownerInformation: PersonalInfo!
  email: String
  address: String!
  password: String
  createdAt: DateTime!
  weeklySchedule: [WeekdaySchedule!]!
  orderQueueLevel: OrderQueueLevel!
  isExpressDeliveryAvailable: Boolean!
  isShopDeliveryAvailable: Boolean!

  """
  The percentage of the delivery fee that shop pays so the delivery fee would be more appealing to the users.
  """
  expressDeliveryShopCommission: Int!
  isOnlinePaymentAvailable: Boolean!
  isCashOnDeliveryAvailable: Boolean!
  lastActivityAt: DateTime
  description: String
  location: Point!
  currency: String!
  ratingAggregate: RatingAggregate!
  itemPresetsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopItemPresetAggregateFilter
  ): [ShopItemPresetsAggregateResponse!]!
  categoriesAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopCategoryAggregateFilter
  ): [ShopCategoriesAggregateResponse!]!
  sessionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopSessionAggregateFilter
  ): [ShopSessionsAggregateResponse!]!
  walletAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopWalletAggregateFilter
  ): [ShopWalletAggregateResponse!]!
  cartsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopOrderCartAggregateFilter
  ): [ShopCartsAggregateResponse!]!
  image: Media
  itemPresets(
    """Specify to filter the records returned."""
    filter: ShopItemPresetFilter! = {}

    """Specify to sort results."""
    sorting: [ShopItemPresetSort!]! = []
  ): [ShopItemPreset!]!
  categories(
    """Specify to filter the records returned."""
    filter: ShopCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ShopCategorySort!]! = []
  ): [ShopCategory!]!
  sessions(
    """Specify to filter the records returned."""
    filter: ShopSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSessionSort!]! = []
  ): [ShopSession!]!
  wallet(
    """Specify to filter the records returned."""
    filter: ShopWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ShopWalletSort!]! = []
  ): [ShopWallet!]!
  carts(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopOrderCartFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderCartSort!]! = []
  ): ShopCartsConnection!
}

enum OrderQueueLevel {
  LOW
  MEDIUM
  HIGH
}

input ShopItemPresetAggregateFilter {
  and: [ShopItemPresetAggregateFilter!]
  or: [ShopItemPresetAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
  items: ShopItemPresetAggregateFilterItemAggregateFilter
  itemCategories: ShopItemPresetAggregateFilterItemCategoryAggregateFilter
}

input ShopItemPresetAggregateFilterItemAggregateFilter {
  and: [ShopItemPresetAggregateFilterItemAggregateFilter!]
  or: [ShopItemPresetAggregateFilterItemAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopItemPresetAggregateFilterItemCategoryAggregateFilter {
  and: [ShopItemPresetAggregateFilterItemCategoryAggregateFilter!]
  or: [ShopItemPresetAggregateFilterItemCategoryAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopCategoryAggregateFilter {
  and: [ShopCategoryAggregateFilter!]
  or: [ShopCategoryAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopCategoryStatusFilterComparison
}

input ShopSessionAggregateFilter {
  and: [ShopSessionAggregateFilter!]
  or: [ShopSessionAggregateFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  appType: AppTypeFilterComparison
}

input ShopWalletAggregateFilter {
  and: [ShopWalletAggregateFilter!]
  or: [ShopWalletAggregateFilter!]
  id: IDFilterComparison
  balance: NumberFieldComparison
  currency: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopCategoryFilter {
  and: [ShopCategoryFilter!]
  or: [ShopCategoryFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopCategoryStatusFilterComparison
}

input ShopCategorySort {
  field: ShopCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopCategorySortFields {
  id
  name
  status
}

input ShopSessionFilter {
  and: [ShopSessionFilter!]
  or: [ShopSessionFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  appType: AppTypeFilterComparison
}

input ShopSessionSort {
  field: ShopSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopSessionSortFields {
  id
  shopId
  appType
}

input ShopWalletFilter {
  and: [ShopWalletFilter!]
  or: [ShopWalletFilter!]
  id: IDFilterComparison
  balance: NumberFieldComparison
  currency: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopWalletSort {
  field: ShopWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopWalletSortFields {
  id
  balance
  currency
  shopId
}

type ShopTransaction {
  id: ID!
  shopId: ID!
  status: TransactionStatus!
  createdAt: DateTime!
  transactionDate: DateTime!
  appType: AppType!
  type: TransactionType!
  debitType: ShopTransactionDebitType!
  creditType: ShopTransactionCreditType!
  currency: String!
  amount: Float!
  documentNumber: String
  description: String
  payoutSessionId: ID!
  payoutAccountId: ID!
  payoutMethodId: ID!
  payoutSessionMethodId: ID!
  staff: Operator
  payoutAccount: PayoutAccount
  payoutMethod: PayoutMethod
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  shop: Shop!
}

type ShopPayoutSessionPayoutMethodDetail {
  id: ID!
  status: PayoutSessionStatus!
  shopTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopTransactionAggregateFilter
  ): [ShopPayoutSessionPayoutMethodDetailShopTransactionsAggregateResponse!]!
  payoutMethod: PayoutMethod!
  shopTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopTransactionSort!]! = []
  ): ShopPayoutSessionPayoutMethodDetailShopTransactionsConnection!
}

input ShopTransactionAggregateFilter {
  and: [ShopTransactionAggregateFilter!]
  or: [ShopTransactionAggregateFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  status: TransactionStatusFilterComparison
  appType: AppTypeFilterComparison
  type: TransactionTypeFilterComparison
  debitType: ShopTransactionDebitTypeFilterComparison
  creditType: ShopTransactionCreditTypeFilterComparison
  currency: StringFieldComparison
  amount: NumberFieldComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  payoutMethod: ShopTransactionAggregateFilterPayoutMethodAggregateFilter
}

input ShopTransactionAggregateFilterPayoutMethodAggregateFilter {
  and: [ShopTransactionAggregateFilterPayoutMethodAggregateFilter!]
  or: [ShopTransactionAggregateFilterPayoutMethodAggregateFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

type ShopPayoutSession {
  id: ID!
  createdAt: DateTime!
  processedAt: DateTime
  description: String
  status: PayoutSessionStatus!
  totalAmount: Float!
  currency: String!
  shopTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopTransactionAggregateFilter
  ): [ShopPayoutSessionShopTransactionsAggregateResponse!]!
  shopTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopTransactionSort!]! = []
  ): ShopPayoutSessionShopTransactionsConnection!
  payoutMethodDetails(
    """Specify to filter the records returned."""
    filter: ShopPayoutSessionPayoutMethodDetailFilter! = {}

    """Specify to sort results."""
    sorting: [ShopPayoutSessionPayoutMethodDetailSort!]! = []
  ): [ShopPayoutSessionPayoutMethodDetail!]!
  payoutMethods(
    """Specify to filter the records returned."""
    filter: PayoutMethodFilter! = {}

    """Specify to sort results."""
    sorting: [PayoutMethodSort!]! = []
  ): [PayoutMethod!]!
}

input ShopPayoutSessionPayoutMethodDetailFilter {
  and: [ShopPayoutSessionPayoutMethodDetailFilter!]
  or: [ShopPayoutSessionPayoutMethodDetailFilter!]
  id: IDFilterComparison
}

input ShopPayoutSessionPayoutMethodDetailSort {
  field: ShopPayoutSessionPayoutMethodDetailSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopPayoutSessionPayoutMethodDetailSortFields {
  id
}

type ShopPayoutSessionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopPayoutSession!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopPayoutSessionShopTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopPayoutSessionShopTransactionsAggregateGroupBy {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionShopTransactionsCountAggregate {
  id: Int
  shopId: Int
  status: Int
  appType: Int
  type: Int
  debitType: Int
  creditType: Int
  currency: Int
  amount: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type ShopPayoutSessionShopTransactionsSumAggregate {
  id: Float
  shopId: Float
  amount: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopPayoutSessionShopTransactionsAvgAggregate {
  id: Float
  shopId: Float
  amount: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopPayoutSessionShopTransactionsMinAggregate {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionShopTransactionsMaxAggregate {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionShopTransactionsAggregateResponse {
  groupBy: ShopPayoutSessionShopTransactionsAggregateGroupBy
  count: ShopPayoutSessionShopTransactionsCountAggregate
  sum: ShopPayoutSessionShopTransactionsSumAggregate
  avg: ShopPayoutSessionShopTransactionsAvgAggregate
  min: ShopPayoutSessionShopTransactionsMinAggregate
  max: ShopPayoutSessionShopTransactionsMaxAggregate
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsAggregateGroupBy {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsCountAggregate {
  id: Int
  shopId: Int
  status: Int
  appType: Int
  type: Int
  debitType: Int
  creditType: Int
  currency: Int
  amount: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsSumAggregate {
  id: Float
  shopId: Float
  amount: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsAvgAggregate {
  id: Float
  shopId: Float
  amount: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsMinAggregate {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsMaxAggregate {
  id: ID
  shopId: ID
  status: TransactionStatus
  appType: AppType
  type: TransactionType
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  currency: String
  amount: Float
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopPayoutSessionPayoutMethodDetailShopTransactionsAggregateResponse {
  groupBy: ShopPayoutSessionPayoutMethodDetailShopTransactionsAggregateGroupBy
  count: ShopPayoutSessionPayoutMethodDetailShopTransactionsCountAggregate
  sum: ShopPayoutSessionPayoutMethodDetailShopTransactionsSumAggregate
  avg: ShopPayoutSessionPayoutMethodDetailShopTransactionsAvgAggregate
  min: ShopPayoutSessionPayoutMethodDetailShopTransactionsMinAggregate
  max: ShopPayoutSessionPayoutMethodDetailShopTransactionsMaxAggregate
}

type ParkingTransaction {
  id: ID!
  createdAt: DateTime!
  transactionDate: DateTime!
  status: TransactionStatus!
  type: TransactionType!
  debitType: ParkingTransactionDebitType!
  creditType: ParkingTransactionCreditType!
  currency: String!
  amount: Float!
  documentNumber: String
  description: String
  customerId: ID!
  payoutSessionId: ID!
  payoutAccountId: ID!
  payoutMethodId: ID!
  payoutSessionMethodId: ID!
  parkSpotId: ID!
  staff: Operator
  payoutAccount: PayoutAccount
  payoutMethod: PayoutMethod
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  customer: Rider!
}

enum ParkingTransactionDebitType {
  Commission
  Correction
  Payout
  Refund
  ParkingFee
  CancelFee
}

enum ParkingTransactionCreditType {
  WalletTopUp
  GiftCardTopUp
  BankTransfer
  ParkingRentalIncome
  Correction
}

type ParkingPayoutSessionPayoutMethodDetail {
  id: ID!
  status: PayoutSessionStatus!
  parkingTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingTransactionAggregateFilter
  ): [ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAggregateResponse!]!
  payoutMethod: PayoutMethod!
  parkingTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingTransactionSort!]! = []
  ): ParkingPayoutSessionPayoutMethodDetailParkingTransactionsConnection!
}

input ParkingTransactionAggregateFilter {
  and: [ParkingTransactionAggregateFilter!]
  or: [ParkingTransactionAggregateFilter!]
  id: IDFilterComparison
  status: TransactionStatusFilterComparison
  type: TransactionTypeFilterComparison
  debitType: ParkingTransactionDebitTypeFilterComparison
  creditType: ParkingTransactionCreditTypeFilterComparison
  currency: StringFieldComparison
  amount: NumberFieldComparison
  customerId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  parkSpotId: IDFilterComparison
  payoutMethod: ParkingTransactionAggregateFilterPayoutMethodAggregateFilter
}

input ParkingTransactionDebitTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkingTransactionDebitType
  neq: ParkingTransactionDebitType
  gt: ParkingTransactionDebitType
  gte: ParkingTransactionDebitType
  lt: ParkingTransactionDebitType
  lte: ParkingTransactionDebitType
  like: ParkingTransactionDebitType
  notLike: ParkingTransactionDebitType
  iLike: ParkingTransactionDebitType
  notILike: ParkingTransactionDebitType
  in: [ParkingTransactionDebitType!]
  notIn: [ParkingTransactionDebitType!]
}

input ParkingTransactionCreditTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkingTransactionCreditType
  neq: ParkingTransactionCreditType
  gt: ParkingTransactionCreditType
  gte: ParkingTransactionCreditType
  lt: ParkingTransactionCreditType
  lte: ParkingTransactionCreditType
  like: ParkingTransactionCreditType
  notLike: ParkingTransactionCreditType
  iLike: ParkingTransactionCreditType
  notILike: ParkingTransactionCreditType
  in: [ParkingTransactionCreditType!]
  notIn: [ParkingTransactionCreditType!]
}

input ParkingTransactionAggregateFilterPayoutMethodAggregateFilter {
  and: [ParkingTransactionAggregateFilterPayoutMethodAggregateFilter!]
  or: [ParkingTransactionAggregateFilterPayoutMethodAggregateFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

input ParkingTransactionFilter {
  and: [ParkingTransactionFilter!]
  or: [ParkingTransactionFilter!]
  id: IDFilterComparison
  status: TransactionStatusFilterComparison
  type: TransactionTypeFilterComparison
  debitType: ParkingTransactionDebitTypeFilterComparison
  creditType: ParkingTransactionCreditTypeFilterComparison
  currency: StringFieldComparison
  amount: NumberFieldComparison
  customerId: IDFilterComparison
  payoutSessionId: IDFilterComparison
  payoutAccountId: IDFilterComparison
  payoutMethodId: IDFilterComparison
  payoutSessionMethodId: IDFilterComparison
  parkSpotId: IDFilterComparison
  payoutMethod: ParkingTransactionFilterPayoutMethodFilter
}

input ParkingTransactionFilterPayoutMethodFilter {
  and: [ParkingTransactionFilterPayoutMethodFilter!]
  or: [ParkingTransactionFilterPayoutMethodFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  currency: StringFieldComparison
  name: StringFieldComparison
  type: PayoutMethodTypeFilterComparison
}

input ParkingTransactionSort {
  field: ParkingTransactionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingTransactionSortFields {
  id
  status
  type
  debitType
  creditType
  currency
  amount
  customerId
  payoutSessionId
  payoutAccountId
  payoutMethodId
  payoutSessionMethodId
  parkSpotId
}

type ParkingPayoutSession {
  id: ID!
  createdAt: DateTime!
  processedAt: DateTime
  description: String
  status: PayoutSessionStatus!
  totalAmount: Float!
  currency: String!
  parkingTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingTransactionAggregateFilter
  ): [ParkingPayoutSessionParkingTransactionsAggregateResponse!]!
  parkingTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingTransactionSort!]! = []
  ): ParkingPayoutSessionParkingTransactionsConnection!
  payoutMethodDetails(
    """Specify to filter the records returned."""
    filter: ParkingPayoutSessionPayoutMethodDetailFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingPayoutSessionPayoutMethodDetailSort!]! = []
  ): [ParkingPayoutSessionPayoutMethodDetail!]!
  payoutMethods(
    """Specify to filter the records returned."""
    filter: PayoutMethodFilter! = {}

    """Specify to sort results."""
    sorting: [PayoutMethodSort!]! = []
  ): [PayoutMethod!]!
}

input ParkingPayoutSessionPayoutMethodDetailFilter {
  and: [ParkingPayoutSessionPayoutMethodDetailFilter!]
  or: [ParkingPayoutSessionPayoutMethodDetailFilter!]
  id: IDFilterComparison
}

input ParkingPayoutSessionPayoutMethodDetailSort {
  field: ParkingPayoutSessionPayoutMethodDetailSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingPayoutSessionPayoutMethodDetailSortFields {
  id
}

type ParkingPayoutSessionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingPayoutSession!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingPayoutSessionParkingTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingPayoutSessionParkingTransactionsAggregateGroupBy {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionParkingTransactionsCountAggregate {
  id: Int
  status: Int
  type: Int
  debitType: Int
  creditType: Int
  currency: Int
  amount: Int
  customerId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
  parkSpotId: Int
}

type ParkingPayoutSessionParkingTransactionsSumAggregate {
  id: Float
  amount: Float
  customerId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
  parkSpotId: Float
}

type ParkingPayoutSessionParkingTransactionsAvgAggregate {
  id: Float
  amount: Float
  customerId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
  parkSpotId: Float
}

type ParkingPayoutSessionParkingTransactionsMinAggregate {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionParkingTransactionsMaxAggregate {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionParkingTransactionsAggregateResponse {
  groupBy: ParkingPayoutSessionParkingTransactionsAggregateGroupBy
  count: ParkingPayoutSessionParkingTransactionsCountAggregate
  sum: ParkingPayoutSessionParkingTransactionsSumAggregate
  avg: ParkingPayoutSessionParkingTransactionsAvgAggregate
  min: ParkingPayoutSessionParkingTransactionsMinAggregate
  max: ParkingPayoutSessionParkingTransactionsMaxAggregate
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAggregateGroupBy {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsCountAggregate {
  id: Int
  status: Int
  type: Int
  debitType: Int
  creditType: Int
  currency: Int
  amount: Int
  customerId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
  parkSpotId: Int
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsSumAggregate {
  id: Float
  amount: Float
  customerId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
  parkSpotId: Float
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAvgAggregate {
  id: Float
  amount: Float
  customerId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
  parkSpotId: Float
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsMinAggregate {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsMaxAggregate {
  id: ID
  status: TransactionStatus
  type: TransactionType
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  currency: String
  amount: Float
  customerId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
  parkSpotId: ID
}

type ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAggregateResponse {
  groupBy: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAggregateGroupBy
  count: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsCountAggregate
  sum: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsSumAggregate
  avg: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsAvgAggregate
  min: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsMinAggregate
  max: ParkingPayoutSessionPayoutMethodDetailParkingTransactionsMaxAggregate
}

type PayoutMethodDeleteResponse {
  id: ID
  enabled: Boolean
  currency: String
  name: String
  description: String
  type: PayoutMethodType
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: String
  mediaId: ID
  balance: Float
}

type PayoutMethodConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [PayoutMethod!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PayoutAccountEdge {
  """The node containing the PayoutAccount"""
  node: PayoutAccount!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

type RegionDeleteResponse {
  id: ID
  name: String
  currency: String
  enabled: Boolean
  location: [[Point!]!]
  categoryId: ID
}

type RegionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Region!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RegionAggregateGroupBy {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionCountAggregate {
  id: Int
  name: Int
  currency: Int
  categoryId: Int
}

type RegionSumAggregate {
  id: Float
  categoryId: Float
}

type RegionAvgAggregate {
  id: Float
  categoryId: Float
}

type RegionMinAggregate {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionMaxAggregate {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionAggregateResponse {
  groupBy: RegionAggregateGroupBy
  count: RegionCountAggregate
  sum: RegionSumAggregate
  avg: RegionAvgAggregate
  min: RegionMinAggregate
  max: RegionMaxAggregate
}

type RegionTaxiOrdersConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Order!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RegionTaxiOrdersAggregateGroupBy {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RegionTaxiOrdersCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  distanceBest: Int
  durationBest: Int
  costBest: Int
  costAfterCoupon: Int
  currency: Int
  riderId: Int
  paymentMode: Int
  driverId: Int
  regionId: Int
  fleetId: Int
  serviceId: Int
}

type RegionTaxiOrdersSumAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type RegionTaxiOrdersAvgAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type RegionTaxiOrdersMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RegionTaxiOrdersMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RegionTaxiOrdersAggregateResponse {
  groupBy: RegionTaxiOrdersAggregateGroupBy
  count: RegionTaxiOrdersCountAggregate
  sum: RegionTaxiOrdersSumAggregate
  avg: RegionTaxiOrdersAvgAggregate
  min: RegionTaxiOrdersMinAggregate
  max: RegionTaxiOrdersMaxAggregate
}

type RegionCategoryDeleteResponse {
  id: ID
  name: String
  currency: String
}

type RegionCategoryAggregateGroupBy {
  id: ID
}

type RegionCategoryCountAggregate {
  id: Int
}

type RegionCategorySumAggregate {
  id: Float
}

type RegionCategoryAvgAggregate {
  id: Float
}

type RegionCategoryMinAggregate {
  id: ID
}

type RegionCategoryMaxAggregate {
  id: ID
}

type RegionCategoryAggregateResponse {
  groupBy: RegionCategoryAggregateGroupBy
  count: RegionCategoryCountAggregate
  sum: RegionCategorySumAggregate
  avg: RegionCategoryAvgAggregate
  min: RegionCategoryMinAggregate
  max: RegionCategoryMaxAggregate
}

type RegionCategoryRegionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Region!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RegionCategoryRegionsAggregateGroupBy {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionCategoryRegionsCountAggregate {
  id: Int
  name: Int
  currency: Int
  categoryId: Int
}

type RegionCategoryRegionsSumAggregate {
  id: Float
  categoryId: Float
}

type RegionCategoryRegionsAvgAggregate {
  id: Float
  categoryId: Float
}

type RegionCategoryRegionsMinAggregate {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionCategoryRegionsMaxAggregate {
  id: ID
  name: String
  currency: String
  categoryId: ID
}

type RegionCategoryRegionsAggregateResponse {
  groupBy: RegionCategoryRegionsAggregateGroupBy
  count: RegionCategoryRegionsCountAggregate
  sum: RegionCategoryRegionsSumAggregate
  avg: RegionCategoryRegionsAvgAggregate
  min: RegionCategoryRegionsMinAggregate
  max: RegionCategoryRegionsMaxAggregate
}

type CustomerNote {
  id: ID!
  createdAt: DateTime!
  customerId: ID!
  note: String!
  createdById: ID!
  customer: Rider!
  createdBy: Operator!
}

type CustomerSession {
  id: ID!
  sessionInfo: SessionInfo!
  customerId: ID!
}

type RiderConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Rider!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderAggregateGroupBy {
  id: ID
  status: RiderStatus
  firstName: String
  lastName: String
  mobileNumber: String
  gender: Gender
}

type RiderCountAggregate {
  id: Int
  status: Int
  firstName: Int
  lastName: Int
  mobileNumber: Int
  gender: Int
}

type RiderSumAggregate {
  id: Float
}

type RiderAvgAggregate {
  id: Float
}

type RiderMinAggregate {
  id: ID
  status: RiderStatus
  firstName: String
  lastName: String
  mobileNumber: String
  gender: Gender
}

type RiderMaxAggregate {
  id: ID
  status: RiderStatus
  firstName: String
  lastName: String
  mobileNumber: String
  gender: Gender
}

type RiderAggregateResponse {
  groupBy: RiderAggregateGroupBy
  count: RiderCountAggregate
  sum: RiderSumAggregate
  avg: RiderAvgAggregate
  min: RiderMinAggregate
  max: RiderMaxAggregate
}

type RiderOrdersConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Order!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderTransactionsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderAddressesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderAddress!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderOrdersAggregateGroupBy {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RiderOrdersCountAggregate {
  id: Int
  createdOn: Int
  status: Int
  distanceBest: Int
  durationBest: Int
  costBest: Int
  costAfterCoupon: Int
  currency: Int
  riderId: Int
  paymentMode: Int
  driverId: Int
  regionId: Int
  fleetId: Int
  serviceId: Int
}

type RiderOrdersSumAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type RiderOrdersAvgAggregate {
  id: Float
  distanceBest: Float
  durationBest: Float
  costBest: Float
  costAfterCoupon: Float
  riderId: Float
  driverId: Float
  regionId: Float
  fleetId: Float
  serviceId: Float
}

type RiderOrdersMinAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RiderOrdersMaxAggregate {
  id: ID
  createdOn: DateTime
  status: OrderStatus
  distanceBest: Int
  durationBest: Int
  costBest: Float
  costAfterCoupon: Float
  currency: String
  riderId: ID
  paymentMode: PaymentMode
  driverId: ID
  regionId: ID
  fleetId: ID
  serviceId: ID
}

type RiderOrdersAggregateResponse {
  groupBy: RiderOrdersAggregateGroupBy
  count: RiderOrdersCountAggregate
  sum: RiderOrdersSumAggregate
  avg: RiderOrdersAvgAggregate
  min: RiderOrdersMinAggregate
  max: RiderOrdersMaxAggregate
}

type RiderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type RiderTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type RiderTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type RiderTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type RiderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type RiderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type RiderTransactionsAggregateResponse {
  groupBy: RiderTransactionsAggregateGroupBy
  count: RiderTransactionsCountAggregate
  sum: RiderTransactionsSumAggregate
  avg: RiderTransactionsAvgAggregate
  min: RiderTransactionsMinAggregate
  max: RiderTransactionsMaxAggregate
}

type RiderParkingWalletsAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type RiderParkingWalletsCountAggregate {
  id: Int
  balance: Int
  currency: Int
  customerId: Int
}

type RiderParkingWalletsSumAggregate {
  id: Float
  balance: Float
  customerId: Float
}

type RiderParkingWalletsAvgAggregate {
  id: Float
  balance: Float
  customerId: Float
}

type RiderParkingWalletsMinAggregate {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type RiderParkingWalletsMaxAggregate {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type RiderParkingWalletsAggregateResponse {
  groupBy: RiderParkingWalletsAggregateGroupBy
  count: RiderParkingWalletsCountAggregate
  sum: RiderParkingWalletsSumAggregate
  avg: RiderParkingWalletsAvgAggregate
  min: RiderParkingWalletsMinAggregate
  max: RiderParkingWalletsMaxAggregate
}

type RiderWalletAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  riderId: ID
}

type RiderWalletCountAggregate {
  id: Int
  balance: Int
  currency: Int
  riderId: Int
}

type RiderWalletSumAggregate {
  id: Float
  balance: Float
  riderId: Float
}

type RiderWalletAvgAggregate {
  id: Float
  balance: Float
  riderId: Float
}

type RiderWalletMinAggregate {
  id: ID
  balance: Float
  currency: String
  riderId: ID
}

type RiderWalletMaxAggregate {
  id: ID
  balance: Float
  currency: String
  riderId: ID
}

type RiderWalletAggregateResponse {
  groupBy: RiderWalletAggregateGroupBy
  count: RiderWalletCountAggregate
  sum: RiderWalletSumAggregate
  avg: RiderWalletAvgAggregate
  min: RiderWalletMinAggregate
  max: RiderWalletMaxAggregate
}

type RiderAddressesAggregateGroupBy {
  id: ID
  riderId: ID
}

type RiderAddressesCountAggregate {
  id: Int
  riderId: Int
}

type RiderAddressesSumAggregate {
  id: Float
  riderId: Float
}

type RiderAddressesAvgAggregate {
  id: Float
  riderId: Float
}

type RiderAddressesMinAggregate {
  id: ID
  riderId: ID
}

type RiderAddressesMaxAggregate {
  id: ID
  riderId: ID
}

type RiderAddressesAggregateResponse {
  groupBy: RiderAddressesAggregateGroupBy
  count: RiderAddressesCountAggregate
  sum: RiderAddressesSumAggregate
  avg: RiderAddressesAvgAggregate
  min: RiderAddressesMinAggregate
  max: RiderAddressesMaxAggregate
}

type RiderWalletConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderWallet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type RiderAddressConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [RiderAddress!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SavedPaymentMethodDeleteResponse {
  id: ID
  title: String
  lastFour: String
  isDefault: Boolean
  type: SavedPaymentMethodType
  providerBrand: ProviderBrand
  expiryDate: DateTime
  holderName: String
}

type SavedPaymentMethodConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [SavedPaymentMethod!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CustomerSessionDeleteResponse {
  id: ID
  sessionInfo: SessionInfo
  customerId: ID
}

type ServiceCategory {
  id: ID!
  name: String!
  services(
    """Specify to filter the records returned."""
    filter: ServiceFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceSort!]! = []
  ): [Service!]!
}

type ServiceDeleteResponse {
  id: ID
  name: String
  description: String
  orderTypes: [TaxiOrderType!]
  personCapacity: Int
  categoryId: ID
  baseFare: Float
  roundingFactor: Float
  perHundredMeters: Float
  perMinuteDrive: Float
  perMinuteWait: Float
  prepayPercent: Float
  minimumFee: Float
  searchRadius: Int
  paymentMethod: ServicePaymentMethod
  cancellationTotalFee: Float
  cancellationDriverShare: Float
  providerSharePercent: Int
  providerShareFlat: Float
  twoWayAvailable: Boolean
  maximumDestinationDistance: Int
  timeMultipliers: [TimeMultiplier!]
  distanceMultipliers: [DistanceMultiplier!]
  weekdayMultipliers: [WeekdayMultiplier!]
  dateRangeMultipliers: [DateRangeMultiplier!]
  mediaId: ID
}

type ServiceCategoryDeleteResponse {
  id: ID
  name: String
}

type ServiceOptionDeleteResponse {
  id: ID
  name: String
  type: ServiceOptionType
  additionalFee: Float
  icon: ServiceOptionIcon
}

type MediaEdge {
  """The node containing the Media"""
  node: Media!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type SOSActivity {
  id: ID!
  createdAt: DateTime!
  action: SOSActivityAction!
  note: String
  operatorId: ID!
  operator: Operator!
}

enum SOSActivityAction {
  Submitted
  Seen
  ContactDriver
  ContactAuthorities
  MarkedAsResolved
  MarkedAsFalseAlarm
}

type SOSReason {
  id: ID!
  name: String!
  isActive: Boolean!
  sosAggregate(
    """Filter to find records to aggregate on"""
    filter: DistressSignalAggregateFilter
  ): [SOSReasonSosAggregateResponse!]!
  sos(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DistressSignalFilter! = {}

    """Specify to sort results."""
    sorting: [DistressSignalSort!]! = []
  ): SOSReasonSosConnection!
}

input DistressSignalAggregateFilter {
  and: [DistressSignalAggregateFilter!]
  or: [DistressSignalAggregateFilter!]
  id: IDFilterComparison
  status: SOSStatusFilterComparison
}

input SOSStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SOSStatus
  neq: SOSStatus
  gt: SOSStatus
  gte: SOSStatus
  lt: SOSStatus
  lte: SOSStatus
  like: SOSStatus
  notLike: SOSStatus
  iLike: SOSStatus
  notILike: SOSStatus
  in: [SOSStatus!]
  notIn: [SOSStatus!]
}

enum SOSStatus {
  Submitted
  UnderReview
  FalseAlarm
  Resolved
}

input DistressSignalFilter {
  and: [DistressSignalFilter!]
  or: [DistressSignalFilter!]
  id: IDFilterComparison
  status: SOSStatusFilterComparison
}

input DistressSignalSort {
  field: DistressSignalSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DistressSignalSortFields {
  id
  status
}

type DistressSignal {
  id: ID!
  createdAt: DateTime!
  status: SOSStatus!
  comment: String
  location: Point
  submittedByRider: Boolean!
  requestId: ID!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: SOSActivityAggregateFilter
  ): [DistressSignalActivitiesAggregateResponse!]!
  order: Order!
  reason: SOSReason
  activities(
    """Specify to filter the records returned."""
    filter: SOSActivityFilter! = {}

    """Specify to sort results."""
    sorting: [SOSActivitySort!]! = []
  ): [SOSActivity!]!
}

input SOSActivityAggregateFilter {
  and: [SOSActivityAggregateFilter!]
  or: [SOSActivityAggregateFilter!]
  id: IDFilterComparison
}

input SOSActivityFilter {
  and: [SOSActivityFilter!]
  or: [SOSActivityFilter!]
  id: IDFilterComparison
}

input SOSActivitySort {
  field: SOSActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SOSActivitySortFields {
  id
}

type DistressSignalConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DistressSignal!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DistressSignalAggregateGroupBy {
  id: ID
  status: SOSStatus
}

type DistressSignalCountAggregate {
  id: Int
  status: Int
}

type DistressSignalSumAggregate {
  id: Float
}

type DistressSignalAvgAggregate {
  id: Float
}

type DistressSignalMinAggregate {
  id: ID
  status: SOSStatus
}

type DistressSignalMaxAggregate {
  id: ID
  status: SOSStatus
}

type DistressSignalAggregateResponse {
  groupBy: DistressSignalAggregateGroupBy
  count: DistressSignalCountAggregate
  sum: DistressSignalSumAggregate
  avg: DistressSignalAvgAggregate
  min: DistressSignalMinAggregate
  max: DistressSignalMaxAggregate
}

type DistressSignalActivitiesAggregateGroupBy {
  id: ID
}

type DistressSignalActivitiesCountAggregate {
  id: Int
}

type DistressSignalActivitiesSumAggregate {
  id: Float
}

type DistressSignalActivitiesAvgAggregate {
  id: Float
}

type DistressSignalActivitiesMinAggregate {
  id: ID
}

type DistressSignalActivitiesMaxAggregate {
  id: ID
}

type DistressSignalActivitiesAggregateResponse {
  groupBy: DistressSignalActivitiesAggregateGroupBy
  count: DistressSignalActivitiesCountAggregate
  sum: DistressSignalActivitiesSumAggregate
  avg: DistressSignalActivitiesAvgAggregate
  min: DistressSignalActivitiesMinAggregate
  max: DistressSignalActivitiesMaxAggregate
}

type SOSReasonDeleteResponse {
  id: ID
  name: String
  isActive: Boolean
}

type SOSReasonConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [SOSReason!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SOSReasonSosConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [DistressSignal!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SOSReasonSosAggregateGroupBy {
  id: ID
  status: SOSStatus
}

type SOSReasonSosCountAggregate {
  id: Int
  status: Int
}

type SOSReasonSosSumAggregate {
  id: Float
}

type SOSReasonSosAvgAggregate {
  id: Float
}

type SOSReasonSosMinAggregate {
  id: ID
  status: SOSStatus
}

type SOSReasonSosMaxAggregate {
  id: ID
  status: SOSStatus
}

type SOSReasonSosAggregateResponse {
  groupBy: SOSReasonSosAggregateGroupBy
  count: SOSReasonSosCountAggregate
  sum: SOSReasonSosSumAggregate
  avg: SOSReasonSosAvgAggregate
  min: SOSReasonSosMinAggregate
  max: SOSReasonSosMaxAggregate
}

type Reward {
  id: ID!
  title: String!
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType!
  beneficiary: RewardBeneficiary!
  event: RewardEvent!
  creditGift: Float!
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

enum RewardAppType {
  Driver
  Rider
}

enum RewardBeneficiary {
  Self
  Referrer
}

enum RewardEvent {
  Register
  ServiceCompleted
}

type RewardDeleteResponse {
  id: ID
  title: String
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType
  beneficiary: RewardBeneficiary
  event: RewardEvent
  creditGift: Float
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

type RewardConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Reward!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type GiftCode {
  id: ID!
  code: String!
  usedAt: DateTime
  giftId: ID!
  riderTransaction: RiderTransaction
  driverTransaction: DriverTransaction
}

type GiftBatch {
  id: ID!
  name: String!
  currency: String!
  amount: Float!
  availableFrom: DateTime
  expireAt: DateTime
  giftCodesAggregate(
    """Filter to find records to aggregate on"""
    filter: GiftCodeAggregateFilter
  ): [GiftBatchGiftCodesAggregateResponse!]!
  giftCodes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: GiftCodeFilter! = {}

    """Specify to sort results."""
    sorting: [GiftCodeSort!]! = []
  ): GiftBatchGiftCodesConnection!
}

input GiftCodeAggregateFilter {
  and: [GiftCodeAggregateFilter!]
  or: [GiftCodeAggregateFilter!]
  id: IDFilterComparison
  usedAt: DateFieldComparison
  giftId: IDFilterComparison
}

input GiftCodeFilter {
  and: [GiftCodeFilter!]
  or: [GiftCodeFilter!]
  id: IDFilterComparison
  usedAt: DateFieldComparison
  giftId: IDFilterComparison
}

input GiftCodeSort {
  field: GiftCodeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum GiftCodeSortFields {
  id
  usedAt
  giftId
}

type GiftBatchConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [GiftBatch!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type GiftBatchGiftCodesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [GiftCode!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type GiftBatchGiftCodesAggregateGroupBy {
  id: ID
  usedAt: DateTime
  giftId: ID
}

type GiftBatchGiftCodesCountAggregate {
  id: Int
  usedAt: Int
  giftId: Int
}

type GiftBatchGiftCodesSumAggregate {
  id: Float
  giftId: Float
}

type GiftBatchGiftCodesAvgAggregate {
  id: Float
  giftId: Float
}

type GiftBatchGiftCodesMinAggregate {
  id: ID
  usedAt: DateTime
  giftId: ID
}

type GiftBatchGiftCodesMaxAggregate {
  id: ID
  usedAt: DateTime
  giftId: ID
}

type GiftBatchGiftCodesAggregateResponse {
  groupBy: GiftBatchGiftCodesAggregateGroupBy
  count: GiftBatchGiftCodesCountAggregate
  sum: GiftBatchGiftCodesSumAggregate
  avg: GiftBatchGiftCodesAvgAggregate
  min: GiftBatchGiftCodesMinAggregate
  max: GiftBatchGiftCodesMaxAggregate
}

type GiftCodeConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [GiftCode!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SMS {
  id: ID!
  countryIsoCode: String!
  to: String!
  from: String!
  message: String!
  status: SMSStatus!
  type: SMSType!
  providerId: ID!
}

enum SMSStatus {
  PENDING
  SENT
  FAILED
  DELIVERED
  UNDELIVERED
  REJECTED
  EXPIRED
}

enum SMSType {
  OTP
  NOTIFICATION
  PROMOTIONAL
  TRANSACTIONAL
}

"""SMS Provider"""
type SMSProvider {
  id: ID!
  name: String!
  type: SMSProviderType!
  isDefault: Boolean!
  accountId: ID!
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
  messagesAggregate(
    """Filter to find records to aggregate on"""
    filter: SMSAggregateFilter
  ): [SMSProviderMessagesAggregateResponse!]!
  messages(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: SMSFilter! = {}

    """Specify to sort results."""
    sorting: [SMSSort!]! = []
  ): SMSProviderMessagesConnection!
}

"""The type of the SMS provider"""
enum SMSProviderType {
  Firebase
  Twilio
  Plivo
  Pahappa
  BroadNet
  Vonage
  ClickSend
  Infobip
  MessageBird
  VentisSMS
}

input SMSAggregateFilter {
  and: [SMSAggregateFilter!]
  or: [SMSAggregateFilter!]
  id: IDFilterComparison
}

input SMSFilter {
  and: [SMSFilter!]
  or: [SMSFilter!]
  id: IDFilterComparison
}

input SMSSort {
  field: SMSSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SMSSortFields {
  id
}

type SMSProviderDeleteResponse {
  id: ID
  name: String
  type: SMSProviderType
  isDefault: Boolean
  accountId: ID
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
}

type SMSProviderConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [SMSProvider!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SMSProviderMessagesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [SMS!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type SMSProviderMessagesAggregateGroupBy {
  id: ID
}

type SMSProviderMessagesCountAggregate {
  id: Int
}

type SMSProviderMessagesSumAggregate {
  id: Float
}

type SMSProviderMessagesAvgAggregate {
  id: Float
}

type SMSProviderMessagesMinAggregate {
  id: ID
}

type SMSProviderMessagesMaxAggregate {
  id: ID
}

type SMSProviderMessagesAggregateResponse {
  groupBy: SMSProviderMessagesAggregateGroupBy
  count: SMSProviderMessagesCountAggregate
  sum: SMSProviderMessagesSumAggregate
  avg: SMSProviderMessagesAvgAggregate
  min: SMSProviderMessagesMinAggregate
  max: SMSProviderMessagesMaxAggregate
}

type SMSDeleteResponse {
  id: ID
  countryIsoCode: String
  to: String
  from: String
  message: String
  status: SMSStatus
  type: SMSType
  providerId: ID
}

type SMSConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [SMS!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DispatcherShop {
  id: ID!
  name: String!
  status: ShopStatus!
  mobileNumber: PhoneNumber!
  ownerInformation: PersonalInfo!
  email: String
  address: String!
  password: String
  createdAt: DateTime!
  weeklySchedule: [WeekdaySchedule!]!
  orderQueueLevel: OrderQueueLevel!
  isExpressDeliveryAvailable: Boolean!
  isShopDeliveryAvailable: Boolean!

  """
  The percentage of the delivery fee that shop pays so the delivery fee would be more appealing to the users.
  """
  expressDeliveryShopCommission: Int!
  isOnlinePaymentAvailable: Boolean!
  isCashOnDeliveryAvailable: Boolean!
  lastActivityAt: DateTime
  description: String
  location: Point!
  currency: String!
  ratingAggregate: RatingAggregate!
  itemPresetsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopItemPresetAggregateFilter
  ): [ShopItemPresetsAggregateResponse!]!
  categoriesAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopCategoryAggregateFilter
  ): [ShopCategoriesAggregateResponse!]!
  sessionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopSessionAggregateFilter
  ): [ShopSessionsAggregateResponse!]!
  walletAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopWalletAggregateFilter
  ): [ShopWalletAggregateResponse!]!
  cartsAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopOrderCartAggregateFilter
  ): [ShopCartsAggregateResponse!]!
  image: Media
  itemPresets(
    """Specify to filter the records returned."""
    filter: ShopItemPresetFilter! = {}

    """Specify to sort results."""
    sorting: [ShopItemPresetSort!]! = []
  ): [ShopItemPreset!]!
  categories(
    """Specify to filter the records returned."""
    filter: ShopCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ShopCategorySort!]! = []
  ): [ShopCategory!]!
  sessions(
    """Specify to filter the records returned."""
    filter: ShopSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSessionSort!]! = []
  ): [ShopSession!]!
  wallet(
    """Specify to filter the records returned."""
    filter: ShopWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ShopWalletSort!]! = []
  ): [ShopWallet!]!
  carts(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopOrderCartFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderCartSort!]! = []
  ): ShopCartsConnection!
  deliveryFee: Float!
  minDeliveryTime: Int!
  maxDeliveryTime: Int!
  minimumOrderAmount: Float!
}

type CalculateDeliveryFee {
  batchDeliveryFee: Float!
  batchDeliveryDuration: Int!
  splitDeliveryFee: Float!
}

type ShopSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
  actor: Operator
  assignedToStaffs: [Operator!]!
  unassignedFromStaffs: [Operator!]!
}

type ShopSupportRequest {
  id: ID!
  createdAt: DateTime!
  requestedByShop: Boolean!
  subject: String!
  content: String
  status: ComplaintStatus!
  assignedToStaffsAggregate(
    """Filter to find records to aggregate on"""
    filter: OperatorAggregateFilter
  ): [ShopSupportRequestAssignedToStaffsAggregateResponse!]!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopSupportRequestActivityAggregateFilter
  ): [ShopSupportRequestActivitiesAggregateResponse!]!
  order: ShopOrder!
  cart: ShopOrderCart
  assignedToStaffs: [Operator!]!
  activities(
    """Specify to filter the records returned."""
    filter: ShopSupportRequestActivityFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSupportRequestActivitySort!]! = []
  ): [ShopSupportRequestActivity!]!
}

input ShopSupportRequestActivityAggregateFilter {
  and: [ShopSupportRequestActivityAggregateFilter!]
  or: [ShopSupportRequestActivityAggregateFilter!]
  id: IDFilterComparison
}

input ShopSupportRequestActivityFilter {
  and: [ShopSupportRequestActivityFilter!]
  or: [ShopSupportRequestActivityFilter!]
  id: IDFilterComparison
}

input ShopSupportRequestActivitySort {
  field: ShopSupportRequestActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopSupportRequestActivitySortFields {
  id
}

type ShopSupportRequestConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopSupportRequest!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopSupportRequestAggregateGroupBy {
  id: ID
  requestedByShop: Boolean
  status: ComplaintStatus
  orderId: ID
  cartId: ID
}

type ShopSupportRequestCountAggregate {
  id: Int
  requestedByShop: Int
  status: Int
  orderId: Int
  cartId: Int
}

type ShopSupportRequestSumAggregate {
  id: Float
  orderId: Float
  cartId: Float
}

type ShopSupportRequestAvgAggregate {
  id: Float
  orderId: Float
  cartId: Float
}

type ShopSupportRequestMinAggregate {
  id: ID
  status: ComplaintStatus
  orderId: ID
  cartId: ID
}

type ShopSupportRequestMaxAggregate {
  id: ID
  status: ComplaintStatus
  orderId: ID
  cartId: ID
}

type ShopSupportRequestAggregateResponse {
  groupBy: ShopSupportRequestAggregateGroupBy
  count: ShopSupportRequestCountAggregate
  sum: ShopSupportRequestSumAggregate
  avg: ShopSupportRequestAvgAggregate
  min: ShopSupportRequestMinAggregate
  max: ShopSupportRequestMaxAggregate
}

type ShopSupportRequestActivitiesAggregateGroupBy {
  id: ID
}

type ShopSupportRequestActivitiesCountAggregate {
  id: Int
}

type ShopSupportRequestActivitiesSumAggregate {
  id: Float
}

type ShopSupportRequestActivitiesAvgAggregate {
  id: Float
}

type ShopSupportRequestActivitiesMinAggregate {
  id: ID
}

type ShopSupportRequestActivitiesMaxAggregate {
  id: ID
}

type ShopSupportRequestActivitiesAggregateResponse {
  groupBy: ShopSupportRequestActivitiesAggregateGroupBy
  count: ShopSupportRequestActivitiesCountAggregate
  sum: ShopSupportRequestActivitiesSumAggregate
  avg: ShopSupportRequestActivitiesAvgAggregate
  min: ShopSupportRequestActivitiesMinAggregate
  max: ShopSupportRequestActivitiesMaxAggregate
}

type ShopSupportRequestAssignedToStaffsAggregateGroupBy {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  isBlocked: Boolean
  email: String
  roleId: ID
}

type ShopSupportRequestAssignedToStaffsCountAggregate {
  id: Int
  firstName: Int
  lastName: Int
  userName: Int
  mobileNumber: Int
  isBlocked: Int
  email: Int
  roleId: Int
}

type ShopSupportRequestAssignedToStaffsSumAggregate {
  id: Float
  roleId: Float
}

type ShopSupportRequestAssignedToStaffsAvgAggregate {
  id: Float
  roleId: Float
}

type ShopSupportRequestAssignedToStaffsMinAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type ShopSupportRequestAssignedToStaffsMaxAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type ShopSupportRequestAssignedToStaffsAggregateResponse {
  groupBy: ShopSupportRequestAssignedToStaffsAggregateGroupBy
  count: ShopSupportRequestAssignedToStaffsCountAggregate
  sum: ShopSupportRequestAssignedToStaffsSumAggregate
  avg: ShopSupportRequestAssignedToStaffsAvgAggregate
  min: ShopSupportRequestAssignedToStaffsMinAggregate
  max: ShopSupportRequestAssignedToStaffsMaxAggregate
}

type Note {
  createdAt: DateTime!
  note: String!
  staffId: ID!
}

type ShopOrderNote {
  id: ID!
  note: Note!
  orderId: ID!
  staffId: ID!
  order: ShopOrder!
  staff: Operator!
}

type ShopFeedbackConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopFeedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopFeedbackParameterDeleteResponse {
  id: ID
  isGood: Boolean
  name: String
}

type ShopFeedbackParameterConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopFeedbackParameter!]!
}

type ShopNote {
  id: ID!
  note: Note!
  shopId: ID!
  staffId: ID!
  shop: Shop!
  staff: Operator!
}

type ShopLoginSession {
  id: ID!
  sessionInfo: SessionInfo!
  shopId: ID!
}

type ShopDeliveryZone {
  id: ID!
  shopId: ID!
  name: String!
  deliveryFee: Float!
  minDeliveryTimeMinutes: Int!
  maxDeliveryTimeMinutes: Int!
  minimumOrderAmount: Float!
  enabled: Boolean!
  location: [[Point!]!]!
}

type ShopCategoryDeleteResponse {
  id: ID
  name: String
  status: ShopCategoryStatus
}

type ShopCategoryConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopCategory!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopCategoryShopsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Shop!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopDeleteResponse {
  id: ID
  name: String
  status: ShopStatus
  mobileNumber: PhoneNumber
  ownerInformation: PersonalInfo
  email: String
  address: String
  password: String
  createdAt: DateTime
  weeklySchedule: [WeekdaySchedule!]
  orderQueueLevel: OrderQueueLevel
  isExpressDeliveryAvailable: Boolean
  isShopDeliveryAvailable: Boolean

  """
  The percentage of the delivery fee that shop pays so the delivery fee would be more appealing to the users.
  """
  expressDeliveryShopCommission: Int
  isOnlinePaymentAvailable: Boolean
  isCashOnDeliveryAvailable: Boolean
  lastActivityAt: DateTime
  description: String
  location: Point
  currency: String
  ratingAggregate: RatingAggregate
}

type ShopConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Shop!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopAggregateGroupBy {
  id: ID
  name: String
  status: ShopStatus
  ratingAggregate: RatingAggregate
}

type ShopCountAggregate {
  id: Int
  name: Int
  status: Int
  ratingAggregate: Int
}

type ShopSumAggregate {
  id: Float
}

type ShopAvgAggregate {
  id: Float
}

type ShopMinAggregate {
  id: ID
  name: String
  status: ShopStatus
  ratingAggregate: RatingAggregate
}

type ShopMaxAggregate {
  id: ID
  name: String
  status: ShopStatus
  ratingAggregate: RatingAggregate
}

type ShopAggregateResponse {
  groupBy: ShopAggregateGroupBy
  count: ShopCountAggregate
  sum: ShopSumAggregate
  avg: ShopAvgAggregate
  min: ShopMinAggregate
  max: ShopMaxAggregate
}

type ShopCartsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopOrderCart!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopCartsAggregateGroupBy {
  id: ID
  shopId: ID
}

type ShopCartsCountAggregate {
  id: Int
  shopId: Int
}

type ShopCartsSumAggregate {
  id: Float
  shopId: Float
}

type ShopCartsAvgAggregate {
  id: Float
  shopId: Float
}

type ShopCartsMinAggregate {
  id: ID
  shopId: ID
}

type ShopCartsMaxAggregate {
  id: ID
  shopId: ID
}

type ShopCartsAggregateResponse {
  groupBy: ShopCartsAggregateGroupBy
  count: ShopCartsCountAggregate
  sum: ShopCartsSumAggregate
  avg: ShopCartsAvgAggregate
  min: ShopCartsMinAggregate
  max: ShopCartsMaxAggregate
}

type ShopWalletAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  shopId: ID
}

type ShopWalletCountAggregate {
  id: Int
  balance: Int
  currency: Int
  shopId: Int
}

type ShopWalletSumAggregate {
  id: Float
  balance: Float
  shopId: Float
}

type ShopWalletAvgAggregate {
  id: Float
  balance: Float
  shopId: Float
}

type ShopWalletMinAggregate {
  id: ID
  balance: Float
  currency: String
  shopId: ID
}

type ShopWalletMaxAggregate {
  id: ID
  balance: Float
  currency: String
  shopId: ID
}

type ShopWalletAggregateResponse {
  groupBy: ShopWalletAggregateGroupBy
  count: ShopWalletCountAggregate
  sum: ShopWalletSumAggregate
  avg: ShopWalletAvgAggregate
  min: ShopWalletMinAggregate
  max: ShopWalletMaxAggregate
}

type ShopSessionsAggregateGroupBy {
  id: ID
  shopId: ID
  appType: AppType
}

type ShopSessionsCountAggregate {
  id: Int
  shopId: Int
  appType: Int
}

type ShopSessionsSumAggregate {
  id: Float
  shopId: Float
}

type ShopSessionsAvgAggregate {
  id: Float
  shopId: Float
}

type ShopSessionsMinAggregate {
  id: ID
  shopId: ID
  appType: AppType
}

type ShopSessionsMaxAggregate {
  id: ID
  shopId: ID
  appType: AppType
}

type ShopSessionsAggregateResponse {
  groupBy: ShopSessionsAggregateGroupBy
  count: ShopSessionsCountAggregate
  sum: ShopSessionsSumAggregate
  avg: ShopSessionsAvgAggregate
  min: ShopSessionsMinAggregate
  max: ShopSessionsMaxAggregate
}

type ShopCategoriesAggregateGroupBy {
  id: ID
  name: String
  status: ShopCategoryStatus
}

type ShopCategoriesCountAggregate {
  id: Int
  name: Int
  status: Int
}

type ShopCategoriesSumAggregate {
  id: Float
}

type ShopCategoriesAvgAggregate {
  id: Float
}

type ShopCategoriesMinAggregate {
  id: ID
  name: String
  status: ShopCategoryStatus
}

type ShopCategoriesMaxAggregate {
  id: ID
  name: String
  status: ShopCategoryStatus
}

type ShopCategoriesAggregateResponse {
  groupBy: ShopCategoriesAggregateGroupBy
  count: ShopCategoriesCountAggregate
  sum: ShopCategoriesSumAggregate
  avg: ShopCategoriesAvgAggregate
  min: ShopCategoriesMinAggregate
  max: ShopCategoriesMaxAggregate
}

type ShopItemPresetsAggregateGroupBy {
  id: ID
  name: String
  shopId: ID
}

type ShopItemPresetsCountAggregate {
  id: Int
  name: Int
  shopId: Int
}

type ShopItemPresetsSumAggregate {
  id: Float
  shopId: Float
}

type ShopItemPresetsAvgAggregate {
  id: Float
  shopId: Float
}

type ShopItemPresetsMinAggregate {
  id: ID
  name: String
  shopId: ID
}

type ShopItemPresetsMaxAggregate {
  id: ID
  name: String
  shopId: ID
}

type ShopItemPresetsAggregateResponse {
  groupBy: ShopItemPresetsAggregateGroupBy
  count: ShopItemPresetsCountAggregate
  sum: ShopItemPresetsSumAggregate
  avg: ShopItemPresetsAvgAggregate
  min: ShopItemPresetsMinAggregate
  max: ShopItemPresetsMaxAggregate
}

type ShopItemPresetDeleteResponse {
  id: ID
  name: String
  shopId: ID
  weeklySchedule: [WeekdaySchedule!]
}

type ShopItemPresetConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopItemPreset!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopItemPresetItemsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Item!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopItemPresetItemCategoriesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ItemCategory!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ItemCategoryDeleteResponse {
  id: ID
  name: String
  shopId: ID
}

type ItemCategoryConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ItemCategory!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ItemCategoryItemsConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Item!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ItemDeleteResponse {
  id: ID
  name: String
  description: String

  """The base price of the item"""
  basePrice: Float
  ratingAggregate: RatingAggregate
  shopId: ID

  """The stock quantity"""
  stockQuantity: Int
  discountPercentage: Int
  discountedQuantity: Int
  discountUntil: DateTime
  usedDiscountedQuantity: Int
}

type ItemConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [Item!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ItemFeedbacksConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopFeedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopDeliveryZoneDeleteResponse {
  id: ID
  shopId: ID
  name: String
  deliveryFee: Float
  minDeliveryTimeMinutes: Int
  maxDeliveryTimeMinutes: Int
  minimumOrderAmount: Float
  enabled: Boolean
  location: [[Point!]!]
}

type ShopDeliveryZoneConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopDeliveryZone!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopOrderConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopOrder!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ShopOrderAggregateGroupBy {
  id: ID
  createdAt(by: GroupBy! = DAY): DateTime
  status: ShopOrderStatus
  currency: String
  deliveryMethod: DeliveryMethod
  paymentMethod: PaymentMode
  customerId: ID
  total: Float
}

type ShopOrderCountAggregate {
  id: Int
  createdAt: Int
  status: Int
  currency: Int
  deliveryMethod: Int
  paymentMethod: Int
  customerId: Int
  total: Int
}

type ShopOrderSumAggregate {
  id: Float
  customerId: Float
  total: Float
}

type ShopOrderAvgAggregate {
  id: Float
  customerId: Float
  total: Float
}

type ShopOrderMinAggregate {
  id: ID
  createdAt: DateTime
  status: ShopOrderStatus
  currency: String
  deliveryMethod: DeliveryMethod
  paymentMethod: PaymentMode
  customerId: ID
  total: Float
}

type ShopOrderMaxAggregate {
  id: ID
  createdAt: DateTime
  status: ShopOrderStatus
  currency: String
  deliveryMethod: DeliveryMethod
  paymentMethod: PaymentMode
  customerId: ID
  total: Float
}

type ShopOrderAggregateResponse {
  groupBy: ShopOrderAggregateGroupBy
  count: ShopOrderCountAggregate
  sum: ShopOrderSumAggregate
  avg: ShopOrderAvgAggregate
  min: ShopOrderMinAggregate
  max: ShopOrderMaxAggregate
}

type ShopOrderStatusHistoriesAggregateGroupBy {
  id: ID
  orderId: ID
}

type ShopOrderStatusHistoriesCountAggregate {
  id: Int
  orderId: Int
}

type ShopOrderStatusHistoriesSumAggregate {
  id: Float
  orderId: Float
}

type ShopOrderStatusHistoriesAvgAggregate {
  id: Float
  orderId: Float
}

type ShopOrderStatusHistoriesMinAggregate {
  id: ID
  orderId: ID
}

type ShopOrderStatusHistoriesMaxAggregate {
  id: ID
  orderId: ID
}

type ShopOrderStatusHistoriesAggregateResponse {
  groupBy: ShopOrderStatusHistoriesAggregateGroupBy
  count: ShopOrderStatusHistoriesCountAggregate
  sum: ShopOrderStatusHistoriesSumAggregate
  avg: ShopOrderStatusHistoriesAvgAggregate
  min: ShopOrderStatusHistoriesMinAggregate
  max: ShopOrderStatusHistoriesMaxAggregate
}

type ShopOrderDriverTransactionsAggregateGroupBy {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopOrderDriverTransactionsCountAggregate {
  id: Int
  createdAt: Int
  action: Int
  status: Int
  amount: Int
  currency: Int
  driverId: Int
  paymentGatewayId: Int
  payoutSessionId: Int
  payoutAccountId: Int
  payoutMethodId: Int
  payoutSessionMethodId: Int
}

type ShopOrderDriverTransactionsSumAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopOrderDriverTransactionsAvgAggregate {
  id: Float
  amount: Float
  driverId: Float
  paymentGatewayId: Float
  payoutSessionId: Float
  payoutAccountId: Float
  payoutMethodId: Float
  payoutSessionMethodId: Float
}

type ShopOrderDriverTransactionsMinAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopOrderDriverTransactionsMaxAggregate {
  id: ID
  createdAt: DateTime
  action: TransactionAction
  status: TransactionStatus
  amount: Float
  currency: String
  driverId: ID
  paymentGatewayId: ID
  payoutSessionId: ID
  payoutAccountId: ID
  payoutMethodId: ID
  payoutSessionMethodId: ID
}

type ShopOrderDriverTransactionsAggregateResponse {
  groupBy: ShopOrderDriverTransactionsAggregateGroupBy
  count: ShopOrderDriverTransactionsCountAggregate
  sum: ShopOrderDriverTransactionsSumAggregate
  avg: ShopOrderDriverTransactionsAvgAggregate
  min: ShopOrderDriverTransactionsMinAggregate
  max: ShopOrderDriverTransactionsMaxAggregate
}

type ShopOrderRiderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ShopOrderRiderTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type ShopOrderRiderTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ShopOrderRiderTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ShopOrderRiderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ShopOrderRiderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ShopOrderRiderTransactionsAggregateResponse {
  groupBy: ShopOrderRiderTransactionsAggregateGroupBy
  count: ShopOrderRiderTransactionsCountAggregate
  sum: ShopOrderRiderTransactionsSumAggregate
  avg: ShopOrderRiderTransactionsAvgAggregate
  min: ShopOrderRiderTransactionsMinAggregate
  max: ShopOrderRiderTransactionsMaxAggregate
}

type ShopOrderCartsAggregateGroupBy {
  id: ID
  shopId: ID
}

type ShopOrderCartsCountAggregate {
  id: Int
  shopId: Int
}

type ShopOrderCartsSumAggregate {
  id: Float
  shopId: Float
}

type ShopOrderCartsAvgAggregate {
  id: Float
  shopId: Float
}

type ShopOrderCartsMinAggregate {
  id: ID
  shopId: ID
}

type ShopOrderCartsMaxAggregate {
  id: ID
  shopId: ID
}

type ShopOrderCartsAggregateResponse {
  groupBy: ShopOrderCartsAggregateGroupBy
  count: ShopOrderCartsCountAggregate
  sum: ShopOrderCartsSumAggregate
  avg: ShopOrderCartsAvgAggregate
  min: ShopOrderCartsMinAggregate
  max: ShopOrderCartsMaxAggregate
}

type ShopWalletConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ShopWallet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkOrderNote {
  id: ID!
  createdAt: DateTime!
  parkOrderId: ID!
  note: String!
  staff: Operator!
  parkOrder: ParkOrder!
}

type ParkOrderActivity {
  id: ID!
  updatedAt: DateTime
  status: ParkOrderStatus!
  expectedBy: DateTime
}

"""park order status, Pending is the default status prior to payment"""
enum ParkOrderStatus {
  PENDING
  PAID
  CANCELLED
  ACCEPTED
  REJECTED
  COMPLETED
}

type ParkingFeedbackParameter {
  id: ID!
  isGood: Boolean!
  name: String!
  feedbacksAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingFeedbackParameterAggregateFilter
  ): [ParkingFeedbackParameterFeedbacksAggregateResponse!]!
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingFeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackParameterSort!]! = []
  ): ParkingFeedbackParameterFeedbacksConnection!
}

input ParkingFeedbackParameterAggregateFilter {
  and: [ParkingFeedbackParameterAggregateFilter!]
  or: [ParkingFeedbackParameterAggregateFilter!]
  id: IDFilterComparison
}

input ParkingFeedbackParameterFilter {
  and: [ParkingFeedbackParameterFilter!]
  or: [ParkingFeedbackParameterFilter!]
  id: IDFilterComparison
}

input ParkingFeedbackParameterSort {
  field: ParkingFeedbackParameterSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingFeedbackParameterSortFields {
  id
}

type ParkingFeedback {
  id: ID!

  """The score of the review, from 0 to 100"""
  score: Int!
  comment: String
  status: ReviewStatus!
  createdAt: DateTime!
  parkSpotId: ID!
  customerId: ID!
  parametersAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingFeedbackParameterAggregateFilter
  ): [ParkingFeedbackParametersAggregateResponse!]!
  order: ParkOrder!
  parameters(
    """Specify to filter the records returned."""
    filter: ParkingFeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackParameterSort!]! = []
  ): [ParkingFeedbackParameter!]!
}

type ParkOrder {
  id: ID!
  createdAt: DateTime!
  enterTime: DateTime!
  exitTime: DateTime!
  extendedExitTime: DateTime
  vehicleType: ParkSpotVehicleType!
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode!
  parkSpotId: ID!
  price: Float!
  currency: String!
  status: ParkOrderStatus!
  carOwnerId: ID!
  notesAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkOrderNoteAggregateFilter
  ): [ParkOrderNotesAggregateResponse!]!
  feedbacksAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingFeedbackAggregateFilter
  ): [ParkOrderFeedbacksAggregateResponse!]!
  customerTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [ParkOrderCustomerTransactionsAggregateResponse!]!
  parkOwnerTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderTransactionAggregateFilter
  ): [ParkOrderParkOwnerTransactionsAggregateResponse!]!
  providerTransactionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProviderTransactionAggregateFilter
  ): [ParkOrderProviderTransactionsAggregateResponse!]!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkOrderActivityAggregateFilter
  ): [ParkOrderActivitiesAggregateResponse!]!
  parkSpot: ParkSpot!
  spotOwner: Rider
  carOwner: Rider
  paymentGateway: PaymentGateway
  savedPaymentMethod: SavedPaymentMethod
  notes(
    """Specify to filter the records returned."""
    filter: ParkOrderNoteFilter! = {}

    """Specify to sort results."""
    sorting: [ParkOrderNoteSort!]! = []
  ): [ParkOrderNote!]!
  feedbacks(
    """Specify to filter the records returned."""
    filter: ParkingFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackSort!]! = []
  ): [ParkingFeedback!]!
  customerTransactions(
    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): [RiderTransaction!]!
  parkOwnerTransactions(
    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): [RiderTransaction!]!
  providerTransactions(
    """Specify to filter the records returned."""
    filter: ProviderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ProviderTransactionSort!]! = []
  ): [ProviderTransaction!]!
  activities(
    """Specify to filter the records returned."""
    filter: ParkOrderActivityFilter! = {}

    """Specify to sort results."""
    sorting: [ParkOrderActivitySort!]! = []
  ): [ParkOrderActivity!]!
}

"""The type of ride that can be parked in a park spot"""
enum ParkSpotVehicleType {
  Car
  Bike
  Truck
}

enum ParkSpotCarSize {
  SMALL
  MEDIUM
  LARGE
  VERY_LARGE
}

input ParkOrderNoteAggregateFilter {
  and: [ParkOrderNoteAggregateFilter!]
  or: [ParkOrderNoteAggregateFilter!]
  id: IDFilterComparison
  parkOrderId: IDFilterComparison
}

input ParkingFeedbackAggregateFilter {
  and: [ParkingFeedbackAggregateFilter!]
  or: [ParkingFeedbackAggregateFilter!]
  id: IDFilterComparison
  score: IntFieldComparison
  status: ReviewStatusFilterComparison
  parkSpotId: IDFilterComparison
  customerId: IDFilterComparison
  order: ParkingFeedbackAggregateFilterParkOrderAggregateFilter
}

input ParkingFeedbackAggregateFilterParkOrderAggregateFilter {
  and: [ParkingFeedbackAggregateFilterParkOrderAggregateFilter!]
  or: [ParkingFeedbackAggregateFilterParkOrderAggregateFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input ParkSpotVehicleTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkSpotVehicleType
  neq: ParkSpotVehicleType
  gt: ParkSpotVehicleType
  gte: ParkSpotVehicleType
  lt: ParkSpotVehicleType
  lte: ParkSpotVehicleType
  like: ParkSpotVehicleType
  notLike: ParkSpotVehicleType
  iLike: ParkSpotVehicleType
  notILike: ParkSpotVehicleType
  in: [ParkSpotVehicleType!]
  notIn: [ParkSpotVehicleType!]
}

input ParkSpotCarSizeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkSpotCarSize
  neq: ParkSpotCarSize
  gt: ParkSpotCarSize
  gte: ParkSpotCarSize
  lt: ParkSpotCarSize
  lte: ParkSpotCarSize
  like: ParkSpotCarSize
  notLike: ParkSpotCarSize
  iLike: ParkSpotCarSize
  notILike: ParkSpotCarSize
  in: [ParkSpotCarSize!]
  notIn: [ParkSpotCarSize!]
}

input ParkOrderStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkOrderStatus
  neq: ParkOrderStatus
  gt: ParkOrderStatus
  gte: ParkOrderStatus
  lt: ParkOrderStatus
  lte: ParkOrderStatus
  like: ParkOrderStatus
  notLike: ParkOrderStatus
  iLike: ParkOrderStatus
  notILike: ParkOrderStatus
  in: [ParkOrderStatus!]
  notIn: [ParkOrderStatus!]
}

input ParkOrderActivityAggregateFilter {
  and: [ParkOrderActivityAggregateFilter!]
  or: [ParkOrderActivityAggregateFilter!]
  id: IDFilterComparison
}

input ParkOrderNoteFilter {
  and: [ParkOrderNoteFilter!]
  or: [ParkOrderNoteFilter!]
  id: IDFilterComparison
  parkOrderId: IDFilterComparison
}

input ParkOrderNoteSort {
  field: ParkOrderNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkOrderNoteSortFields {
  id
  parkOrderId
}

input ParkingFeedbackFilter {
  and: [ParkingFeedbackFilter!]
  or: [ParkingFeedbackFilter!]
  id: IDFilterComparison
  score: IntFieldComparison
  status: ReviewStatusFilterComparison
  parkSpotId: IDFilterComparison
  customerId: IDFilterComparison
  order: ParkingFeedbackFilterParkOrderFilter
}

input ParkingFeedbackFilterParkOrderFilter {
  and: [ParkingFeedbackFilterParkOrderFilter!]
  or: [ParkingFeedbackFilterParkOrderFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input ParkingFeedbackSort {
  field: ParkingFeedbackSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingFeedbackSortFields {
  id
  score
  status
  parkSpotId
  customerId
}

input ParkOrderActivityFilter {
  and: [ParkOrderActivityFilter!]
  or: [ParkOrderActivityFilter!]
  id: IDFilterComparison
}

input ParkOrderActivitySort {
  field: ParkOrderActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkOrderActivitySortFields {
  id
}

type ParkSpot {
  id: ID!
  status: ParkSpotStatus!
  type: ParkSpotType!
  name: String!
  location: Point!
  address: String
  phoneNumber: String
  email: String
  ratingAggregate: RatingAggregate!
  openHour: String
  createdAt: DateTime!
  weeklySchedule: [WeekdaySchedule!]!
  lastActivityAt: DateTime
  closeHour: String
  acceptNewRequest: Boolean!
  acceptExtendRequest: Boolean!
  carSize: ParkSpotCarSize
  carPrice: Float
  carSpaces: Int!
  bikePrice: Float
  bikeSpaces: Int!
  truckPrice: Float
  truckSpaces: Int!
  currency: String!
  description: String
  operatorName: String
  operatorPhoneCountryCode: String
  operatorPhoneNumber: String
  facilities: [ParkSpotFacility!]!
  mainImageId: ID!
  imagesAggregate(
    """Filter to find records to aggregate on"""
    filter: MediaAggregateFilter
  ): [ParkSpotImagesAggregateResponse!]!
  feedbacksAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingFeedbackAggregateFilter
  ): [ParkSpotFeedbacksAggregateResponse!]!
  parkOrdersAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkOrderAggregateFilter
  ): [ParkSpotParkOrdersAggregateResponse!]!
  mainImage: Media
  owner: Rider
  images(
    """Specify to filter the records returned."""
    filter: MediaFilter! = {}

    """Specify to sort results."""
    sorting: [MediaSort!]! = []
  ): [Media!]!
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackSort!]! = []
  ): ParkSpotFeedbacksConnection!
  parkOrders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkOrderFilter! = {}

    """Specify to sort results."""
    sorting: [ParkOrderSort!]! = []
  ): ParkSpotParkOrdersConnection!
}

"""The status of the park spot"""
enum ParkSpotStatus {
  Pending
  Active
  Blocked
  Inactive
}

"""
The type of the park spot, If personal then show the location as name, If public then show the name as location
"""
enum ParkSpotType {
  PERSONAL
  PUBLIC
}

"""List of possible park spot facilities. This enum is used in ParkSpot."""
enum ParkSpotFacility {
  GUARDED
  COVERED
  CCTV
  ELECTRIC_CHARGING
  CAR_WASH
  TOILET
}

input MediaAggregateFilter {
  and: [MediaAggregateFilter!]
  or: [MediaAggregateFilter!]
  id: IDFilterComparison
}

input ParkOrderAggregateFilter {
  and: [ParkOrderAggregateFilter!]
  or: [ParkOrderAggregateFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input MediaFilter {
  and: [MediaFilter!]
  or: [MediaFilter!]
  id: IDFilterComparison
}

input MediaSort {
  field: MediaSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum MediaSortFields {
  id
}

input ParkOrderFilter {
  and: [ParkOrderFilter!]
  or: [ParkOrderFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input ParkOrderSort {
  field: ParkOrderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkOrderSortFields {
  id
  enterTime
  exitTime
  vehicleType
  carSize
  paymentMethod
  parkSpotId
  price
  currency
  status
  carOwnerId
}

type ParkSpotNote {
  id: ID!
  createdAt: DateTime!
  parkSpotId: ID!
  note: String!
  parkSpot: ParkSpot!
  staff: Operator!
}

type ParkingFeedbackConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingFeedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingFeedbackAggregateGroupBy {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkingFeedbackCountAggregate {
  id: Int
  score: Int
  status: Int
  parkSpotId: Int
  customerId: Int
}

type ParkingFeedbackSumAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkingFeedbackAvgAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkingFeedbackMinAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkingFeedbackMaxAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkingFeedbackAggregateResponse {
  groupBy: ParkingFeedbackAggregateGroupBy
  count: ParkingFeedbackCountAggregate
  sum: ParkingFeedbackSumAggregate
  avg: ParkingFeedbackAvgAggregate
  min: ParkingFeedbackMinAggregate
  max: ParkingFeedbackMaxAggregate
}

type ParkingFeedbackParametersAggregateGroupBy {
  id: ID
}

type ParkingFeedbackParametersCountAggregate {
  id: Int
}

type ParkingFeedbackParametersSumAggregate {
  id: Float
}

type ParkingFeedbackParametersAvgAggregate {
  id: Float
}

type ParkingFeedbackParametersMinAggregate {
  id: ID
}

type ParkingFeedbackParametersMaxAggregate {
  id: ID
}

type ParkingFeedbackParametersAggregateResponse {
  groupBy: ParkingFeedbackParametersAggregateGroupBy
  count: ParkingFeedbackParametersCountAggregate
  sum: ParkingFeedbackParametersSumAggregate
  avg: ParkingFeedbackParametersAvgAggregate
  min: ParkingFeedbackParametersMinAggregate
  max: ParkingFeedbackParametersMaxAggregate
}

type ParkingFeedbackParameterDeleteResponse {
  id: ID
  isGood: Boolean
  name: String
}

type ParkingFeedbackParameterFeedbacksConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingFeedbackParameter!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingFeedbackParameterFeedbacksAggregateGroupBy {
  id: ID
}

type ParkingFeedbackParameterFeedbacksCountAggregate {
  id: Int
}

type ParkingFeedbackParameterFeedbacksSumAggregate {
  id: Float
}

type ParkingFeedbackParameterFeedbacksAvgAggregate {
  id: Float
}

type ParkingFeedbackParameterFeedbacksMinAggregate {
  id: ID
}

type ParkingFeedbackParameterFeedbacksMaxAggregate {
  id: ID
}

type ParkingFeedbackParameterFeedbacksAggregateResponse {
  groupBy: ParkingFeedbackParameterFeedbacksAggregateGroupBy
  count: ParkingFeedbackParameterFeedbacksCountAggregate
  sum: ParkingFeedbackParameterFeedbacksSumAggregate
  avg: ParkingFeedbackParameterFeedbacksAvgAggregate
  min: ParkingFeedbackParameterFeedbacksMinAggregate
  max: ParkingFeedbackParameterFeedbacksMaxAggregate
}

type ParkingSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
  actor: Operator
  assignedToStaffs: [Operator!]!
  unassignedFromStaffs: [Operator!]!
}

type ParkingSupportRequest {
  id: ID!
  createdAt: DateTime!
  requestedByOwner: Boolean!
  subject: String!
  content: String
  status: ComplaintStatus!
  assignedToStaffsAggregate(
    """Filter to find records to aggregate on"""
    filter: OperatorAggregateFilter
  ): [ParkingSupportRequestAssignedToStaffsAggregateResponse!]!
  activitiesAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingSupportRequestActivityAggregateFilter
  ): [ParkingSupportRequestActivitiesAggregateResponse!]!
  parkOrder: ParkOrder!
  assignedToStaffs: [Operator!]!
  activities(
    """Specify to filter the records returned."""
    filter: ParkingSupportRequestActivityFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingSupportRequestActivitySort!]! = []
  ): [ParkingSupportRequestActivity!]!
}

input ParkingSupportRequestActivityAggregateFilter {
  and: [ParkingSupportRequestActivityAggregateFilter!]
  or: [ParkingSupportRequestActivityAggregateFilter!]
  id: IDFilterComparison
}

input ParkingSupportRequestActivityFilter {
  and: [ParkingSupportRequestActivityFilter!]
  or: [ParkingSupportRequestActivityFilter!]
  id: IDFilterComparison
}

input ParkingSupportRequestActivitySort {
  field: ParkingSupportRequestActivitySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingSupportRequestActivitySortFields {
  id
}

type ParkingSupportRequestConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingSupportRequest!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingSupportRequestAggregateGroupBy {
  id: ID
  requestedByOwner: Boolean
  status: ComplaintStatus
  parkOrderId: ID
}

type ParkingSupportRequestCountAggregate {
  id: Int
  requestedByOwner: Int
  status: Int
  parkOrderId: Int
}

type ParkingSupportRequestSumAggregate {
  id: Float
  parkOrderId: Float
}

type ParkingSupportRequestAvgAggregate {
  id: Float
  parkOrderId: Float
}

type ParkingSupportRequestMinAggregate {
  id: ID
  status: ComplaintStatus
  parkOrderId: ID
}

type ParkingSupportRequestMaxAggregate {
  id: ID
  status: ComplaintStatus
  parkOrderId: ID
}

type ParkingSupportRequestAggregateResponse {
  groupBy: ParkingSupportRequestAggregateGroupBy
  count: ParkingSupportRequestCountAggregate
  sum: ParkingSupportRequestSumAggregate
  avg: ParkingSupportRequestAvgAggregate
  min: ParkingSupportRequestMinAggregate
  max: ParkingSupportRequestMaxAggregate
}

type ParkingSupportRequestActivitiesAggregateGroupBy {
  id: ID
}

type ParkingSupportRequestActivitiesCountAggregate {
  id: Int
}

type ParkingSupportRequestActivitiesSumAggregate {
  id: Float
}

type ParkingSupportRequestActivitiesAvgAggregate {
  id: Float
}

type ParkingSupportRequestActivitiesMinAggregate {
  id: ID
}

type ParkingSupportRequestActivitiesMaxAggregate {
  id: ID
}

type ParkingSupportRequestActivitiesAggregateResponse {
  groupBy: ParkingSupportRequestActivitiesAggregateGroupBy
  count: ParkingSupportRequestActivitiesCountAggregate
  sum: ParkingSupportRequestActivitiesSumAggregate
  avg: ParkingSupportRequestActivitiesAvgAggregate
  min: ParkingSupportRequestActivitiesMinAggregate
  max: ParkingSupportRequestActivitiesMaxAggregate
}

type ParkingSupportRequestAssignedToStaffsAggregateGroupBy {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  isBlocked: Boolean
  email: String
  roleId: ID
}

type ParkingSupportRequestAssignedToStaffsCountAggregate {
  id: Int
  firstName: Int
  lastName: Int
  userName: Int
  mobileNumber: Int
  isBlocked: Int
  email: Int
  roleId: Int
}

type ParkingSupportRequestAssignedToStaffsSumAggregate {
  id: Float
  roleId: Float
}

type ParkingSupportRequestAssignedToStaffsAvgAggregate {
  id: Float
  roleId: Float
}

type ParkingSupportRequestAssignedToStaffsMinAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type ParkingSupportRequestAssignedToStaffsMaxAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type ParkingSupportRequestAssignedToStaffsAggregateResponse {
  groupBy: ParkingSupportRequestAssignedToStaffsAggregateGroupBy
  count: ParkingSupportRequestAssignedToStaffsCountAggregate
  sum: ParkingSupportRequestAssignedToStaffsSumAggregate
  avg: ParkingSupportRequestAssignedToStaffsAvgAggregate
  min: ParkingSupportRequestAssignedToStaffsMinAggregate
  max: ParkingSupportRequestAssignedToStaffsMaxAggregate
}

type ParkingLoginSession {
  id: ID!
  sessionInfo: SessionInfo!
  customerId: ID!
}

type ParkSpotConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkSpot!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkSpotAggregateGroupBy {
  id: ID
  status: ParkSpotStatus
  type: ParkSpotType
  name: String
  address: String
  ratingAggregate: RatingAggregate
  carSize: ParkSpotCarSize
}

type ParkSpotCountAggregate {
  id: Int
  status: Int
  type: Int
  name: Int
  address: Int
  ratingAggregate: Int
  carSize: Int
}

type ParkSpotSumAggregate {
  id: Float
}

type ParkSpotAvgAggregate {
  id: Float
}

type ParkSpotMinAggregate {
  id: ID
  status: ParkSpotStatus
  type: ParkSpotType
  name: String
  address: String
  ratingAggregate: RatingAggregate
  carSize: ParkSpotCarSize
}

type ParkSpotMaxAggregate {
  id: ID
  status: ParkSpotStatus
  type: ParkSpotType
  name: String
  address: String
  ratingAggregate: RatingAggregate
  carSize: ParkSpotCarSize
}

type ParkSpotAggregateResponse {
  groupBy: ParkSpotAggregateGroupBy
  count: ParkSpotCountAggregate
  sum: ParkSpotSumAggregate
  avg: ParkSpotAvgAggregate
  min: ParkSpotMinAggregate
  max: ParkSpotMaxAggregate
}

type ParkSpotParkOrdersConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkOrder!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkSpotFeedbacksConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingFeedback!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkSpotParkOrdersAggregateGroupBy {
  id: ID
  enterTime: DateTime
  exitTime: DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkSpotParkOrdersCountAggregate {
  id: Int
  enterTime: Int
  exitTime: Int
  vehicleType: Int
  carSize: Int
  paymentMethod: Int
  parkSpotId: Int
  price: Int
  currency: Int
  status: Int
  carOwnerId: Int
}

type ParkSpotParkOrdersSumAggregate {
  id: Float
  parkSpotId: Float
  price: Float
  carOwnerId: Float
}

type ParkSpotParkOrdersAvgAggregate {
  id: Float
  parkSpotId: Float
  price: Float
  carOwnerId: Float
}

type ParkSpotParkOrdersMinAggregate {
  id: ID
  enterTime: DateTime
  exitTime: DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkSpotParkOrdersMaxAggregate {
  id: ID
  enterTime: DateTime
  exitTime: DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkSpotParkOrdersAggregateResponse {
  groupBy: ParkSpotParkOrdersAggregateGroupBy
  count: ParkSpotParkOrdersCountAggregate
  sum: ParkSpotParkOrdersSumAggregate
  avg: ParkSpotParkOrdersAvgAggregate
  min: ParkSpotParkOrdersMinAggregate
  max: ParkSpotParkOrdersMaxAggregate
}

type ParkSpotFeedbacksAggregateGroupBy {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkSpotFeedbacksCountAggregate {
  id: Int
  score: Int
  status: Int
  parkSpotId: Int
  customerId: Int
}

type ParkSpotFeedbacksSumAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkSpotFeedbacksAvgAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkSpotFeedbacksMinAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkSpotFeedbacksMaxAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkSpotFeedbacksAggregateResponse {
  groupBy: ParkSpotFeedbacksAggregateGroupBy
  count: ParkSpotFeedbacksCountAggregate
  sum: ParkSpotFeedbacksSumAggregate
  avg: ParkSpotFeedbacksAvgAggregate
  min: ParkSpotFeedbacksMinAggregate
  max: ParkSpotFeedbacksMaxAggregate
}

type ParkSpotImagesAggregateGroupBy {
  id: ID
}

type ParkSpotImagesCountAggregate {
  id: Int
}

type ParkSpotImagesSumAggregate {
  id: Float
}

type ParkSpotImagesAvgAggregate {
  id: Float
}

type ParkSpotImagesMinAggregate {
  id: ID
}

type ParkSpotImagesMaxAggregate {
  id: ID
}

type ParkSpotImagesAggregateResponse {
  groupBy: ParkSpotImagesAggregateGroupBy
  count: ParkSpotImagesCountAggregate
  sum: ParkSpotImagesSumAggregate
  avg: ParkSpotImagesAvgAggregate
  min: ParkSpotImagesMinAggregate
  max: ParkSpotImagesMaxAggregate
}

type ParkOrderConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkOrder!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkOrderAggregateGroupBy {
  id: ID
  enterTime(by: GroupBy! = DAY): DateTime
  exitTime(by: GroupBy! = DAY): DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkOrderCountAggregate {
  id: Int
  enterTime: Int
  exitTime: Int
  vehicleType: Int
  carSize: Int
  paymentMethod: Int
  parkSpotId: Int
  price: Int
  currency: Int
  status: Int
  carOwnerId: Int
}

type ParkOrderSumAggregate {
  id: Float
  parkSpotId: Float
  price: Float
  carOwnerId: Float
}

type ParkOrderAvgAggregate {
  id: Float
  parkSpotId: Float
  price: Float
  carOwnerId: Float
}

type ParkOrderMinAggregate {
  id: ID
  enterTime: DateTime
  exitTime: DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkOrderMaxAggregate {
  id: ID
  enterTime: DateTime
  exitTime: DateTime
  vehicleType: ParkSpotVehicleType
  carSize: ParkSpotCarSize
  paymentMethod: PaymentMode
  parkSpotId: ID
  price: Float
  currency: String
  status: ParkOrderStatus
  carOwnerId: ID
}

type ParkOrderAggregateResponse {
  groupBy: ParkOrderAggregateGroupBy
  count: ParkOrderCountAggregate
  sum: ParkOrderSumAggregate
  avg: ParkOrderAvgAggregate
  min: ParkOrderMinAggregate
  max: ParkOrderMaxAggregate
}

type ParkOrderActivitiesAggregateGroupBy {
  id: ID
}

type ParkOrderActivitiesCountAggregate {
  id: Int
}

type ParkOrderActivitiesSumAggregate {
  id: Float
}

type ParkOrderActivitiesAvgAggregate {
  id: Float
}

type ParkOrderActivitiesMinAggregate {
  id: ID
}

type ParkOrderActivitiesMaxAggregate {
  id: ID
}

type ParkOrderActivitiesAggregateResponse {
  groupBy: ParkOrderActivitiesAggregateGroupBy
  count: ParkOrderActivitiesCountAggregate
  sum: ParkOrderActivitiesSumAggregate
  avg: ParkOrderActivitiesAvgAggregate
  min: ParkOrderActivitiesMinAggregate
  max: ParkOrderActivitiesMaxAggregate
}

type ParkOrderProviderTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ParkOrderProviderTransactionsCountAggregate {
  id: Int
  action: Int
  deductType: Int
  rechargeType: Int
  expenseType: Int
  amount: Int
  currency: Int
  operatorId: Int
  requestId: Int
  parkOrderId: Int
  shopOrderCartId: Int
}

type ParkOrderProviderTransactionsSumAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type ParkOrderProviderTransactionsAvgAggregate {
  id: Float
  amount: Float
  operatorId: Float
  requestId: Float
  parkOrderId: Float
  shopOrderCartId: Float
}

type ParkOrderProviderTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ParkOrderProviderTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  expenseType: ProviderExpenseType
  amount: Float
  currency: String
  operatorId: ID
  requestId: ID
  parkOrderId: ID
  shopOrderCartId: ID
}

type ParkOrderProviderTransactionsAggregateResponse {
  groupBy: ParkOrderProviderTransactionsAggregateGroupBy
  count: ParkOrderProviderTransactionsCountAggregate
  sum: ParkOrderProviderTransactionsSumAggregate
  avg: ParkOrderProviderTransactionsAvgAggregate
  min: ParkOrderProviderTransactionsMinAggregate
  max: ParkOrderProviderTransactionsMaxAggregate
}

type ParkOrderParkOwnerTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderParkOwnerTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type ParkOrderParkOwnerTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ParkOrderParkOwnerTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ParkOrderParkOwnerTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderParkOwnerTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderParkOwnerTransactionsAggregateResponse {
  groupBy: ParkOrderParkOwnerTransactionsAggregateGroupBy
  count: ParkOrderParkOwnerTransactionsCountAggregate
  sum: ParkOrderParkOwnerTransactionsSumAggregate
  avg: ParkOrderParkOwnerTransactionsAvgAggregate
  min: ParkOrderParkOwnerTransactionsMinAggregate
  max: ParkOrderParkOwnerTransactionsMaxAggregate
}

type ParkOrderCustomerTransactionsAggregateGroupBy {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderCustomerTransactionsCountAggregate {
  id: Int
  action: Int
  createdAt: Int
  deductType: Int
  rechargeType: Int
  status: Int
  amount: Int
  currency: Int
  riderId: Int
  paymentGatewayId: Int
  savedPaymentMethodId: Int
  operatorId: Int
  requestId: Int
  shopOrderId: Int
  parkOrderParkOwnerId: Int
  parkOrderCustomerId: Int
}

type ParkOrderCustomerTransactionsSumAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ParkOrderCustomerTransactionsAvgAggregate {
  id: Float
  amount: Float
  riderId: Float
  paymentGatewayId: Float
  savedPaymentMethodId: Float
  operatorId: Float
  requestId: Float
  shopOrderId: Float
  parkOrderParkOwnerId: Float
  parkOrderCustomerId: Float
}

type ParkOrderCustomerTransactionsMinAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderCustomerTransactionsMaxAggregate {
  id: ID
  action: TransactionAction
  createdAt: DateTime
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  status: TransactionStatus
  amount: Float
  currency: String
  riderId: ID
  paymentGatewayId: ID
  savedPaymentMethodId: ID
  operatorId: ID
  requestId: ID
  shopOrderId: ID
  parkOrderParkOwnerId: ID
  parkOrderCustomerId: ID
}

type ParkOrderCustomerTransactionsAggregateResponse {
  groupBy: ParkOrderCustomerTransactionsAggregateGroupBy
  count: ParkOrderCustomerTransactionsCountAggregate
  sum: ParkOrderCustomerTransactionsSumAggregate
  avg: ParkOrderCustomerTransactionsAvgAggregate
  min: ParkOrderCustomerTransactionsMinAggregate
  max: ParkOrderCustomerTransactionsMaxAggregate
}

type ParkOrderFeedbacksAggregateGroupBy {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkOrderFeedbacksCountAggregate {
  id: Int
  score: Int
  status: Int
  parkSpotId: Int
  customerId: Int
}

type ParkOrderFeedbacksSumAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkOrderFeedbacksAvgAggregate {
  id: Float
  score: Float
  parkSpotId: Float
  customerId: Float
}

type ParkOrderFeedbacksMinAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkOrderFeedbacksMaxAggregate {
  id: ID
  score: Int
  status: ReviewStatus
  parkSpotId: ID
  customerId: ID
}

type ParkOrderFeedbacksAggregateResponse {
  groupBy: ParkOrderFeedbacksAggregateGroupBy
  count: ParkOrderFeedbacksCountAggregate
  sum: ParkOrderFeedbacksSumAggregate
  avg: ParkOrderFeedbacksAvgAggregate
  min: ParkOrderFeedbacksMinAggregate
  max: ParkOrderFeedbacksMaxAggregate
}

type ParkOrderNotesAggregateGroupBy {
  id: ID
  parkOrderId: ID
}

type ParkOrderNotesCountAggregate {
  id: Int
  parkOrderId: Int
}

type ParkOrderNotesSumAggregate {
  id: Float
  parkOrderId: Float
}

type ParkOrderNotesAvgAggregate {
  id: Float
  parkOrderId: Float
}

type ParkOrderNotesMinAggregate {
  id: ID
  parkOrderId: ID
}

type ParkOrderNotesMaxAggregate {
  id: ID
  parkOrderId: ID
}

type ParkOrderNotesAggregateResponse {
  groupBy: ParkOrderNotesAggregateGroupBy
  count: ParkOrderNotesCountAggregate
  sum: ParkOrderNotesSumAggregate
  avg: ParkOrderNotesAvgAggregate
  min: ParkOrderNotesMinAggregate
  max: ParkOrderNotesMaxAggregate
}

type ParkOrderActivityEdge {
  """The node containing the ParkOrderActivity"""
  node: ParkOrderActivity!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type ParkingWalletConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingWallet!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ParkingWalletAggregateGroupBy {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type ParkingWalletCountAggregate {
  id: Int
  balance: Int
  currency: Int
  customerId: Int
}

type ParkingWalletSumAggregate {
  id: Float
  balance: Float
  customerId: Float
}

type ParkingWalletAvgAggregate {
  id: Float
  balance: Float
  customerId: Float
}

type ParkingWalletMinAggregate {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type ParkingWalletMaxAggregate {
  id: ID
  balance: Float
  currency: String
  customerId: ID
}

type ParkingWalletAggregateResponse {
  groupBy: ParkingWalletAggregateGroupBy
  count: ParkingWalletCountAggregate
  sum: ParkingWalletSumAggregate
  avg: ParkingWalletAvgAggregate
  min: ParkingWalletMinAggregate
  max: ParkingWalletMaxAggregate
}

type ParkingTransactionConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ParkingTransaction!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ActiveInactiveUsers {
  """Any date in the range of the data."""
  date: DateTime!
  count: Int!
  activityLevel: UserActivityLevel!
}

"""The activity level of the user."""
enum UserActivityLevel {
  Active
  Inactive
}

type CustomerLoginPerApp {
  app: AppType!
  count: Int!
}

type RevenuePerApp {
  app: AppType!
  revenue: Float!

  """Any date within the range of revenue interval."""
  date: DateTime!
}

type PlatformDistribution {
  platform: DevicePlatform!
  count: Int!
}

type LeaderboardItem {
  id: ID!
  name: String!
  avatarUrl: String
  currency: String
  totalAmount: Float
  totalCount: Int!
}

type GenderDistribution {
  gender: Gender!
  count: Int!
}

type RetentionRate {
  """Any date within the range of revenue interval."""
  date: DateTime!
  retentionRate: Float!
}

type CountryDistribution {
  country: String!
  count: Int!
}

type NameCount {
  name: String!
  count: Int!
}

type UserTypeCountPair {
  userType: AnnouncementUserType!
  count: Float!
}

type UsedUnusedCountPairDTO {
  used: Int!
  unused: Int!
}

type FinancialTimeline {
  amount: Float!

  """Any date within the range of revenue interval."""
  anyDate: DateTime!
  dateString: String!
}

type RevenueExpensePair {
  revenue: Float!
  expense: Float!
  anyDate: DateTime!
  dateString: String!
}

type ProviderExpenseBreakdownRecord {
  expenseType: ProviderExpenseType!
  value: Float!
  dateString: String!
  anyDate: DateTime!
}

type ZonePriceCategory {
  id: ID!
  name: String!
  zonePrices(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZonePriceFilter! = {}

    """Specify to sort results."""
    sorting: [ZonePriceSort!]! = []
  ): ZonePriceCategoryZonePricesConnection!
}

type ZonePriceDeleteResponse {
  id: ID
  name: String
  from: [[Point!]!]
  to: [[Point!]!]
  cost: Float
  timeMultipliers: [TimeMultiplier!]
}

type ZonePriceConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ZonePrice!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ZonePriceCategoryDeleteResponse {
  id: ID
  name: String
}

type ZonePriceCategoryZonePricesConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [ZonePrice!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type DriverDocumentDeleteResponse {
  id: ID
  title: String
  isEnabled: Boolean
  isRequired: Boolean
  hasExpiryDate: Boolean
  notificationDaysBeforeExpiry: Int
  numberOfImages: Int
}

type DriverDocumentRetentionPolicyDeleteResponse {
  id: ID
  title: String
  deleteAfterDays: Int
}

type DriverDocumentRetentionPolicyEdge {
  """The node containing the DriverDocumentRetentionPolicy"""
  node: DriverDocumentRetentionPolicy!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type DriverDocumentRetentionPolicyConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [DriverDocumentRetentionPolicyEdge!]!
}

type DriverToDriverDocumentDeleteResponse {
  id: ID
  driverId: ID
  driverDocumentId: ID
  mediaId: ID
  retentionPolicyId: ID
  expiresAt: DateTime
}

type DriverToDriverDocumentEdge {
  """The node containing the DriverToDriverDocument"""
  node: DriverToDriverDocument!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type DriverToDriverDocumentConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [DriverToDriverDocumentEdge!]!
}

type DriverShiftRule {
  id: ID!
  timeFrequency: TimeFrequency!
  maxHoursPerFrequency: Int!
  mandatoryBreakMinutes: Int!
}

enum TimeFrequency {
  Daily
  Weekly
  Monthly
  Quarterly
  Yearly
}

type DriverShiftRuleDeleteResponse {
  id: ID
  timeFrequency: TimeFrequency
  maxHoursPerFrequency: Int
  mandatoryBreakMinutes: Int
}

type TaxiSupportRequestConnection {
  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Array of nodes."""
  nodes: [TaxiSupportRequest!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaxiSupportRequestAggregateGroupBy {
  id: ID
  requestedByDriver: Boolean
  status: ComplaintStatus
  requestId: ID
}

type TaxiSupportRequestCountAggregate {
  id: Int
  requestedByDriver: Int
  status: Int
  requestId: Int
}

type TaxiSupportRequestSumAggregate {
  id: Float
  requestId: Float
}

type TaxiSupportRequestAvgAggregate {
  id: Float
  requestId: Float
}

type TaxiSupportRequestMinAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type TaxiSupportRequestMaxAggregate {
  id: ID
  status: ComplaintStatus
  requestId: ID
}

type TaxiSupportRequestAggregateResponse {
  groupBy: TaxiSupportRequestAggregateGroupBy
  count: TaxiSupportRequestCountAggregate
  sum: TaxiSupportRequestSumAggregate
  avg: TaxiSupportRequestAvgAggregate
  min: TaxiSupportRequestMinAggregate
  max: TaxiSupportRequestMaxAggregate
}

type TaxiSupportRequestAssignedToStaffsAggregateGroupBy {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  isBlocked: Boolean
  email: String
  roleId: ID
}

type TaxiSupportRequestAssignedToStaffsCountAggregate {
  id: Int
  firstName: Int
  lastName: Int
  userName: Int
  mobileNumber: Int
  isBlocked: Int
  email: Int
  roleId: Int
}

type TaxiSupportRequestAssignedToStaffsSumAggregate {
  id: Float
  roleId: Float
}

type TaxiSupportRequestAssignedToStaffsAvgAggregate {
  id: Float
  roleId: Float
}

type TaxiSupportRequestAssignedToStaffsMinAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type TaxiSupportRequestAssignedToStaffsMaxAggregate {
  id: ID
  firstName: String
  lastName: String
  userName: String
  mobileNumber: String
  email: String
  roleId: ID
}

type TaxiSupportRequestAssignedToStaffsAggregateResponse {
  groupBy: TaxiSupportRequestAssignedToStaffsAggregateGroupBy
  count: TaxiSupportRequestAssignedToStaffsCountAggregate
  sum: TaxiSupportRequestAssignedToStaffsSumAggregate
  avg: TaxiSupportRequestAssignedToStaffsAvgAggregate
  min: TaxiSupportRequestAssignedToStaffsMinAggregate
  max: TaxiSupportRequestAssignedToStaffsMaxAggregate
}

type TaxiSupportRequestActivitiesAggregateGroupBy {
  id: ID
  complaintId: ID
}

type TaxiSupportRequestActivitiesCountAggregate {
  id: Int
  complaintId: Int
}

type TaxiSupportRequestActivitiesSumAggregate {
  id: Float
  complaintId: Float
}

type TaxiSupportRequestActivitiesAvgAggregate {
  id: Float
  complaintId: Float
}

type TaxiSupportRequestActivitiesMinAggregate {
  id: ID
  complaintId: ID
}

type TaxiSupportRequestActivitiesMaxAggregate {
  id: ID
  complaintId: ID
}

type TaxiSupportRequestActivitiesAggregateResponse {
  groupBy: TaxiSupportRequestActivitiesAggregateGroupBy
  count: TaxiSupportRequestActivitiesCountAggregate
  sum: TaxiSupportRequestActivitiesSumAggregate
  avg: TaxiSupportRequestActivitiesAvgAggregate
  min: TaxiSupportRequestActivitiesMinAggregate
  max: TaxiSupportRequestActivitiesMaxAggregate
}

type KPIAppBreakdown {
  """Application key or enum value (e.g., "taxi")"""
  app: AppType!

  """Value for this app in the current time period"""
  value: Float!

  """Percentage share of the KPI that belongs to this app"""
  percentage: Float!
}

type PlatformKPIItem {
  """Display name of the KPI (e.g., "Total Orders")"""
  name: String!

  """Unit of measurement (e.g., "orders", "$")"""
  unit: String

  """Total value for the current time period"""
  total: Float!

  """Percentage change compared to the previous time period"""
  change: Float!

  """Breakdown of KPI value by sub-application (e.g., taxi, shop)"""
  breakdown: [KPIAppBreakdown!]!
}

type PlatformKPI {
  totalOrders: PlatformKPIItem!
  totalRevenue: PlatformKPIItem!
  activeCustomers: PlatformKPIItem!
}

input PointInput {
  lat: Float!
  lng: Float!
  heading: Int
}

input AppConfigInfoInput {
  logo: String
  name: String
  color: String
}

input DateRangeMultiplierInput {
  startDate: Float!
  endDate: Float!
  multiply: Float!
}

input DistanceMultiplierInput {
  distanceFrom: Float!
  distanceTo: Float!
  multiply: Float!
}

input TimeMultiplierInput {
  startTime: String!
  endTime: String!
  multiply: Float!
}

input WeekdayMultiplierInput {
  weekday: Weekday!
  multiply: Float!
}

input WeekdayScheduleInput {
  weekday: Weekday!
  openingHours: [OpeningHoursInput!]!
}

input OpeningHoursInput {
  open: String!
  close: String!
}

input RatingAggregateInput {
  rating: Int
  reviewCount: Int!
}

input PersonalInfoInput {
  firstName: String
  lastName: String
  email: String
  mobileNumber: String
  gender: Gender
  address: String
}

input PhoneNumberInput {
  countryCode: String!
  number: String!
}

input NoteInput {
  createdAt: DateTime!
  note: String!
  staffId: ID!
}

type Query {
  platformKPI(input: PlatformKPIInput!): PlatformKPI!
  currentUserSessions: [OperatorSession!]!
  getDriversLocation(center: PointInput!, count: Int!): [OnlineDriver!]!
  getDriversLocationWithData(center: PointInput!, count: Int!): [OnlineDriverWithData!]!
  driverFeedbackParametersSummary(driverId: ID!): [FeedbackParameterAggregate!]!
  calculateFare(input: CalculateFareInput!): CalculateFare!
  taxiOrderSuccessRate(startTime: DateTime, endTime: DateTime): Int
  exportCampaignCodes(batchId: ID!): String!
  incomeChart(timeframe: ChartTimeframe!): [IncomeResultItem!]!
  requestChart(timeframe: ChartTimeframe!): [RequestResultItem!]!
  driverRegistrations(timeframe: ChartTimeframe!): [RegistrationResultItem!]!
  riderRegistrations(timeframe: ChartTimeframe!): [RegistrationResultItem!]!
  export(input: ExportArgs!): ExportResult!
  totalRevenue(currency: String!): TotalDailyPair!
  totaloutstandingUserBalances(currency: String!): TotalDailyPair!
  totalExpenses(currency: String!): TotalDailyPair!
  login(userName: String!, password: String!): TokenObject!
  me: Operator!
  supportedCurrencies: [String!]!
  dispatcherShops(input: ShopFiltersInput!): [DispatcherShop!]!
  itemCategories(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ItemCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ItemCategorySort!]! = []
  ): ItemCategoryConnection!
  calculateDeliveryFee(input: CalculateDeliveryFeeInput!): CalculateDeliveryFee!
  parkings(input: ParkSpotFilterInput!): [ParkSpot!]!
  configInformation: ConfigInformation!
  licenseInformation: LicenseInformation
  currentConfiguration: CurrentConfiguration!
  notifications(type: AdminNotificationType): [AdminNotificationUnion!]!
  service(
    """The id of the record to find."""
    id: ID!
  ): Service!
  services(
    """Specify to filter the records returned."""
    filter: ServiceFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceSort!]! = []
  ): [Service!]!
  serviceCategory(
    """The id of the record to find."""
    id: ID!
  ): ServiceCategory!
  serviceCategories(
    """Specify to filter the records returned."""
    filter: ServiceCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceCategorySort!]! = []
  ): [ServiceCategory!]!
  serviceOption(
    """The id of the record to find."""
    id: ID!
  ): ServiceOption!
  serviceOptions(
    """Specify to filter the records returned."""
    filter: ServiceOptionFilter! = {}

    """Specify to sort results."""
    sorting: [ServiceOptionSort!]! = []
  ): [ServiceOption!]!
  operatorRole(
    """The id of the record to find."""
    id: ID!
  ): OperatorRole!
  operatorRoles(
    """Specify to filter the records returned."""
    filter: OperatorRoleFilter! = {}

    """Specify to sort results."""
    sorting: [OperatorRoleSort!]! = []
  ): [OperatorRole!]!
  operator(
    """The id of the record to find."""
    id: ID!
  ): Operator!
  operators(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OperatorFilter! = {}

    """Specify to sort results."""
    sorting: [OperatorSort!]! = []
  ): OperatorConnection!
  operatorSessions(
    """Specify to filter the records returned."""
    filter: OperatorSessionFilter! = {}

    """Specify to sort results."""
    sorting: [OperatorSessionSort!]! = []
  ): [OperatorSession!]!
  riderAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderAggregateFilter
  ): [RiderAggregateResponse!]!
  rider(
    """The id of the record to find."""
    id: ID!
  ): Rider!
  riders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderFilter! = {}

    """Specify to sort results."""
    sorting: [RiderSort!]! = []
  ): RiderConnection!
  riderWalletAggregate(
    """Filter to find records to aggregate on"""
    filter: RiderWalletAggregateFilter
  ): [RiderWalletAggregateResponse!]!
  riderWallet(
    """The id of the record to find."""
    id: ID!
  ): RiderWallet!
  riderWallets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderWalletFilter! = {}

    """Specify to sort results."""
    sorting: [RiderWalletSort!]! = []
  ): RiderWalletConnection!
  riderTransaction(
    """The id of the record to find."""
    id: ID!
  ): RiderTransaction!
  riderTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [RiderTransactionSort!]! = []
  ): RiderTransactionConnection!
  riderAddress(
    """The id of the record to find."""
    id: ID!
  ): RiderAddress!
  riderAddresses(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RiderAddressFilter! = {}

    """Specify to sort results."""
    sorting: [RiderAddressSort!]! = []
  ): RiderAddressConnection!
  savedPaymentMethods(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: SavedPaymentMethodFilter! = {}

    """Specify to sort results."""
    sorting: [SavedPaymentMethodSort!]! = []
  ): SavedPaymentMethodConnection!
  customerNotes(
    """Specify to filter the records returned."""
    filter: CustomerNoteFilter!

    """Specify to sort results."""
    sorting: [CustomerNoteSort!]! = []
  ): [CustomerNote!]!
  customerSessions(
    """Specify to filter the records returned."""
    filter: CustomerSessionFilter! = {}

    """Specify to sort results."""
    sorting: [CustomerSessionSort!]! = []
  ): [CustomerSession!]!
  customersPerApp: [CustomerLoginPerApp!]!
  revenuePerApp(input: ChartFilterInput!): [RevenuePerApp!]!
  customerPlatformDistribution: [PlatformDistribution!]!
  topSpendingCustomers: [LeaderboardItem!]!
  genderDistribution: [GenderDistribution!]!
  retentionRate(input: ChartFilterInput!): [RetentionRate!]!
  activeInactiveUsers(input: ChartFilterInput!): [ActiveInactiveUsers!]!
  countryDistribution: [CountryDistribution!]!
  topEarningDrivers(currency: String!): [LeaderboardItem!]!
  topTripsCompletedDrivers: [LeaderboardItem!]!
  activeInactiveDrivers: [ActiveInactiveUsers!]!
  topEarningShops: [LeaderboardItem!]!
  popularRegionsByTaxiOrders: [NameCount!]!
  ratingPointPopularities: [NameCount!]!
  cancelReasonPopularityByName: [NameCount!]!
  cancelReasonPopularityByUserType: [UserTypeCountPair!]!
  getUsedUnusedCountPair(campaignId: ID!): UsedUnusedCountPairDTO!
  fleetIncome(fleetId: ID!, input: ChartFilterInput!): [FinancialTimeline!]!

  """
  Get the average delivery time for a shop within a date range in minutes
  """
  getShopAverageDeliveryTime(input: ShopDateRangePairInput!): Float!
  providerWalletBalanceHistory(currency: String!, input: ChartFilterInput!): [FinancialTimeline!]!
  providerRevenueExpenseHistory(currency: String!, input: ChartFilterInput!): [RevenueExpensePair!]!
  providerExpenseBreakdownHistory(currency: String!, input: ChartFilterInput!): [ProviderExpenseBreakdownRecord!]!
  topEarningParkSpots(currency: String!): [LeaderboardItem!]!
  driverAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverAggregateFilter
  ): [DriverAggregateResponse!]!
  driver(
    """The id of the record to find."""
    id: ID!
  ): Driver!
  drivers(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverFilter! = {}

    """Specify to sort results."""
    sorting: [DriverSort!]! = []
  ): DriverConnection!
  driverNotes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverNoteFilter!

    """Specify to sort results."""
    sorting: [DriverNoteSort!]! = []
  ): DriverNoteConnection!
  driverWalletAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverWalletAggregateFilter
  ): [DriverWalletAggregateResponse!]!
  driverWallets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverWalletFilter! = {}

    """Specify to sort results."""
    sorting: [DriverWalletSort!]! = []
  ): DriverWalletConnection!
  driverSessions(
    """Specify to filter the records returned."""
    filter: DriverSessionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverSessionSort!]! = []
  ): [DriverSession!]!
  driverTransactionAggregate(
    """Filter to find records to aggregate on"""
    filter: DriverTransactionAggregateFilter
  ): [DriverTransactionAggregateResponse!]!
  driverTransaction(
    """The id of the record to find."""
    id: ID!
  ): DriverTransaction!
  driverTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DriverTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [DriverTransactionSort!]! = []
  ): DriverTransactionConnection!
  driverDocuments(
    """Specify to filter the records returned."""
    filter: DriverDocumentFilter! = {}

    """Specify to sort results."""
    sorting: [DriverDocumentSort!]! = []
  ): [DriverDocument!]!
  driverDocumentRetentionPolicies(
    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to filter the records returned."""
    filter: DriverDocumentRetentionPolicyFilter! = {}

    """Specify to sort results."""
    sorting: [DriverDocumentRetentionPolicySort!]! = []
  ): DriverDocumentRetentionPolicyConnection!
  driverToDriverDocuments(
    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to filter the records returned."""
    filter: DriverToDriverDocumentFilter! = {}

    """Specify to sort results."""
    sorting: [DriverToDriverDocumentSort!]! = []
  ): DriverToDriverDocumentConnection!
  driverShiftRules(
    """Specify to filter the records returned."""
    filter: DriverShiftRuleFilter! = {}

    """Specify to sort results."""
    sorting: [DriverShiftRuleSort!]! = []
  ): [DriverShiftRule!]!
  fleet(
    """The id of the record to find."""
    id: ID!
  ): Fleet!
  fleets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FleetFilter! = {}

    """Specify to sort results."""
    sorting: [FleetSort!]! = []
  ): FleetConnection!
  fleetWalletAggregate(
    """Filter to find records to aggregate on"""
    filter: FleetWalletAggregateFilter
  ): [FleetWalletAggregateResponse!]!
  fleetWallet(
    """The id of the record to find."""
    id: ID!
  ): FleetWallet!
  fleetWallets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FleetWalletFilter! = {}

    """Specify to sort results."""
    sorting: [FleetWalletSort!]! = []
  ): FleetWalletConnection!
  fleetTransactionAggregate(
    """Filter to find records to aggregate on"""
    filter: FleetTransactionAggregateFilter
  ): [FleetTransactionAggregateResponse!]!
  fleetTransaction(
    """The id of the record to find."""
    id: ID!
  ): FleetTransaction!
  fleetTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FleetTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [FleetTransactionSort!]! = []
  ): FleetTransactionConnection!
  fleetStaff(
    """The id of the record to find."""
    id: ID!
  ): FleetStaff!
  fleetStaffs(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FleetStaffFilter! = {}

    """Specify to sort results."""
    sorting: [FleetStaffSort!]! = []
  ): FleetStaffConnection!
  fleetStaffSession(
    """The id of the record to find."""
    id: ID!
  ): FleetStaffSession!
  fleetStaffSessions(
    """Specify to filter the records returned."""
    filter: FleetStaffSessionFilter! = {}

    """Specify to sort results."""
    sorting: [FleetStaffSessionSort!]! = []
  ): [FleetStaffSession!]!
  orderAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): [OrderAggregateResponse!]!
  order(
    """The id of the record to find."""
    id: ID!
  ): Order!
  orders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter! = {}

    """Specify to sort results."""
    sorting: [OrderSort!]! = []
  ): OrderConnection!
  orderCancelReason(
    """The id of the record to find."""
    id: ID!
  ): OrderCancelReason!
  orderCancelReasons(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderCancelReasonFilter! = {}

    """Specify to sort results."""
    sorting: [OrderCancelReasonSort!]! = []
  ): OrderCancelReasonConnection!
  taxiOrderNotes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxiOrderNoteFilter!

    """Specify to sort results."""
    sorting: [TaxiOrderNoteSort!]! = []
  ): TaxiOrderNoteConnection!
  announcement(
    """The id of the record to find."""
    id: ID!
  ): Announcement!
  announcements(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: AnnouncementFilter! = {}

    """Specify to sort results."""
    sorting: [AnnouncementSort!]! = []
  ): AnnouncementConnection!
  coupon(
    """The id of the record to find."""
    id: ID!
  ): Coupon!
  coupons(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CouponFilter! = {}

    """Specify to sort results."""
    sorting: [CouponSort!]! = []
  ): CouponConnection!
  campaign(
    """The id of the record to find."""
    id: ID!
  ): Campaign!
  campaigns(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CampaignFilter! = {}

    """Specify to sort results."""
    sorting: [CampaignSort!]! = []
  ): CampaignConnection!
  campaignCode(
    """The id of the record to find."""
    id: ID!
  ): CampaignCode!
  campaignCodes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CampaignCodeFilter! = {}

    """Specify to sort results."""
    sorting: [CampaignCodeSort!]! = []
  ): CampaignCodeConnection!
  giftBatch(
    """The id of the record to find."""
    id: ID!
  ): GiftBatch!
  giftBatches(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: GiftBatchFilter! = {}

    """Specify to sort results."""
    sorting: [GiftBatchSort!]! = []
  ): GiftBatchConnection!
  giftCodes(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: GiftCodeFilter! = {}

    """Specify to sort results."""
    sorting: [GiftCodeSort!]! = []
  ): GiftCodeConnection!
  providerTransactionAggregate(
    """Filter to find records to aggregate on"""
    filter: ProviderTransactionAggregateFilter
  ): [ProviderTransactionAggregateResponse!]!
  providerTransaction(
    """The id of the record to find."""
    id: ID!
  ): ProviderTransaction!
  providerTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProviderTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ProviderTransactionSort!]! = []
  ): ProviderTransactionConnection!
  providerWallet(
    """The id of the record to find."""
    id: ID!
  ): ProviderWallet!
  providerWallets(
    """Specify to filter the records returned."""
    filter: ProviderWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ProviderWalletSort!]! = []
  ): [ProviderWallet!]!
  regionAggregate(
    """Filter to find records to aggregate on"""
    filter: RegionAggregateFilter
  ): [RegionAggregateResponse!]!
  region(
    """The id of the record to find."""
    id: ID!
  ): Region!
  regions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RegionFilter! = {}

    """Specify to sort results."""
    sorting: [RegionSort!]! = []
  ): RegionConnection!
  regionCategoryAggregate(
    """Filter to find records to aggregate on"""
    filter: RegionCategoryAggregateFilter
  ): [RegionCategoryAggregateResponse!]!
  regionCategory(
    """The id of the record to find."""
    id: ID!
  ): RegionCategory!
  regionCategories(
    """Specify to filter the records returned."""
    filter: RegionCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [RegionCategorySort!]! = []
  ): [RegionCategory!]!
  paymentGateway(
    """The id of the record to find."""
    id: ID!
  ): PaymentGateway!
  paymentGateways(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: PaymentGatewayFilter! = {}

    """Specify to sort results."""
    sorting: [PaymentGatewaySort!]! = []
  ): PaymentGatewayConnection!
  carModel(
    """The id of the record to find."""
    id: ID!
  ): CarModel!
  carModels(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CarModelFilter! = {}

    """Specify to sort results."""
    sorting: [CarModelSort!]! = []
  ): CarModelConnection!
  carColor(
    """The id of the record to find."""
    id: ID!
  ): CarColor!
  carColors(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: CarColorFilter! = {}

    """Specify to sort results."""
    sorting: [CarColorSort!]! = []
  ): CarColorConnection!
  feedback(
    """The id of the record to find."""
    id: ID!
  ): Feedback!
  feedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: FeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [FeedbackSort!]! = []
  ): FeedbackConnection!
  feedbackParameter(
    """The id of the record to find."""
    id: ID!
  ): FeedbackParameter!
  feedbackParameters(
    """Specify to filter the records returned."""
    filter: FeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [FeedbackParameterSort!]! = []
  ): [FeedbackParameter!]!
  address(
    """The id of the record to find."""
    id: ID!
  ): Address!
  addresses(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: AddressFilter! = {}

    """Specify to sort results."""
    sorting: [AddressSort!]! = []
  ): AddressConnection!
  taxiPayoutStatistics(currency: String): PayoutStatistics!
  taxiPayoutSession(
    """The id of the record to find."""
    id: ID!
  ): TaxiPayoutSession!
  taxiPayoutSessions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxiPayoutSessionFilter! = {}

    """Specify to sort results."""
    sorting: [TaxiPayoutSessionSort!]! = []
  ): TaxiPayoutSessionConnection!
  shopPayoutSession(
    """The id of the record to find."""
    id: ID!
  ): ShopPayoutSession!
  shopPayoutSessions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopPayoutSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopPayoutSessionSort!]! = []
  ): ShopPayoutSessionConnection!
  parkingPayoutSession(
    """The id of the record to find."""
    id: ID!
  ): ParkingPayoutSession!
  parkingPayoutSessions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingPayoutSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingPayoutSessionSort!]! = []
  ): ParkingPayoutSessionConnection!
  payoutMethod(
    """The id of the record to find."""
    id: ID!
  ): PayoutMethod!
  payoutMethods(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: PayoutMethodFilter! = {}

    """Specify to sort results."""
    sorting: [PayoutMethodSort!]! = []
  ): PayoutMethodConnection!
  payoutAccount(
    """The id of the record to find."""
    id: ID!
  ): PayoutAccount!
  distressSignalAggregate(
    """Filter to find records to aggregate on"""
    filter: DistressSignalAggregateFilter
  ): [DistressSignalAggregateResponse!]!
  distressSignal(
    """The id of the record to find."""
    id: ID!
  ): DistressSignal!
  distressSignals(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: DistressSignalFilter! = {}

    """Specify to sort results."""
    sorting: [DistressSignalSort!]! = []
  ): DistressSignalConnection!
  sosReason(
    """The id of the record to find."""
    id: ID!
  ): SOSReason!
  sosReasons(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: SOSReasonFilter! = {}

    """Specify to sort results."""
    sorting: [SOSReasonSort!]! = []
  ): SOSReasonConnection!
  reward(
    """The id of the record to find."""
    id: ID!
  ): Reward!
  rewards(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: RewardFilter! = {}

    """Specify to sort results."""
    sorting: [RewardSort!]! = []
  ): RewardConnection!
  taxiSupportRequestAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxiSupportRequestAggregateFilter
  ): [TaxiSupportRequestAggregateResponse!]!
  taxiSupportRequest(
    """The id of the record to find."""
    id: ID!
  ): TaxiSupportRequest!
  taxiSupportRequests(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxiSupportRequestFilter! = {}

    """Specify to sort results."""
    sorting: [TaxiSupportRequestSort!]! = []
  ): TaxiSupportRequestConnection!
  shopSupportRequestAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopSupportRequestAggregateFilter
  ): [ShopSupportRequestAggregateResponse!]!
  shopSupportRequest(
    """The id of the record to find."""
    id: ID!
  ): ShopSupportRequest!
  shopSupportRequests(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopSupportRequestFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSupportRequestSort!]! = []
  ): ShopSupportRequestConnection!
  shopFeedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ShopFeedbackSort!]! = []
  ): ShopFeedbackConnection!
  shopFeedbackParameter(
    """The id of the record to find."""
    id: ID!
  ): ShopFeedbackParameter!
  shopFeedbackParameters(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopFeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [ShopFeedbackParameterSort!]! = []
  ): ShopFeedbackParameterConnection!
  shopCategory(
    """The id of the record to find."""
    id: ID!
  ): ShopCategory!
  shopCategories(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ShopCategorySort!]! = []
  ): ShopCategoryConnection!
  shopAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopAggregateFilter
  ): [ShopAggregateResponse!]!
  shop(
    """The id of the record to find."""
    id: ID!
  ): Shop!
  shops(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopFilter! = {}

    """Specify to sort results."""
    sorting: [ShopSort!]! = []
  ): ShopConnection!
  shopLoginSessions(
    """Specify to filter the records returned."""
    filter: ShopLoginSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopLoginSessionSort!]! = []
  ): [ShopLoginSession!]!
  shopOrderNotes(
    """Specify to filter the records returned."""
    filter: ShopOrderNoteFilter!

    """Specify to sort results."""
    sorting: [ShopOrderNoteSort!]! = []
  ): [ShopOrderNote!]!
  shopNotes(
    """Specify to filter the records returned."""
    filter: ShopNoteFilter!

    """Specify to sort results."""
    sorting: [ShopNoteSort!]! = []
  ): [ShopNote!]!
  shopItemPreset(
    """The id of the record to find."""
    id: ID!
  ): ShopItemPreset!
  shopItemPresets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopItemPresetFilter! = {}

    """Specify to sort results."""
    sorting: [ShopItemPresetSort!]! = []
  ): ShopItemPresetConnection!
  itemCategory(
    """The id of the record to find."""
    id: ID!
  ): ItemCategory!
  shopOrderStatusHistories(
    """Specify to filter the records returned."""
    filter: ShopOrderStatusHistoryFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderStatusHistorySort!]! = []
  ): [ShopOrderStatusHistory!]!
  item(
    """The id of the record to find."""
    id: ID!
  ): Item!
  items(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ItemFilter! = {}

    """Specify to sort results."""
    sorting: [ItemSort!]! = []
  ): ItemConnection!
  shopTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ShopTransactionSort!]! = []
  ): ShopTransactionConnection!
  shopDeliveryZone(
    """The id of the record to find."""
    id: ID!
  ): ShopDeliveryZone!
  shopDeliveryZones(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopDeliveryZoneFilter! = {}

    """Specify to sort results."""
    sorting: [ShopDeliveryZoneSort!]! = []
  ): ShopDeliveryZoneConnection!
  shopOrderAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopOrderAggregateFilter
  ): [ShopOrderAggregateResponse!]!
  shopOrder(
    """The id of the record to find."""
    id: ID!
  ): ShopOrder!
  shopOrders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopOrderFilter! = {}

    """Specify to sort results."""
    sorting: [ShopOrderSort!]! = []
  ): ShopOrderConnection!
  shopWalletAggregate(
    """Filter to find records to aggregate on"""
    filter: ShopWalletAggregateFilter
  ): [ShopWalletAggregateResponse!]!
  shopWallets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ShopWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ShopWalletSort!]! = []
  ): ShopWalletConnection!
  parkingFeedbackAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingFeedbackAggregateFilter
  ): [ParkingFeedbackAggregateResponse!]!
  parkingFeedbacks(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingFeedbackFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackSort!]! = []
  ): ParkingFeedbackConnection!
  parkingFeedbackParameter(
    """The id of the record to find."""
    id: ID!
  ): ParkingFeedbackParameter!
  parkingFeedbackParameters(
    """Specify to filter the records returned."""
    filter: ParkingFeedbackParameterFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingFeedbackParameterSort!]! = []
  ): [ParkingFeedbackParameter!]!
  parkingSupportRequestAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingSupportRequestAggregateFilter
  ): [ParkingSupportRequestAggregateResponse!]!
  parkingSupportRequest(
    """The id of the record to find."""
    id: ID!
  ): ParkingSupportRequest!
  parkingSupportRequests(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingSupportRequestFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingSupportRequestSort!]! = []
  ): ParkingSupportRequestConnection!
  parkSpotAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkSpotAggregateFilter
  ): [ParkSpotAggregateResponse!]!
  parkSpot(
    """The id of the record to find."""
    id: ID!
  ): ParkSpot!
  parkSpots(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkSpotFilter! = {}

    """Specify to sort results."""
    sorting: [ParkSpotSort!]! = []
  ): ParkSpotConnection!
  parkingLoginSessions(
    """Specify to filter the records returned."""
    filter: ParkingLoginSessionFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingLoginSessionSort!]! = []
  ): [ParkingLoginSession!]!
  parkOrderAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkOrderAggregateFilter
  ): [ParkOrderAggregateResponse!]!
  parkOrder(
    """The id of the record to find."""
    id: ID!
  ): ParkOrder!
  parkOrders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkOrderFilter! = {}

    """Specify to sort results."""
    sorting: [ParkOrderSort!]! = []
  ): ParkOrderConnection!
  parkSpotNotes(
    """Specify to filter the records returned."""
    filter: ParkSpotNoteFilter! = {}

    """Specify to sort results."""
    sorting: [ParkSpotNoteSort!]! = []
  ): [ParkSpotNote!]!
  parkingWalletAggregate(
    """Filter to find records to aggregate on"""
    filter: ParkingWalletAggregateFilter
  ): [ParkingWalletAggregateResponse!]!
  parkingWallets(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingWalletFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingWalletSort!]! = []
  ): ParkingWalletConnection!
  parkingTransactions(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ParkingTransactionFilter! = {}

    """Specify to sort results."""
    sorting: [ParkingTransactionSort!]! = []
  ): ParkingTransactionConnection!
  smsProvider(
    """The id of the record to find."""
    id: ID!
  ): SMSProvider!
  smsProviders(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: SMSProviderFilter! = {}

    """Specify to sort results."""
    sorting: [SMSProviderSort!]! = []
  ): SMSProviderConnection!
  sms(
    """The id of the record to find."""
    id: ID!
  ): SMS!
  smses(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: SMSFilter! = {}

    """Specify to sort results."""
    sorting: [SMSSort!]! = []
  ): SMSConnection!
  zonePrice(
    """The id of the record to find."""
    id: ID!
  ): ZonePrice!
  zonePrices(
    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZonePriceFilter! = {}

    """Specify to sort results."""
    sorting: [ZonePriceSort!]! = []
  ): ZonePriceConnection!
  zonePriceCategory(
    """The id of the record to find."""
    id: ID!
  ): ZonePriceCategory!
  zonePriceCategories(
    """Specify to filter the records returned."""
    filter: ZonePriceCategoryFilter! = {}

    """Specify to sort results."""
    sorting: [ZonePriceCategorySort!]! = []
  ): [ZonePriceCategory!]!
}

input PlatformKPIInput {
  """The currency for the KPI"""
  currency: String!

  """The period for the KPI"""
  period: KPIPeriod!
}

"""KPI period for the platform overview"""
enum KPIPeriod {
  Last7Days
  Last30Days
  Last90Days
  Last365Days
  AllTime
}

input CalculateFareInput {
  points: [PointInput!]!
  riderId: ID!
  orderType: TaxiOrderType!
}

enum ChartTimeframe {
  Daily
  Weekly
  Monthly
  Yearly
}

input ExportArgs {
  table: ExportTable!
  filters: [ExportFilterArg!]
  sort: ExportSortArg
  relations: [String!]
  type: ExportType!
}

enum ExportTable {
  ProviderWallet
  DriverWallet
  RiderWallet
  FleetWallet
}

input ExportFilterArg {
  field: String!
  value: String!
}

input ExportSortArg {
  property: String!
  direction: SortDirection!
}

enum ExportType {
  CSV
}

input ShopFiltersInput {
  categoryId: ID!
  addressId: ID!
  query: String
}

input CalculateDeliveryFeeInput {
  carts: [ShopOrderCartInput!]!
  deliveryAddressId: ID!
}

input ShopOrderCartInput {
  shopId: ID!
  items: [ShopOrderCartItemInput!]!
}

input ShopOrderCartItemInput {
  productId: ID!
  itemVariantId: ID!
  itemOptionIds: [ID!]!
  quantity: Int!
}

input ParkSpotFilterInput {
  point: PointInput!
  vehicleType: ParkSpotVehicleType
  fromTime: DateTime
  toTime: DateTime
  maximumDistance: Int!
  minimumRating: Int!
  facilities: [ParkSpotFacility!]!
  parkingType: ParkSpotType
}

union AdminNotificationUnion = TaxiSupportRequestNotification | ShopSupportRequestNotification | ParkingSupportRequestNotification | DriverPendingVerificationNotification | ShopPendingVerificationNotification | ParkSpotPendingVerificationNotification | ShopReviewPendingApprovalNotification | ParkingReviewPendingApprovalNotification

type TaxiSupportRequestNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  taxiSupportRequest: TaxiSupportRequest!
}

"""The type of admin notification."""
enum AdminNotificationType {
  UserPendingVerification
  SupportRequestSubmitted
  SupportRequestAssigned
  ReviewPendingApproval
}

type ShopSupportRequestNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  shopSupportRequest: ShopSupportRequest!
}

type ParkingSupportRequestNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  parkingSupportRequest: ParkingSupportRequest!
}

type DriverPendingVerificationNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  driverPendingVerification: Driver!
}

type ShopPendingVerificationNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  shopPendingVerification: Shop!
}

type ParkSpotPendingVerificationNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  parkSpotPendingVerification: ParkSpot!
}

type ShopReviewPendingApprovalNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  shopReviewPendingApproval: ShopFeedback!
}

type ParkingReviewPendingApprovalNotification {
  id: ID!
  type: AdminNotificationType!
  appType: AppType!
  createdAt: DateTime!
  readAt: DateTime
  parkingReviewPendingApproval: ParkingFeedback!
}

input ServiceCategoryFilter {
  and: [ServiceCategoryFilter!]
  or: [ServiceCategoryFilter!]
  id: IDFilterComparison
}

input ServiceCategorySort {
  field: ServiceCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceCategorySortFields {
  id
}

input OperatorRoleFilter {
  and: [OperatorRoleFilter!]
  or: [OperatorRoleFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
}

input OperatorRoleSort {
  field: OperatorRoleSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OperatorRoleSortFields {
  id
  title
}

input OperatorFilter {
  and: [OperatorFilter!]
  or: [OperatorFilter!]
  id: IDFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  userName: StringFieldComparison
  mobileNumber: StringFieldComparison
  isBlocked: BooleanFieldComparison
  email: StringFieldComparison
  roleId: IDFilterComparison
}

input OperatorSort {
  field: OperatorSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OperatorSortFields {
  id
  firstName
  lastName
  userName
  mobileNumber
  isBlocked
  email
  roleId
}

input RiderAggregateFilter {
  and: [RiderAggregateFilter!]
  or: [RiderAggregateFilter!]
  id: IDFilterComparison
  status: RiderStatusFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  gender: GenderFilterComparison
}

input RiderStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: RiderStatus
  neq: RiderStatus
  gt: RiderStatus
  gte: RiderStatus
  lt: RiderStatus
  lte: RiderStatus
  like: RiderStatus
  notLike: RiderStatus
  iLike: RiderStatus
  notILike: RiderStatus
  in: [RiderStatus!]
  notIn: [RiderStatus!]
}

input RiderFilter {
  and: [RiderFilter!]
  or: [RiderFilter!]
  id: IDFilterComparison
  status: RiderStatusFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  mobileNumber: StringFieldComparison
  gender: GenderFilterComparison
}

input RiderSort {
  field: RiderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RiderSortFields {
  id
  status
  firstName
  lastName
  mobileNumber
  gender
}

input SavedPaymentMethodFilter {
  and: [SavedPaymentMethodFilter!]
  or: [SavedPaymentMethodFilter!]
  id: IDFilterComparison
  isEnabled: BooleanFieldComparison
  riderId: IDFilterComparison
  driverId: IDFilterComparison
}

input SavedPaymentMethodSort {
  field: SavedPaymentMethodSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SavedPaymentMethodSortFields {
  id
  isEnabled
  riderId
  driverId
}

input CustomerNoteFilter {
  and: [CustomerNoteFilter!]
  or: [CustomerNoteFilter!]
  id: IDFilterComparison
  customerId: IDFilterComparison!
}

input CustomerNoteSort {
  field: CustomerNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CustomerNoteSortFields {
  id
  customerId
}

input CustomerSessionFilter {
  and: [CustomerSessionFilter!]
  or: [CustomerSessionFilter!]
  id: IDFilterComparison
  customerId: IDFilterComparison
}

input CustomerSessionSort {
  field: CustomerSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CustomerSessionSortFields {
  id
  customerId
}

input ChartFilterInput {
  startDate: DateTime!
  endDate: DateTime!
  interval: ChartInterval!
}

enum ChartInterval {
  Daily
  Monthly
  Quarterly
  Yearly
}

input ShopDateRangePairInput {
  shopId: ID!
  startDate: DateTime!
  endDate: DateTime!
}

input DriverNoteFilter {
  and: [DriverNoteFilter!]
  or: [DriverNoteFilter!]
  id: IDFilterComparison
  driverId: IDFilterComparison!
}

input DriverNoteSort {
  field: DriverNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverNoteSortFields {
  id
  driverId
}

input DriverDocumentFilter {
  and: [DriverDocumentFilter!]
  or: [DriverDocumentFilter!]
  id: IDFilterComparison
}

input DriverDocumentSort {
  field: DriverDocumentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverDocumentSortFields {
  id
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input DriverShiftRuleFilter {
  and: [DriverShiftRuleFilter!]
  or: [DriverShiftRuleFilter!]
  id: IDFilterComparison
}

input DriverShiftRuleSort {
  field: DriverShiftRuleSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DriverShiftRuleSortFields {
  id
}

input FleetWalletAggregateFilter {
  and: [FleetWalletAggregateFilter!]
  or: [FleetWalletAggregateFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
  fleetId: IDFilterComparison
}

input FleetStaffFilter {
  and: [FleetStaffFilter!]
  or: [FleetStaffFilter!]
  id: IDFilterComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  isBlocked: BooleanFieldComparison
  userName: StringFieldComparison
  fleetId: IDFilterComparison
}

input FleetStaffSort {
  field: FleetStaffSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetStaffSortFields {
  id
  firstName
  lastName
  isBlocked
  userName
  fleetId
}

input FleetStaffSessionFilter {
  and: [FleetStaffSessionFilter!]
  or: [FleetStaffSessionFilter!]
  id: IDFilterComparison
  fleetStaffId: IDFilterComparison
}

input FleetStaffSessionSort {
  field: FleetStaffSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FleetStaffSessionSortFields {
  id
  fleetStaffId
}

input OrderCancelReasonFilter {
  and: [OrderCancelReasonFilter!]
  or: [OrderCancelReasonFilter!]
  id: IDFilterComparison
}

input OrderCancelReasonSort {
  field: OrderCancelReasonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderCancelReasonSortFields {
  id
}

input TaxiOrderNoteFilter {
  and: [TaxiOrderNoteFilter!]
  or: [TaxiOrderNoteFilter!]
  id: IDFilterComparison
  orderId: IDFilterComparison!
}

input TaxiOrderNoteSort {
  field: TaxiOrderNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxiOrderNoteSortFields {
  id
  orderId
}

input AnnouncementFilter {
  and: [AnnouncementFilter!]
  or: [AnnouncementFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
  description: StringFieldComparison
  appType: AppTypeFilterComparison
}

input AnnouncementSort {
  field: AnnouncementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AnnouncementSortFields {
  id
  title
  description
  appType
}

input CouponFilter {
  and: [CouponFilter!]
  or: [CouponFilter!]
  id: IDFilterComparison
}

input CouponSort {
  field: CouponSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CouponSortFields {
  id
}

input CampaignFilter {
  and: [CampaignFilter!]
  or: [CampaignFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
}

input CampaignSort {
  field: CampaignSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CampaignSortFields {
  id
  name
}

input GiftBatchFilter {
  and: [GiftBatchFilter!]
  or: [GiftBatchFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  currency: StringFieldComparison
}

input GiftBatchSort {
  field: GiftBatchSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum GiftBatchSortFields {
  id
  name
  currency
}

input ProviderWalletFilter {
  and: [ProviderWalletFilter!]
  or: [ProviderWalletFilter!]
  id: IDFilterComparison
  balance: FloatFieldComparison
  currency: StringFieldComparison
}

input ProviderWalletSort {
  field: ProviderWalletSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProviderWalletSortFields {
  id
  balance
  currency
}

input RegionCategoryAggregateFilter {
  and: [RegionCategoryAggregateFilter!]
  or: [RegionCategoryAggregateFilter!]
  id: IDFilterComparison
}

input RegionCategoryFilter {
  and: [RegionCategoryFilter!]
  or: [RegionCategoryFilter!]
  id: IDFilterComparison
}

input RegionCategorySort {
  field: RegionCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RegionCategorySortFields {
  id
}

input PaymentGatewayFilter {
  and: [PaymentGatewayFilter!]
  or: [PaymentGatewayFilter!]
  id: IDFilterComparison
  enabled: BooleanFieldComparison
  title: StringFieldComparison
  type: PaymentGatewayTypeFilterComparison
}

input PaymentGatewayTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PaymentGatewayType
  neq: PaymentGatewayType
  gt: PaymentGatewayType
  gte: PaymentGatewayType
  lt: PaymentGatewayType
  lte: PaymentGatewayType
  like: PaymentGatewayType
  notLike: PaymentGatewayType
  iLike: PaymentGatewayType
  notILike: PaymentGatewayType
  in: [PaymentGatewayType!]
  notIn: [PaymentGatewayType!]
}

input PaymentGatewaySort {
  field: PaymentGatewaySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PaymentGatewaySortFields {
  id
  enabled
  title
  type
}

input CarModelFilter {
  and: [CarModelFilter!]
  or: [CarModelFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
}

input CarModelSort {
  field: CarModelSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CarModelSortFields {
  id
  name
}

input CarColorFilter {
  and: [CarColorFilter!]
  or: [CarColorFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
}

input CarColorSort {
  field: CarColorSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CarColorSortFields {
  id
  name
}

input AddressFilter {
  and: [AddressFilter!]
  or: [AddressFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input AddressSort {
  field: AddressSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AddressSortFields {
  id
  riderId
}

input TaxiPayoutSessionFilter {
  and: [TaxiPayoutSessionFilter!]
  or: [TaxiPayoutSessionFilter!]
  id: IDFilterComparison
  status: PayoutSessionStatusFilterComparison
  totalAmount: NumberFieldComparison
  currency: StringFieldComparison
}

input PayoutSessionStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PayoutSessionStatus
  neq: PayoutSessionStatus
  gt: PayoutSessionStatus
  gte: PayoutSessionStatus
  lt: PayoutSessionStatus
  lte: PayoutSessionStatus
  like: PayoutSessionStatus
  notLike: PayoutSessionStatus
  iLike: PayoutSessionStatus
  notILike: PayoutSessionStatus
  in: [PayoutSessionStatus!]
  notIn: [PayoutSessionStatus!]
}

input TaxiPayoutSessionSort {
  field: TaxiPayoutSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxiPayoutSessionSortFields {
  id
  status
  totalAmount
  currency
}

input ShopPayoutSessionFilter {
  and: [ShopPayoutSessionFilter!]
  or: [ShopPayoutSessionFilter!]
  id: IDFilterComparison
  status: PayoutSessionStatusFilterComparison
  totalAmount: NumberFieldComparison
  currency: StringFieldComparison
}

input ShopPayoutSessionSort {
  field: ShopPayoutSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopPayoutSessionSortFields {
  id
  status
  totalAmount
  currency
}

input ParkingPayoutSessionFilter {
  and: [ParkingPayoutSessionFilter!]
  or: [ParkingPayoutSessionFilter!]
  id: IDFilterComparison
  status: PayoutSessionStatusFilterComparison
  totalAmount: NumberFieldComparison
  currency: StringFieldComparison
}

input ParkingPayoutSessionSort {
  field: ParkingPayoutSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingPayoutSessionSortFields {
  id
  status
  totalAmount
  currency
}

input SOSReasonFilter {
  and: [SOSReasonFilter!]
  or: [SOSReasonFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  isActive: BooleanFieldComparison
}

input SOSReasonSort {
  field: SOSReasonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SOSReasonSortFields {
  id
  name
  isActive
}

input RewardFilter {
  and: [RewardFilter!]
  or: [RewardFilter!]
  id: IDFilterComparison
}

input RewardSort {
  field: RewardSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RewardSortFields {
  id
}

input ShopSupportRequestAggregateFilter {
  and: [ShopSupportRequestAggregateFilter!]
  or: [ShopSupportRequestAggregateFilter!]
  id: IDFilterComparison
  requestedByShop: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  orderId: IDFilterComparison
  cartId: IDFilterComparison
  order: ShopSupportRequestAggregateFilterShopOrderAggregateFilter
}

input ShopSupportRequestAggregateFilterShopOrderAggregateFilter {
  and: [ShopSupportRequestAggregateFilterShopOrderAggregateFilter!]
  or: [ShopSupportRequestAggregateFilterShopOrderAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
}

input ShopSupportRequestFilter {
  and: [ShopSupportRequestFilter!]
  or: [ShopSupportRequestFilter!]
  id: IDFilterComparison
  requestedByShop: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  orderId: IDFilterComparison
  cartId: IDFilterComparison
  order: ShopSupportRequestFilterShopOrderFilter
}

input ShopSupportRequestFilterShopOrderFilter {
  and: [ShopSupportRequestFilterShopOrderFilter!]
  or: [ShopSupportRequestFilterShopOrderFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
}

input ShopSupportRequestSort {
  field: ShopSupportRequestSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopSupportRequestSortFields {
  id
  requestedByShop
  status
  orderId
  cartId
}

input ShopAggregateFilter {
  and: [ShopAggregateFilter!]
  or: [ShopAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopStatusFilterComparison
  ratingAggregate: ShopAggregateFilterRatingAggregateAggregateFilter
  categories: ShopAggregateFilterShopCategoryAggregateFilter
  itemPresets: ShopAggregateFilterShopItemPresetAggregateFilter
}

input ShopAggregateFilterRatingAggregateAggregateFilter {
  and: [ShopAggregateFilterRatingAggregateAggregateFilter!]
  or: [ShopAggregateFilterRatingAggregateAggregateFilter!]
  rating: IntFieldComparison
}

input ShopAggregateFilterShopCategoryAggregateFilter {
  and: [ShopAggregateFilterShopCategoryAggregateFilter!]
  or: [ShopAggregateFilterShopCategoryAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  status: ShopCategoryStatusFilterComparison
}

input ShopAggregateFilterShopItemPresetAggregateFilter {
  and: [ShopAggregateFilterShopItemPresetAggregateFilter!]
  or: [ShopAggregateFilterShopItemPresetAggregateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  shopId: IDFilterComparison
}

input ShopLoginSessionFilter {
  and: [ShopLoginSessionFilter!]
  or: [ShopLoginSessionFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
}

input ShopLoginSessionSort {
  field: ShopLoginSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopLoginSessionSortFields {
  id
  shopId
}

input ShopOrderNoteFilter {
  and: [ShopOrderNoteFilter!]
  or: [ShopOrderNoteFilter!]
  id: IDFilterComparison
  orderId: IDFilterComparison!
}

input ShopOrderNoteSort {
  field: ShopOrderNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopOrderNoteSortFields {
  id
  orderId
}

input ShopNoteFilter {
  and: [ShopNoteFilter!]
  or: [ShopNoteFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison!
}

input ShopNoteSort {
  field: ShopNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopNoteSortFields {
  id
  shopId
}

input ShopDeliveryZoneFilter {
  and: [ShopDeliveryZoneFilter!]
  or: [ShopDeliveryZoneFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
  name: StringFieldComparison
  deliveryFee: NumberFieldComparison
  enabled: BooleanFieldComparison
}

input ShopDeliveryZoneSort {
  field: ShopDeliveryZoneSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopDeliveryZoneSortFields {
  id
  shopId
  name
  deliveryFee
  enabled
}

input ShopOrderAggregateFilter {
  and: [ShopOrderAggregateFilter!]
  or: [ShopOrderAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
  carts: ShopOrderAggregateFilterShopOrderCartAggregateFilter
}

input ShopOrderAggregateFilterShopOrderCartAggregateFilter {
  and: [ShopOrderAggregateFilterShopOrderCartAggregateFilter!]
  or: [ShopOrderAggregateFilterShopOrderCartAggregateFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
}

input ShopOrderFilter {
  and: [ShopOrderFilter!]
  or: [ShopOrderFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  status: ShopOrderStatusFilterComparison
  currency: StringFieldComparison
  deliveryMethod: DeliveryMethodFilterComparison
  paymentMethod: PaymentModeFilterComparison
  customerId: IDFilterComparison
  total: FloatFieldComparison
  carts: ShopOrderFilterShopOrderCartFilter
}

input ShopOrderFilterShopOrderCartFilter {
  and: [ShopOrderFilterShopOrderCartFilter!]
  or: [ShopOrderFilterShopOrderCartFilter!]
  id: IDFilterComparison
  shopId: IDFilterComparison
}

input ShopOrderSort {
  field: ShopOrderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ShopOrderSortFields {
  id
  createdAt
  status
  currency
  deliveryMethod
  paymentMethod
  customerId
  total
}

input ParkingSupportRequestAggregateFilter {
  and: [ParkingSupportRequestAggregateFilter!]
  or: [ParkingSupportRequestAggregateFilter!]
  id: IDFilterComparison
  requestedByOwner: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  parkOrderId: IDFilterComparison
  parkOrder: ParkingSupportRequestAggregateFilterParkOrderAggregateFilter
}

input ParkingSupportRequestAggregateFilterParkOrderAggregateFilter {
  and: [ParkingSupportRequestAggregateFilterParkOrderAggregateFilter!]
  or: [ParkingSupportRequestAggregateFilterParkOrderAggregateFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input ParkingSupportRequestFilter {
  and: [ParkingSupportRequestFilter!]
  or: [ParkingSupportRequestFilter!]
  id: IDFilterComparison
  requestedByOwner: BooleanFieldComparison
  status: ComplaintStatusFilterComparison
  parkOrderId: IDFilterComparison
  parkOrder: ParkingSupportRequestFilterParkOrderFilter
}

input ParkingSupportRequestFilterParkOrderFilter {
  and: [ParkingSupportRequestFilterParkOrderFilter!]
  or: [ParkingSupportRequestFilterParkOrderFilter!]
  id: IDFilterComparison
  enterTime: DateFieldComparison
  exitTime: DateFieldComparison
  vehicleType: ParkSpotVehicleTypeFilterComparison
  carSize: ParkSpotCarSizeFilterComparison
  paymentMethod: PaymentModeFilterComparison
  parkSpotId: IDFilterComparison
  price: FloatFieldComparison
  currency: StringFieldComparison
  status: ParkOrderStatusFilterComparison
  carOwnerId: IDFilterComparison
}

input ParkingSupportRequestSort {
  field: ParkingSupportRequestSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingSupportRequestSortFields {
  id
  requestedByOwner
  status
  parkOrderId
}

input ParkSpotAggregateFilter {
  and: [ParkSpotAggregateFilter!]
  or: [ParkSpotAggregateFilter!]
  id: IDFilterComparison
  status: ParkSpotStatusFilterComparison
  type: ParkSpotTypeFilterComparison
  name: StringFieldComparison
  address: StringFieldComparison
  ratingAggregate: ParkSpotAggregateFilterRatingAggregateAggregateFilter
  carSize: ParkSpotCarSizeFilterComparison
}

input ParkSpotStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkSpotStatus
  neq: ParkSpotStatus
  gt: ParkSpotStatus
  gte: ParkSpotStatus
  lt: ParkSpotStatus
  lte: ParkSpotStatus
  like: ParkSpotStatus
  notLike: ParkSpotStatus
  iLike: ParkSpotStatus
  notILike: ParkSpotStatus
  in: [ParkSpotStatus!]
  notIn: [ParkSpotStatus!]
}

input ParkSpotTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ParkSpotType
  neq: ParkSpotType
  gt: ParkSpotType
  gte: ParkSpotType
  lt: ParkSpotType
  lte: ParkSpotType
  like: ParkSpotType
  notLike: ParkSpotType
  iLike: ParkSpotType
  notILike: ParkSpotType
  in: [ParkSpotType!]
  notIn: [ParkSpotType!]
}

input ParkSpotAggregateFilterRatingAggregateAggregateFilter {
  and: [ParkSpotAggregateFilterRatingAggregateAggregateFilter!]
  or: [ParkSpotAggregateFilterRatingAggregateAggregateFilter!]
  rating: IntFieldComparison
}

input ParkSpotFilter {
  and: [ParkSpotFilter!]
  or: [ParkSpotFilter!]
  id: IDFilterComparison
  status: ParkSpotStatusFilterComparison
  type: ParkSpotTypeFilterComparison
  name: StringFieldComparison
  address: StringFieldComparison
  ratingAggregate: ParkSpotFilterRatingAggregateFilter
  carSize: ParkSpotCarSizeFilterComparison
}

input ParkSpotFilterRatingAggregateFilter {
  and: [ParkSpotFilterRatingAggregateFilter!]
  or: [ParkSpotFilterRatingAggregateFilter!]
  rating: IntFieldComparison
}

input ParkSpotSort {
  field: ParkSpotSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkSpotSortFields {
  id
  status
  type
  name
  address
  ratingAggregate
  carSize
}

input ParkingLoginSessionFilter {
  and: [ParkingLoginSessionFilter!]
  or: [ParkingLoginSessionFilter!]
  id: IDFilterComparison
  customerId: IDFilterComparison
}

input ParkingLoginSessionSort {
  field: ParkingLoginSessionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkingLoginSessionSortFields {
  id
  customerId
}

input ParkSpotNoteFilter {
  and: [ParkSpotNoteFilter!]
  or: [ParkSpotNoteFilter!]
  id: IDFilterComparison
  parkSpotId: IDFilterComparison
}

input ParkSpotNoteSort {
  field: ParkSpotNoteSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ParkSpotNoteSortFields {
  id
  parkSpotId
}

input SMSProviderFilter {
  and: [SMSProviderFilter!]
  or: [SMSProviderFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  type: SMSProviderTypeFilterComparison
}

input SMSProviderTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SMSProviderType
  neq: SMSProviderType
  gt: SMSProviderType
  gte: SMSProviderType
  lt: SMSProviderType
  lte: SMSProviderType
  like: SMSProviderType
  notLike: SMSProviderType
  iLike: SMSProviderType
  notILike: SMSProviderType
  in: [SMSProviderType!]
  notIn: [SMSProviderType!]
}

input SMSProviderSort {
  field: SMSProviderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SMSProviderSortFields {
  id
  name
  type
}

input ZonePriceCategoryFilter {
  and: [ZonePriceCategoryFilter!]
  or: [ZonePriceCategoryFilter!]
  id: IDFilterComparison
}

input ZonePriceCategorySort {
  field: ZonePriceCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ZonePriceCategorySortFields {
  id
}

type Mutation {
  updatePassword(input: UpdatePasswordInput!): Operator!
  terminateStaffSession(id: ID!): Boolean!
  updateProfile(input: UpdateProfileInput!): Operator!
  createRiderTransaction(input: RiderTransactionInput!): RiderWallet!
  deleteOneRider(id: ID!): Rider!
  terminateCustomerLoginSession(sessionId: ID!): Boolean!
  createDriverTransaction(input: DriverTransactionInput!): DriverWallet!
  deleteOneDriver(id: ID!): Driver!
  terminateDriverLoginSession(sessionId: ID!): Boolean!
  setActivatedServicesOnDriver(input: SetActiveServicesOnDriverInput!): Boolean!
  createFleetTransaction(input: FleetTransactionInput!): FleetWallet!
  terminateFleetStaffSession(id: ID!): Boolean!
  createOrder(input: CreateOrderInput!): Order!
  cancelOrder(orderId: ID!): Order!
  assignDriverToOrder(orderId: ID!, driverId: ID!): Order!
  createTaxiOrderNote(input: CreateTaxiOrderNoteInput!): TaxiOrderNote!
  createCampaign(input: CreateCampaignInput!): Campaign!
  createGiftCardBatch(input: CreateGiftBatchInput!): GiftBatch!
  exportGiftCardBatch(batchId: ID!): String!
  addCommentToTaxiSupportRequest(input: CreateTaxiSupportRequestCommentInput!): TaxiSupportRequestActivity!
  assignTaxiSupportRequestToStaff(input: AssignTaxiSupportRequestInput!): TaxiSupportRequestActivity!
  changeTaxiSupportRequestStatus(input: ChangeTaxiSupportRequestStatusInput!): TaxiSupportRequestActivity!
  createShopOrder(input: ShopOrderInput!): ShopOrder!
  cancelShopOrderCarts(input: CancelShopOrderCartsInput!): ShopOrder!
  removeItemFromCart(input: RemoveItemFromCartInput!): ShopOrder!
  terminateShopLoginSession(sessionId: ID!): Boolean!
  createParkingSpot(input: CreateParkSpotInput!): ParkSpot!
  terminateParkingLoginSession(sessionId: ID!): Boolean!
  updateConfigurations(input: UpdateConfigInputV2!): UpdateConfigResult!
  updatePurchaseCode(purchaseCode: String!, email: String): UpdatePurchaseCodeResult!
  updateMapsAPIKey(backend: String!, adminPanel: String!): UpdateConfigResult! @deprecated(reason: "Use updateConfigurations instead")
  updateFirebase(keyFileName: String!): UpdateConfigResult! @deprecated(reason: "Use updateConfigurations instead")
  disablePreviousServer(ip: String!, purchaseCode: String): UpdateConfigResult!
  saveConfiguration(input: UpdateConfigInput!): CurrentConfiguration! @deprecated(reason: "Use updateConfigurations instead")
  markSMSProviderAsDefault(id: ID!): SMSProvider!
  markAsRead(notificationIds: [ID!]!): Boolean!
  addRegionsToService(input: AddRegionsToServiceInput!): Service!
  setRegionsOnService(input: SetRegionsOnServiceInput!): Service!
  addOptionsToService(input: AddOptionsToServiceInput!): Service!
  setOptionsOnService(input: SetOptionsOnServiceInput!): Service!
  createOneService(input: CreateOneServiceInput!): Service!
  updateOneService(input: UpdateOneServiceInput!): Service!
  deleteOneService(input: DeleteOneServiceInput!): ServiceDeleteResponse!
  createOneServiceCategory(input: CreateOneServiceCategoryInput!): ServiceCategory!
  updateOneServiceCategory(input: UpdateOneServiceCategoryInput!): ServiceCategory!
  deleteOneServiceCategory(input: DeleteOneServiceCategoryInput!): ServiceCategoryDeleteResponse!
  createOneServiceOption(input: CreateOneServiceOptionInput!): ServiceOption!
  updateOneServiceOption(input: UpdateOneServiceOptionInput!): ServiceOption!
  deleteOneServiceOption(input: DeleteOneServiceOptionInput!): ServiceOptionDeleteResponse!
  createOneOperatorRole(input: CreateOneOperatorRoleInput!): OperatorRole!
  updateOneOperatorRole(input: UpdateOneOperatorRoleInput!): OperatorRole!
  deleteOneOperatorRole(input: DeleteOneOperatorRoleInput!): OperatorRoleDeleteResponse!
  createOneOperator(input: CreateOneOperatorInput!): Operator!
  updateOneOperator(input: UpdateOneOperatorInput!): Operator!
  deleteOneOperator(input: DeleteOneOperatorInput!): OperatorDeleteResponse!
  createOneRider(input: CreateOneRiderInput!): Rider!
  updateOneRider(input: UpdateOneRiderInput!): Rider!
  createOneRiderTransaction(input: CreateOneRiderTransactionInput!): RiderTransaction!
  createOneRiderAddress(input: CreateOneRiderAddressInput!): RiderAddress!
  updateOneRiderAddress(input: UpdateOneRiderAddressInput!): RiderAddress!
  updateManyRiderAddresses(input: UpdateManyRiderAddressesInput!): UpdateManyResponse!
  deleteOneSavedPaymentMethod(input: DeleteOneSavedPaymentMethodInput!): SavedPaymentMethodDeleteResponse!
  createOneCustomerNote(input: CreateOneCustomerNoteInput!): CustomerNote!
  deleteOneCustomerSession(input: DeleteOneCustomerSessionInput!): CustomerSessionDeleteResponse!
  createOneDriver(input: CreateOneDriverInput!): Driver!
  updateOneDriver(input: UpdateOneDriverInput!): Driver!
  createOneDriverNote(input: CreateOneDriverNoteInput!): DriverNote!
  deleteOneDriverSession(input: DeleteOneDriverSessionInput!): DriverSessionDeleteResponse!
  createOneDriverTransaction(input: CreateOneDriverTransactionInput!): DriverTransaction!
  createOneDriverDocument(input: CreateOneDriverDocumentInput!): DriverDocument!
  createManyDriverDocuments(input: CreateManyDriverDocumentsInput!): [DriverDocument!]!
  updateOneDriverDocument(input: UpdateOneDriverDocumentInput!): DriverDocument!
  updateManyDriverDocuments(input: UpdateManyDriverDocumentsInput!): UpdateManyResponse!
  deleteOneDriverDocument(input: DeleteOneDriverDocumentInput!): DriverDocumentDeleteResponse!
  deleteManyDriverDocuments(input: DeleteManyDriverDocumentsInput!): DeleteManyResponse!
  createOneDriverDocumentRetentionPolicy(input: CreateOneDriverDocumentRetentionPolicyInput!): DriverDocumentRetentionPolicy!
  createManyDriverDocumentRetentionPolicies(input: CreateManyDriverDocumentRetentionPoliciesInput!): [DriverDocumentRetentionPolicy!]!
  updateOneDriverDocumentRetentionPolicy(input: UpdateOneDriverDocumentRetentionPolicyInput!): DriverDocumentRetentionPolicy!
  updateManyDriverDocumentRetentionPolicies(input: UpdateManyDriverDocumentRetentionPoliciesInput!): UpdateManyResponse!
  deleteOneDriverDocumentRetentionPolicy(input: DeleteOneDriverDocumentRetentionPolicyInput!): DriverDocumentRetentionPolicyDeleteResponse!
  deleteManyDriverDocumentRetentionPolicies(input: DeleteManyDriverDocumentRetentionPoliciesInput!): DeleteManyResponse!
  createOneDriverToDriverDocument(input: CreateOneDriverToDriverDocumentInput!): DriverToDriverDocument!
  updateOneDriverToDriverDocument(input: UpdateOneDriverToDriverDocumentInput!): DriverToDriverDocument!
  deleteOneDriverToDriverDocument(input: DeleteOneDriverToDriverDocumentInput!): DriverToDriverDocumentDeleteResponse!
  createOneDriverShiftRule(input: CreateOneDriverShiftRuleInput!): DriverShiftRule!
  createManyDriverShiftRules(input: CreateManyDriverShiftRulesInput!): [DriverShiftRule!]!
  updateOneDriverShiftRule(input: UpdateOneDriverShiftRuleInput!): DriverShiftRule!
  updateManyDriverShiftRules(input: UpdateManyDriverShiftRulesInput!): UpdateManyResponse!
  deleteOneDriverShiftRule(input: DeleteOneDriverShiftRuleInput!): DriverShiftRuleDeleteResponse!
  deleteManyDriverShiftRules(input: DeleteManyDriverShiftRulesInput!): DeleteManyResponse!
  createOneFleet(input: CreateOneFleetInput!): Fleet!
  updateOneFleet(input: UpdateOneFleetInput!): Fleet!
  deleteOneFleet(input: DeleteOneFleetInput!): FleetDeleteResponse!
  createOneFleetStaff(input: CreateOneFleetStaffInput!): FleetStaff!
  updateOneFleetStaff(input: UpdateOneFleetStaffInput!): FleetStaff!
  deleteOneFleetStaff(input: DeleteOneFleetStaffInput!): FleetStaffDeleteResponse!
  createOneOrderCancelReason(input: CreateOneOrderCancelReasonInput!): OrderCancelReason!
  updateOneOrderCancelReason(input: UpdateOneOrderCancelReasonInput!): OrderCancelReason!
  deleteOneOrderCancelReason(input: DeleteOneOrderCancelReasonInput!): OrderCancelReasonDeleteResponse!
  createOneAnnouncement(input: CreateOneAnnouncementInput!): Announcement!
  updateOneAnnouncement(input: UpdateOneAnnouncementInput!): Announcement!
  deleteOneAnnouncement(input: DeleteOneAnnouncementInput!): AnnouncementDeleteResponse!
  createOneCoupon(input: CreateOneCouponInput!): Coupon!
  updateOneCoupon(input: UpdateOneCouponInput!): Coupon!
  deleteOneCoupon(input: DeleteOneCouponInput!): CouponDeleteResponse!
  deleteOneCampaign(input: DeleteOneCampaignInput!): CampaignDeleteResponse!
  createOneProviderTransaction(input: CreateOneProviderTransactionInput!): ProviderTransaction!
  createOneRegion(input: CreateOneRegionInput!): Region!
  updateOneRegion(input: UpdateOneRegionInput!): Region!
  deleteOneRegion(input: DeleteOneRegionInput!): RegionDeleteResponse!
  createOneRegionCategory(input: CreateOneRegionCategoryInput!): RegionCategory!
  updateOneRegionCategory(input: UpdateOneRegionCategoryInput!): RegionCategory!
  deleteOneRegionCategory(input: DeleteOneRegionCategoryInput!): RegionCategoryDeleteResponse!
  createOnePaymentGateway(input: CreateOnePaymentGatewayInput!): PaymentGateway!
  updateOnePaymentGateway(input: UpdateOnePaymentGatewayInput!): PaymentGateway!
  deleteOnePaymentGateway(input: DeleteOnePaymentGatewayInput!): PaymentGatewayDeleteResponse!
  createOneCarModel(input: CreateOneCarModelInput!): CarModel!
  updateOneCarModel(input: UpdateOneCarModelInput!): CarModel!
  deleteOneCarModel(input: DeleteOneCarModelInput!): CarModelDeleteResponse!
  createOneCarColor(input: CreateOneCarColorInput!): CarColor!
  updateOneCarColor(input: UpdateOneCarColorInput!): CarColor!
  deleteOneCarColor(input: DeleteOneCarColorInput!): CarColorDeleteResponse!
  updateOneFeedback(input: UpdateOneFeedbackInput!): Feedback!
  createOneFeedbackParameter(input: CreateOneFeedbackParameterInput!): FeedbackParameter!
  updateOneFeedbackParameter(input: UpdateOneFeedbackParameterInput!): FeedbackParameter!
  deleteOneFeedbackParameter(input: DeleteOneFeedbackParameterInput!): FeedbackParameterDeleteResponse!
  taxiManualPayout(input: ManualPayoutInput!): DriverTransaction!
  createTaxiPayoutSession(input: CreatePayoutSessionInput!): TaxiPayoutSession!
  exportTaxiPayoutSessionToCsv(input: ExportSessionToCsvInput!): String!
  runTaxiAutoPayout(input: RunAutoPayoutInput!): Boolean!
  updateOneTaxiPayoutSession(input: UpdateOneTaxiPayoutSessionInput!): TaxiPayoutSession!
  createShopPayoutSession(input: CreatePayoutSessionInput!): ShopPayoutSession!
  exportShopPayoutSessionToCsv(input: ExportSessionToCsvInput!): String!
  runShopAutoPayout(input: RunAutoPayoutInput!): Boolean!
  updateOneShopPayoutSession(input: UpdateOneShopPayoutSessionInput!): ShopPayoutSession!
  createParkingPayoutSession(input: CreatePayoutSessionInput!): ParkingPayoutSession!
  exportParkingPayoutSessionToCsv(input: ExportSessionToCsvInput!): String!
  runParkingAutoPayout(input: RunAutoPayoutInput!): Boolean!
  updateOneParkingPayoutSession(input: UpdateOneParkingPayoutSessionInput!): ParkingPayoutSession!
  createOnePayoutMethod(input: CreateOnePayoutMethodInput!): PayoutMethod!
  updateOnePayoutMethod(input: UpdateOnePayoutMethodInput!): PayoutMethod!
  deleteOnePayoutMethod(input: DeleteOnePayoutMethodInput!): PayoutMethodDeleteResponse!
  updateOneDistressSignal(input: UpdateOneDistressSignalInput!): DistressSignal!
  createOneSOSActivity(input: CreateOneSOSActivityInput!): SOSActivity!
  createOneSOSReason(input: CreateOneSOSReasonInput!): SOSReason!
  updateOneSOSReason(input: UpdateOneSOSReasonInput!): SOSReason!
  deleteOneSOSReason(input: DeleteOneSOSReasonInput!): SOSReasonDeleteResponse!
  createOneReward(input: CreateOneRewardInput!): Reward!
  updateOneReward(input: UpdateOneRewardInput!): Reward!
  deleteOneReward(input: DeleteOneRewardInput!): RewardDeleteResponse!
  updateOneTaxiSupportRequest(input: UpdateOneTaxiSupportRequestInput!): TaxiSupportRequest!
  createOneTaxiSupportRequestActivity(input: CreateOneTaxiSupportRequestActivityInput!): TaxiSupportRequestActivity!
  addCommentToShopSupportRequest(input: CreateShopSupportRequestCommentInput!): ShopSupportRequestActivity!
  assignShopSupportRequestToStaff(input: AssignShopSupportRequestInput!): ShopSupportRequestActivity!
  changeShopSupportRequestStatus(input: ChangeShopSupportRequestStatusInput!): ShopSupportRequestActivity!
  updateOneShopSupportRequest(input: UpdateOneShopSupportRequestInput!): ShopSupportRequest!
  createOneShopSupportRequestActivity(input: CreateOneShopSupportRequestActivityInput!): ShopSupportRequestActivity!
  updateShopFeedbackStatus(feedbackId: ID!, status: ReviewStatus!): ShopFeedback!
  updateOneShopFeedback(input: UpdateOneShopFeedbackInput!): ShopFeedback!
  createOneShopFeedbackParameter(input: CreateOneShopFeedbackParameterInput!): ShopFeedbackParameter!
  updateOneShopFeedbackParameter(input: UpdateOneShopFeedbackParameterInput!): ShopFeedbackParameter!
  deleteOneShopFeedbackParameter(input: DeleteOneShopFeedbackParameterInput!): ShopFeedbackParameterDeleteResponse!
  createOneShopCategory(input: CreateOneShopCategoryInput!): ShopCategory!
  updateOneShopCategory(input: UpdateOneShopCategoryInput!): ShopCategory!
  deleteOneShopCategory(input: DeleteOneShopCategoryInput!): ShopCategoryDeleteResponse!
  createOneShop(input: CreateOneShopInput!): Shop!
  updateOneShop(input: UpdateOneShopInput!): Shop!
  deleteOneShop(input: DeleteOneShopInput!): ShopDeleteResponse!
  createOneShopOrderNote(input: CreateOneShopOrderNoteInput!): ShopOrderNote!
  createOneShopNote(input: CreateOneShopNoteInput!): ShopNote!
  createOneShopItemPreset(input: CreateOneShopItemPresetInput!): ShopItemPreset!
  updateOneShopItemPreset(input: UpdateOneShopItemPresetInput!): ShopItemPreset!
  deleteOneShopItemPreset(input: DeleteOneShopItemPresetInput!): ShopItemPresetDeleteResponse!
  createOneItemCategory(input: CreateOneItemCategoryInput!): ItemCategory!
  updateOneItemCategory(input: UpdateOneItemCategoryInput!): ItemCategory!
  deleteOneItemCategory(input: DeleteOneItemCategoryInput!): ItemCategoryDeleteResponse!
  createOneItem(input: CreateOneItemInput!): Item!
  updateOneItem(input: UpdateOneItemInput!): Item!
  deleteOneItem(input: DeleteOneItemInput!): ItemDeleteResponse!
  createOneShopTransaction(input: CreateOneShopTransactionInput!): ShopTransaction!
  createOneShopDeliveryZone(input: CreateOneShopDeliveryZoneInput!): ShopDeliveryZone!
  updateOneShopDeliveryZone(input: UpdateOneShopDeliveryZoneInput!): ShopDeliveryZone!
  deleteOneShopDeliveryZone(input: DeleteOneShopDeliveryZoneInput!): ShopDeliveryZoneDeleteResponse!
  updateParkingFeedbackStatus(feedbackId: ID!, status: ReviewStatus!): ParkingFeedback!
  updateOneParkingFeedback(input: UpdateOneParkingFeedbackInput!): ParkingFeedback!
  createOneParkingFeedbackParameter(input: CreateOneParkingFeedbackParameterInput!): ParkingFeedbackParameter!
  updateOneParkingFeedbackParameter(input: UpdateOneParkingFeedbackParameterInput!): ParkingFeedbackParameter!
  deleteOneParkingFeedbackParameter(input: DeleteOneParkingFeedbackParameterInput!): ParkingFeedbackParameterDeleteResponse!
  addCommentToParkingSupportRequest(input: CreateParkingSupportRequestCommentInput!): ParkingSupportRequestActivity!
  assignParkingSupportRequestToStaff(input: AssignParkingSupportRequestInput!): ParkingSupportRequestActivity!
  changeParkingSupportRequestStatus(input: ChangeParkingSupportRequestStatusInput!): ParkingSupportRequestActivity!
  updateOneParkingSupportRequest(input: UpdateOneParkingSupportRequestInput!): ParkingSupportRequest!
  createOneParkingSupportRequestActivity(input: CreateOneParkingSupportRequestActivityInput!): ParkingSupportRequestActivity!
  updateOneParkSpot(input: UpdateOneParkSpotInput!): ParkSpot!
  createOneParkOrder(input: CreateOneParkOrderInput!): ParkOrder!
  createOneParkOrderNote(input: CreateOneParkOrderNoteInput!): ParkOrderNote!
  createOneParkSpotNote(input: CreateOneParkSpotNoteInput!): ParkSpotNote!
  createOneParkingTransaction(input: CreateOneParkingTransactionInput!): ParkingTransaction!
  createOneSMSProvider(input: CreateOneSMSProviderInput!): SMSProvider!
  createManySMSProviders(input: CreateManySMSProvidersInput!): [SMSProvider!]!
  updateOneSMSProvider(input: UpdateOneSMSProviderInput!): SMSProvider!
  updateManySMSProviders(input: UpdateManySMSProvidersInput!): UpdateManyResponse!
  deleteOneSMSProvider(input: DeleteOneSMSProviderInput!): SMSProviderDeleteResponse!
  deleteManySMSProviders(input: DeleteManySMSProvidersInput!): DeleteManyResponse!
  createOneSMS(input: CreateOneSMSInput!): SMS!
  createManySMS(input: CreateManySMSInput!): [SMS!]!
  updateOneSMS(input: UpdateOneSMSInput!): SMS!
  updateManySMS(input: UpdateManySMSInput!): UpdateManyResponse!
  deleteOneSMS(input: DeleteOneSMSInput!): SMSDeleteResponse!
  deleteManySMS(input: DeleteManySMSInput!): DeleteManyResponse!
  addFleetsToZonePrice(input: AddFleetsToZonePriceInput!): ZonePrice!
  setFleetsOnZonePrice(input: SetFleetsOnZonePriceInput!): ZonePrice!
  addServicesToZonePrice(input: AddServicesToZonePriceInput!): ZonePrice!
  setServicesOnZonePrice(input: SetServicesOnZonePriceInput!): ZonePrice!
  createOneZonePrice(input: CreateOneZonePriceInput!): ZonePrice!
  updateOneZonePrice(input: UpdateOneZonePriceInput!): ZonePrice!
  deleteOneZonePrice(input: DeleteOneZonePriceInput!): ZonePriceDeleteResponse!
  createOneZonePriceCategory(input: CreateOneZonePriceCategoryInput!): ZonePriceCategory!
  updateOneZonePriceCategory(input: UpdateOneZonePriceCategoryInput!): ZonePriceCategory!
  deleteOneZonePriceCategory(input: DeleteOneZonePriceCategoryInput!): ZonePriceCategoryDeleteResponse!
}

input UpdatePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input UpdateProfileInput {
  firstName: String
  lastName: String
  email: String
  mobileNumber: String
  userName: String
  mediaId: ID
  enabledNotifications: [EnabledNotification!]
}

input RiderTransactionInput {
  action: TransactionAction!
  deductType: RiderDeductTransactionType
  rechargeType: RiderRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  riderId: ID!
}

input DriverTransactionInput {
  action: TransactionAction!
  deductType: DriverDeductTransactionType
  rechargeType: DriverRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  driverId: ID!
  description: String
}

input SetActiveServicesOnDriverInput {
  driverId: ID!
  serviceIds: [ID!]!
}

input FleetTransactionInput {
  action: TransactionAction!
  deductType: ProviderDeductTransactionType
  rechargeType: ProviderRechargeTransactionType
  amount: Float!
  currency: String!
  refrenceNumber: String
  fleetId: ID!
  description: String
}

input CreateOrderInput {
  riderId: ID!
  driverId: ID
  serviceId: ID!
  points: [PointInput!]!
  addresses: [String!]!
  waitingTimeMinutes: Int! = 0
  twoWay: Boolean! = false
  optionIds: [ID!]! = []
  intervalMinutes: Int! = 0
}

input CreateTaxiOrderNoteInput {
  orderId: ID!
  note: String!
}

input CreateCampaignInput {
  name: String!
  description: String
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  minimumCost: Float
  maximumCost: Float
  startAt: DateTime
  expireAt: DateTime
  discountPercent: Float!
  discountFlat: Float
  isFirstTravelOnly: Boolean!
  codesCount: Int!
  sendSMS: Boolean!
  smsText: String
  sendEmail: Boolean!
  emailSubject: String
  emailText: String
  sendPush: Boolean!
  pushTitle: String
  pushText: String
  sendAt: DateTime
  targetUsers: [CampaignTargetSegmentCriteria!]!
}

input CampaignTargetSegmentCriteria {
  appType: AppType!
  lastDays: Int!
  type: CampaignCriteriaOrdersType!
  value: Float!
}

enum CampaignCriteriaOrdersType {
  OrderCountMoreThan
  OrderCountLessThan
  PurchaseAmountMoreThan
  PurchaseAmountLessThan
}

input CreateGiftBatchInput {
  name: String!
  currency: String!
  amount: Float!
  availableFrom: DateTime
  expireAt: DateTime
  quantity: Int!
}

input CreateTaxiSupportRequestCommentInput {
  supportRequestId: ID!
  comment: String!
}

input AssignTaxiSupportRequestInput {
  supportRequestId: ID!
  staffIds: [ID!]!
}

input ChangeTaxiSupportRequestStatusInput {
  supportRequestId: ID!
  status: ComplaintStatus!
}

input ShopOrderInput {
  deliveryMethod: DeliveryMethod!
  deliveryAddressId: ID!
  carts: [ShopOrderCartInput!]!
}

input CancelShopOrderCartsInput {
  cartIds: [ID!]!
}

input RemoveItemFromCartInput {
  cartId: ID!
  cancelables: [RemoveItemFromCartItemQuantityPair!]!
}

input RemoveItemFromCartItemQuantityPair {
  shopOrderCartItemId: ID!
  cancelQuantity: Int!
}

input CreateParkSpotInput {
  type: ParkSpotType!
  name: String!
  location: PointInput!
  address: String
  phoneNumber: String
  email: String
  weekdaySchedule: [WeekdayScheduleInput!]!
  carSize: ParkSpotCarSize
  carPrice: Float
  carSpaces: Int!
  bikePrice: Float
  bikeSpaces: Int!
  truckPrice: Float
  truckSpaces: Int!
  description: String
  facilities: [ParkSpotFacility!]!
  ownerFirstName: String!
  ownerLastName: String!
  ownerEmail: String!
  ownerPhoneNumber: String!
  ownerGender: Gender!
  imageIds: [ID!]!
  mainImageId: ID
}

input UpdateConfigInputV2 {
  phoneNumber: String
  email: String
  firstName: String
  lastName: String
  password: String
  profilePicture: String
  adminPanelAPIKey: String
  backendMapsAPIKey: String
  companyLogo: String
  companyName: String
  taxi: AppConfigInfoInput
  shop: AppConfigInfoInput
  parking: AppConfigInfoInput
  mysqlHost: String
  mysqlPort: Int
  mysqlUser: String
  mysqlPassword: String
  mysqlDatabase: String
  redisHost: String
  redisPort: Int
  redisPassword: String
  redisDb: Int
  firebaseProjectPrivateKey: String
}

input UpdateConfigInput {
  backendMapsAPIKey: String
  adminPanelAPIKey: String
  twilioAccountSid: String
  twilioAuthToken: String
  twilioFromNumber: String
  twilioVerificationCodeSMSTemplate: String
}

input AddRegionsToServiceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetRegionsOnServiceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input AddOptionsToServiceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetOptionsOnServiceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input CreateOneServiceInput {
  """The record to create"""
  service: ServiceInput!
}

input ServiceInput {
  name: String!
  description: String
  personCapacity: Int!
  categoryId: ID!
  baseFare: Float!
  orderTypes: [TaxiOrderType!]! = [Ride]
  roundingFactor: Float
  perHundredMeters: Float!
  perMinuteDrive: Float!
  perMinuteWait: Float!
  prepayPercent: Float!
  minimumFee: Float!
  searchRadius: Int!
  paymentMethod: ServicePaymentMethod!
  cancellationTotalFee: Float!
  cancellationDriverShare: Float!
  providerSharePercent: Int!
  providerShareFlat: Float!
  twoWayAvailable: Boolean!
  maximumDestinationDistance: Int!
  timeMultipliers: [TimeMultiplierInput!]!
  distanceMultipliers: [DistanceMultiplierInput!]!
  weekdayMultipliers: [WeekdayMultiplierInput!]!
  dateRangeMultipliers: [DateRangeMultiplierInput!]!
  mediaId: ID!
}

input UpdateOneServiceInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: ServiceInput!
}

input DeleteOneServiceInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneServiceCategoryInput {
  """The record to create"""
  serviceCategory: ServiceCategoryInput!
}

input ServiceCategoryInput {
  name: String!
  enabled: String
}

input UpdateOneServiceCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: ServiceCategoryInput!
}

input DeleteOneServiceCategoryInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneServiceOptionInput {
  """The record to create"""
  serviceOption: ServiceOptionInput!
}

input ServiceOptionInput {
  name: String!
  type: ServiceOptionType!
  additionalFee: Float
  icon: ServiceOptionIcon!
}

input UpdateOneServiceOptionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: ServiceOptionInput!
}

input DeleteOneServiceOptionInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneOperatorRoleInput {
  """The record to create"""
  operatorRole: OperatorRoleInput!
}

input OperatorRoleInput {
  title: String!
  permissions: [OperatorPermission!]
  taxiPermissions: [TaxiPermission!]
  shopPermissions: [ShopPermission!]
  parkingPermissions: [ParkingPermission!]
  allowedApps: [AppType!]
}

input UpdateOneOperatorRoleInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: OperatorRoleInput!
}

input DeleteOneOperatorRoleInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneOperatorInput {
  """The record to create"""
  operator: CreateOperatorInput!
}

input CreateOperatorInput {
  firstName: String
  lastName: String
  userName: String!
  password: String!
  mobileNumber: String!
  email: String
  roleId: ID!
}

input UpdateOneOperatorInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateOperatorInput!
}

input UpdateOperatorInput {
  firstName: String
  lastName: String
  userName: String
  password: String
  mobileNumber: String
  email: String
  roleId: ID!
  isBlocked: Boolean
  enabledNotifications: [String!]
  address: String
  mediaId: ID!
}

input DeleteOneOperatorInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneRiderInput {
  """The record to create"""
  rider: RiderInput!
}

input RiderInput {
  status: RiderStatus
  firstName: String
  lastName: String
  countryIso: String
  mobileNumber: String
  registrationTimestamp: DateTime
  email: String
  gender: Gender
  isResident: Boolean
  idNumber: String
  password: String
}

input UpdateOneRiderInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: RiderInput!
}

input CreateOneRiderTransactionInput {
  """The record to create"""
  riderTransaction: RiderTransactionInput!
}

input CreateOneRiderAddressInput {
  """The record to create"""
  riderAddress: CreateRiderAddress!
}

input CreateRiderAddress {
  id: ID!
  type: RiderAddressType!
  title: String!
  details: String
  location: PointInput!
  riderId: ID!
}

input UpdateOneRiderAddressInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateRiderAddress!
}

input UpdateRiderAddress {
  id: ID
  type: RiderAddressType
  title: String
  details: String
  location: PointInput
  riderId: ID
}

input UpdateManyRiderAddressesInput {
  """Filter used to find fields to update"""
  filter: RiderAddressUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateRiderAddress!
}

input RiderAddressUpdateFilter {
  and: [RiderAddressUpdateFilter!]
  or: [RiderAddressUpdateFilter!]
  id: IDFilterComparison
  riderId: IDFilterComparison
}

input DeleteOneSavedPaymentMethodInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneCustomerNoteInput {
  """The record to create"""
  customerNote: CreateCustomerNoteInput!
}

input CreateCustomerNoteInput {
  customerId: ID!
  note: String!
}

input DeleteOneCustomerSessionInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneDriverInput {
  """The record to create"""
  driver: UpdateDriverInput!
}

input UpdateDriverInput {
  fleetId: ID
  carId: ID
  mobileNumber: String
  carColorId: ID
  firstName: String
  lastName: String
  certificateNumber: String
  canDeliver: Boolean
  maxDeliveryPackageSize: DeliveryPackageSize
  email: String
  password: String
  carProductionYear: Int
  carPlate: String
  status: DriverStatus
  gender: Gender
  accountNumber: String
  bankName: String
  bankRoutingNumber: String
  bankSwift: String
  address: String
  softRejectionNote: String
  mediaId: ID
}

input UpdateOneDriverInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateDriverInput!
}

input CreateOneDriverNoteInput {
  """The record to create"""
  driverNote: CreateDriverNoteInput!
}

input CreateDriverNoteInput {
  driverId: ID!
  note: String!
}

input DeleteOneDriverSessionInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneDriverTransactionInput {
  """The record to create"""
  driverTransaction: DriverTransactionInput!
}

input CreateOneDriverDocumentInput {
  """The record to create"""
  driverDocument: DriverDocumentInput!
}

input DriverDocumentInput {
  title: String!
  isEnabled: Boolean!
  isRequired: Boolean!
  hasExpiryDate: Boolean!
  notificationDaysBeforeExpiry: Int!
  numberOfImages: Int!
}

input CreateManyDriverDocumentsInput {
  """Array of records to create"""
  driverDocuments: [DriverDocumentInput!]!
}

input UpdateOneDriverDocumentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: DriverDocumentInput!
}

input UpdateManyDriverDocumentsInput {
  """Filter used to find fields to update"""
  filter: DriverDocumentUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: DriverDocumentInput!
}

input DriverDocumentUpdateFilter {
  and: [DriverDocumentUpdateFilter!]
  or: [DriverDocumentUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneDriverDocumentInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyDriverDocumentsInput {
  """Filter to find records to delete"""
  filter: DriverDocumentDeleteFilter!
}

input DriverDocumentDeleteFilter {
  and: [DriverDocumentDeleteFilter!]
  or: [DriverDocumentDeleteFilter!]
  id: IDFilterComparison
}

input CreateOneDriverDocumentRetentionPolicyInput {
  """The record to create"""
  driverDocumentRetentionPolicy: DriverDocumentRetentionPolicyInput!
}

input DriverDocumentRetentionPolicyInput {
  title: String!
  deleteAfterDays: Int!
  driverDocumentId: ID!
}

input CreateManyDriverDocumentRetentionPoliciesInput {
  """Array of records to create"""
  driverDocumentRetentionPolicies: [DriverDocumentRetentionPolicyInput!]!
}

input UpdateOneDriverDocumentRetentionPolicyInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: DriverDocumentRetentionPolicyInput!
}

input UpdateManyDriverDocumentRetentionPoliciesInput {
  """Filter used to find fields to update"""
  filter: DriverDocumentRetentionPolicyUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: DriverDocumentRetentionPolicyInput!
}

input DriverDocumentRetentionPolicyUpdateFilter {
  and: [DriverDocumentRetentionPolicyUpdateFilter!]
  or: [DriverDocumentRetentionPolicyUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneDriverDocumentRetentionPolicyInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyDriverDocumentRetentionPoliciesInput {
  """Filter to find records to delete"""
  filter: DriverDocumentRetentionPolicyDeleteFilter!
}

input DriverDocumentRetentionPolicyDeleteFilter {
  and: [DriverDocumentRetentionPolicyDeleteFilter!]
  or: [DriverDocumentRetentionPolicyDeleteFilter!]
  id: IDFilterComparison
}

input CreateOneDriverToDriverDocumentInput {
  """The record to create"""
  driverToDriverDocument: DriverToDriverDocumentInput!
}

input DriverToDriverDocumentInput {
  driverId: ID!
  driverDocumentId: ID!
  mediaId: ID!
  retentionPolicyId: ID!
  expiresAt: DateTime
}

input UpdateOneDriverToDriverDocumentInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: DriverToDriverDocumentInput!
}

input DeleteOneDriverToDriverDocumentInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneDriverShiftRuleInput {
  """The record to create"""
  driverShiftRule: DriverShiftRuleInput!
}

input DriverShiftRuleInput {
  timeFrequency: TimeFrequency!
  maxHoursPerFrequency: Int!
  mandatoryBreakMinutes: Int!
}

input CreateManyDriverShiftRulesInput {
  """Array of records to create"""
  driverShiftRules: [DriverShiftRuleInput!]!
}

input UpdateOneDriverShiftRuleInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: DriverShiftRuleInput!
}

input UpdateManyDriverShiftRulesInput {
  """Filter used to find fields to update"""
  filter: DriverShiftRuleUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: DriverShiftRuleInput!
}

input DriverShiftRuleUpdateFilter {
  and: [DriverShiftRuleUpdateFilter!]
  or: [DriverShiftRuleUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneDriverShiftRuleInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyDriverShiftRulesInput {
  """Filter to find records to delete"""
  filter: DriverShiftRuleDeleteFilter!
}

input DriverShiftRuleDeleteFilter {
  and: [DriverShiftRuleDeleteFilter!]
  or: [DriverShiftRuleDeleteFilter!]
  id: IDFilterComparison
}

input CreateOneFleetInput {
  """The record to create"""
  fleet: CreateFleetInput!
}

input CreateFleetInput {
  name: String!
  phoneNumber: String!
  mobileNumber: String!
  userName: String!
  password: String!
  accountNumber: String!
  commissionSharePercent: Float!
  commissionShareFlat: Float!
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[PointInput!]!]
  profilePictureId: ID!
  isBlocked: Boolean
}

input UpdateOneFleetInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFleetInput!
}

input UpdateFleetInput {
  name: String
  phoneNumber: String
  mobileNumber: String
  userName: String
  password: String
  accountNumber: String
  commissionSharePercent: Float!
  commissionShareFlat: Float
  feeMultiplier: Float
  address: String
  exclusivityAreas: [[PointInput!]!]
  profilePictureId: ID!
  isBlocked: Boolean
}

input DeleteOneFleetInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneFleetStaffInput {
  """The record to create"""
  fleetStaff: CreateFleetStaffInput!
}

input CreateFleetStaffInput {
  fleetId: ID!
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String
  mobileNumber: String
  address: String
  userName: String!
  password: String!
  permissionOrder: FleetStaffPermissionOrder!
  permissionFinancial: FleetStaffPermissionFinancial!
  profileImageId: ID
}

enum FleetStaffPermissionFinancial {
  CAN_VIEW
  CAN_EDIT
}

input UpdateOneFleetStaffInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFleetStaffInput!
}

input UpdateFleetStaffInput {
  firstName: String
  lastName: String
  phoneNumber: String
  mobileNumber: String
  address: String
  email: String
  userName: String
  password: String
  permissionOrder: FleetStaffPermissionOrder!
  permissionFinancial: FleetStaffPermissionFinancial!
  profileImageId: ID
  isBlocked: Boolean
}

input DeleteOneFleetStaffInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneOrderCancelReasonInput {
  """The record to create"""
  orderCancelReason: OrderCancelReasonInput!
}

input OrderCancelReasonInput {
  title: String
  isEnabled: Boolean!
  userType: AnnouncementUserType!
}

input UpdateOneOrderCancelReasonInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: OrderCancelReasonInput!
}

input DeleteOneOrderCancelReasonInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneAnnouncementInput {
  """The record to create"""
  announcement: AnnouncementInput!
}

input AnnouncementInput {
  title: String!
  description: String
  url: String
  appType: AppType
  userType: AnnouncementUserType
  startAt: DateTime
  expireAt: DateTime
}

input UpdateOneAnnouncementInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: AnnouncementInput!
}

input DeleteOneAnnouncementInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneCouponInput {
  """The record to create"""
  coupon: CouponInput!
}

input CouponInput {
  code: String!
  title: String!
  description: String!
  manyUsersCanUse: Int!
  manyTimesUserCanUse: Int!
  minimumCost: Float!
  maximumCost: Float!
  startAt: DateTime!
  expireAt: DateTime!
  discountPercent: Int!
  discountFlat: Int!
  creditGift: Float!
  isEnabled: Boolean!
  isFirstTravelOnly: Boolean!
}

input UpdateOneCouponInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: CouponInput!
}

input DeleteOneCouponInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneCampaignInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneProviderTransactionInput {
  """The record to create"""
  providerTransaction: ProviderTransactionInput!
}

input ProviderTransactionInput {
  action: TransactionAction!
  deductType: ProviderDeductTransactionType!
  rechargeType: ProviderRechargeTransactionType!
  expenseType: ProviderExpenseType!
  amount: Float!
  currency: String!
  refrenceNumber: String
  description: String
  operatorId: ID!
}

input CreateOneRegionInput {
  """The record to create"""
  region: CreateRegionInput!
}

input CreateRegionInput {
  name: String!
  currency: String!
  enabled: Boolean!
  location: [[PointInput!]!]!
  categoryId: ID
}

input UpdateOneRegionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateRegionInput!
}

input UpdateRegionInput {
  name: String
  currency: String
  enabled: Boolean
  location: [[PointInput!]!]
  categoryId: ID
}

input DeleteOneRegionInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneRegionCategoryInput {
  """The record to create"""
  regionCategory: RegionCategoryInput!
}

input RegionCategoryInput {
  name: String!
  currency: String!
}

input UpdateOneRegionCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: RegionCategoryInput!
}

input DeleteOneRegionCategoryInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOnePaymentGatewayInput {
  """The record to create"""
  paymentGateway: CreatePaymentGatewayInput!
}

input CreatePaymentGatewayInput {
  enabled: Boolean!
  title: String!
  type: PaymentGatewayType!
  publicKey: String
  privateKey: String!
  merchantId: ID!
  saltKey: String
  mediaId: ID!
}

input UpdateOnePaymentGatewayInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePaymentGatewayInput!
}

input UpdatePaymentGatewayInput {
  enabled: Boolean
  title: String
  type: PaymentGatewayType
  publicKey: String
  privateKey: String
  merchantId: ID!
  saltKey: String
  mediaId: ID!
}

input DeleteOnePaymentGatewayInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneCarModelInput {
  """The record to create"""
  carModel: CarModelInput!
}

input CarModelInput {
  name: String!
}

input UpdateOneCarModelInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: CarModelInput!
}

input DeleteOneCarModelInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneCarColorInput {
  """The record to create"""
  carColor: CarColorInput!
}

input CarColorInput {
  name: String!
}

input UpdateOneCarColorInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: CarColorInput!
}

input DeleteOneCarColorInput {
  """The id of the record to delete."""
  id: ID!
}

input UpdateOneFeedbackInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFeedback!
}

input UpdateFeedback {
  id: ID
  score: Int
  reviewTimestamp: DateTime
  description: String
  driverId: ID
  requestId: ID
}

input CreateOneFeedbackParameterInput {
  """The record to create"""
  feedbackParameter: FeedbackParameterInput!
}

input FeedbackParameterInput {
  title: String!
  isGood: Boolean!
}

input UpdateOneFeedbackParameterInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: FeedbackParameterInput!
}

input DeleteOneFeedbackParameterInput {
  """The id of the record to delete."""
  id: ID!
}

input ManualPayoutInput {
  """
  Fill this with the user's app type. Taxi for a driver, Parking for a Park Owner and Shop for a shop owner
  """
  appType: AppType! = Taxi
  userTransactionId: ID!
  transactionNumber: String!
  description: String
}

input CreatePayoutSessionInput {
  payoutMethodIds: [ID!]!
  minimumAmount: Float!
  currency: String!
  description: String
  appType: AppType! = Taxi
}

input ExportSessionToCsvInput {
  payoutSessionId: ID!
  payoutMethodId: ID!
}

input RunAutoPayoutInput {
  payoutSessionId: ID!
  payoutMethodId: ID!
}

input UpdateOneTaxiPayoutSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePayoutSessionInput!
}

input UpdatePayoutSessionInput {
  status: PayoutSessionStatus!
}

input UpdateOneShopPayoutSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePayoutSessionInput!
}

input UpdateOneParkingPayoutSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePayoutSessionInput!
}

input CreateOnePayoutMethodInput {
  """The record to create"""
  payoutMethod: CreatePayoutMethodInput!
}

input CreatePayoutMethodInput {
  enabled: Boolean
  name: String!
  description: String!
  currency: String!
  type: PayoutMethodType!
  publicKey: String
  privateKey: String
  saltKey: String
  merchantId: ID!
  mediaId: ID!
}

input UpdateOnePayoutMethodInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: CreatePayoutMethodInput!
}

input DeleteOnePayoutMethodInput {
  """The id of the record to delete."""
  id: ID!
}

input UpdateOneDistressSignalInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSosInput!
}

input UpdateSosInput {
  status: SOSStatus!
}

input CreateOneSOSActivityInput {
  """The record to create"""
  sOSActivity: CreateSOSAcitivtyInput!
}

input CreateSOSAcitivtyInput {
  action: SOSActivityAction!
  note: String
  sosId: ID!
}

input CreateOneSOSReasonInput {
  """The record to create"""
  sOSReason: CreateSosReasonInput!
}

input CreateSosReasonInput {
  name: String!
}

input UpdateOneSOSReasonInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSosReasonInput!
}

input UpdateSosReasonInput {
  name: String
  isActive: Boolean
}

input DeleteOneSOSReasonInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneRewardInput {
  """The record to create"""
  reward: CreateReward!
}

input CreateReward {
  id: ID!
  title: String!
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType!
  beneficiary: RewardBeneficiary!
  event: RewardEvent!
  creditGift: Float!
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

input UpdateOneRewardInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateReward!
}

input UpdateReward {
  id: ID
  title: String
  startDate: DateTime
  endDate: DateTime
  appType: RewardAppType
  beneficiary: RewardBeneficiary
  event: RewardEvent
  creditGift: Float
  tripFeePercentGift: Float
  creditCurrency: String
  conditionTripCountsLessThan: Float
  conditionUserNumberFirstDigits: [String!]
}

input DeleteOneRewardInput {
  """The id of the record to delete."""
  id: ID!
}

input UpdateOneTaxiSupportRequestInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateTaxiSupportRequest!
}

input UpdateTaxiSupportRequest {
  id: ID
  inscriptionTimestamp: DateTime
  requestedByDriver: Boolean
  subject: String
  content: String
  status: ComplaintStatus
  requestId: ID
}

input CreateOneTaxiSupportRequestActivityInput {
  """The record to create"""
  taxiSupportRequestActivity: CreateTaxiSupportRequestActivity!
}

input CreateTaxiSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
  complaintId: ID!
}

input CreateShopSupportRequestCommentInput {
  supportRequestId: ID!
  comment: String!
}

input AssignShopSupportRequestInput {
  supportRequestId: ID!
  staffIds: [ID!]!
}

input ChangeShopSupportRequestStatusInput {
  supportRequestId: ID!
  status: ComplaintStatus!
}

input UpdateOneShopSupportRequestInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopSupportRequest!
}

input UpdateShopSupportRequest {
  id: ID
  createdAt: DateTime
  requestedByShop: Boolean
  subject: String
  content: String
  status: ComplaintStatus
}

input CreateOneShopSupportRequestActivityInput {
  """The record to create"""
  shopSupportRequestActivity: CreateShopSupportRequestActivity!
}

input CreateShopSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
}

input UpdateOneShopFeedbackInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopFeedback!
}

input UpdateShopFeedback {
  id: ID

  """The score of the review, from 0 to 100"""
  score: Int
  comment: String
  status: ReviewStatus
  createdAt: DateTime
  shopId: ID
  customerId: ID
}

input CreateOneShopFeedbackParameterInput {
  """The record to create"""
  shopFeedbackParameter: CreateShopFeedbackParameter!
}

input CreateShopFeedbackParameter {
  id: ID!
  isGood: Boolean!
  name: String!
}

input UpdateOneShopFeedbackParameterInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopFeedbackParameter!
}

input UpdateShopFeedbackParameter {
  id: ID
  isGood: Boolean
  name: String
}

input DeleteOneShopFeedbackParameterInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneShopCategoryInput {
  """The record to create"""
  shopCategory: CreateShopCategoryInput!
}

input CreateShopCategoryInput {
  name: String!
  description: String
  imageId: ID!
}

input UpdateOneShopCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopCategoryInput!
}

input UpdateShopCategoryInput {
  name: String
  description: String
  imageId: ID!
  status: ShopCategoryStatus
}

input DeleteOneShopCategoryInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneShopInput {
  """The record to create"""
  shop: UpsertShopInput!
}

input UpsertShopInput {
  name: String
  status: ShopStatus!
  mobileNumber: String
  personalInfo: PersonalInfoInput!
  email: String
  address: String
  password: String
  weeklySchedule: [WeekdayScheduleInput!]!
  isExpressDeliveryAvailable: Boolean
  isShopDeliveryAvailable: Boolean

  """
  The percentage of the delivery fee that shop pays so the delivery fee would be more appealing to the users.
  """
  expressDeliveryShopCommission: Int!
  isOnlinePaymentAvailable: Boolean
  isCashOnDeliveryAvailable: Boolean
  description: String
  location: PointInput!
  imageId: ID
}

input UpdateOneShopInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpsertShopInput!
}

input DeleteOneShopInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneShopOrderNoteInput {
  """The record to create"""
  shopOrderNote: CreateShopOrderNoteInput!
}

input CreateShopOrderNoteInput {
  orderId: ID!
  note: String!
}

input CreateOneShopNoteInput {
  """The record to create"""
  shopNote: CreateShopNoteInput!
}

input CreateShopNoteInput {
  shopId: ID!
  note: String!
}

input CreateOneShopItemPresetInput {
  """The record to create"""
  shopItemPreset: CreateShopItemPresetInput!
}

input CreateShopItemPresetInput {
  name: String!
  shopId: ID!
  weeklySchedule: [WeekdayScheduleInput!]!
}

input UpdateOneShopItemPresetInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopItemPresetInput!
}

input UpdateShopItemPresetInput {
  name: String
  weeklySchedule: [WeekdayScheduleInput!]
}

input DeleteOneShopItemPresetInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneItemCategoryInput {
  """The record to create"""
  itemCategory: CreateItemCategoryInput!
}

input CreateItemCategoryInput {
  name: String!
  shopId: ID!
}

input UpdateOneItemCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateItemCategoryInput!
}

input UpdateItemCategoryInput {
  name: String
}

input DeleteOneItemCategoryInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneItemInput {
  """The record to create"""
  item: CreateItem!
}

input CreateItem {
  id: ID!
  name: String!
  description: String

  """The base price of the item"""
  basePrice: Float!
  ratingAggregate: RatingAggregateInput!
  shopId: ID!

  """The stock quantity"""
  stockQuantity: Int!
  discountPercentage: Int!
  discountedQuantity: Int!
  discountUntil: DateTime
  usedDiscountedQuantity: Int!
}

input UpdateOneItemInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateItem!
}

input UpdateItem {
  id: ID
  name: String
  description: String

  """The base price of the item"""
  basePrice: Float
  ratingAggregate: RatingAggregateInput
  shopId: ID

  """The stock quantity"""
  stockQuantity: Int
  discountPercentage: Int
  discountedQuantity: Int
  discountUntil: DateTime
  usedDiscountedQuantity: Int
}

input DeleteOneItemInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneShopTransactionInput {
  """The record to create"""
  shopTransaction: CreateShopTransactionInput!
}

input CreateShopTransactionInput {
  transactionDate: DateTime
  type: TransactionType!
  debitType: ShopTransactionDebitType
  creditType: ShopTransactionCreditType
  amount: Float!
  currency: String!
  documentNumber: String
  shopId: ID!
  description: String
}

input CreateOneShopDeliveryZoneInput {
  """The record to create"""
  shopDeliveryZone: CreateShopDeliveryZoneInput!
}

input CreateShopDeliveryZoneInput {
  name: String
  shopId: ID!
  deliveryFee: Float!
  minDeliveryTimeMinutes: Int!
  maxDeliveryTimeMinutes: Int!
  minimumOrderAmount: Float!
  location: [[PointInput!]!]!
}

input UpdateOneShopDeliveryZoneInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateShopDeliveryZoneInput!
}

input UpdateShopDeliveryZoneInput {
  name: String
  deliveryFee: Float
  minDeliveryTimeMinutes: Int!
  maxDeliveryTimeMinutes: Int!
  minimumOrderAmount: Float
  location: [[PointInput!]!]
  enabled: Boolean
}

input DeleteOneShopDeliveryZoneInput {
  """The id of the record to delete."""
  id: ID!
}

input UpdateOneParkingFeedbackInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateParkingFeedback!
}

input UpdateParkingFeedback {
  id: ID

  """The score of the review, from 0 to 100"""
  score: Int
  comment: String
  status: ReviewStatus
  createdAt: DateTime
  parkSpotId: ID
  customerId: ID
}

input CreateOneParkingFeedbackParameterInput {
  """The record to create"""
  parkingFeedbackParameter: CreateParkingFeedbackParameter!
}

input CreateParkingFeedbackParameter {
  id: ID!
  isGood: Boolean!
  name: String!
}

input UpdateOneParkingFeedbackParameterInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateParkingFeedbackParameter!
}

input UpdateParkingFeedbackParameter {
  id: ID
  isGood: Boolean
  name: String
}

input DeleteOneParkingFeedbackParameterInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateParkingSupportRequestCommentInput {
  supportRequestId: ID!
  comment: String!
}

input AssignParkingSupportRequestInput {
  supportRequestId: ID!
  staffIds: [ID!]!
}

input ChangeParkingSupportRequestStatusInput {
  supportRequestId: ID!
  status: ComplaintStatus!
}

input UpdateOneParkingSupportRequestInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateParkingSupportRequest!
}

input UpdateParkingSupportRequest {
  id: ID
  createdAt: DateTime
  requestedByOwner: Boolean
  subject: String
  content: String
  status: ComplaintStatus
}

input CreateOneParkingSupportRequestActivityInput {
  """The record to create"""
  parkingSupportRequestActivity: CreateParkingSupportRequestActivity!
}

input CreateParkingSupportRequestActivity {
  id: ID!
  createdAt: DateTime!
  type: ComplaintActivityType!
  comment: String
  statusFrom: ComplaintStatus
  statusTo: ComplaintStatus
}

input UpdateOneParkSpotInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateParkSpotInput!
}

input UpdateParkSpotInput {
  status: ParkSpotStatus!
  type: ParkSpotType!
  name: String!
  location: PointInput!
  address: String
  phoneNumber: String
  email: String
  weeklySchedule: [WeekdayScheduleInput!]!
  carSize: ParkSpotCarSize
  carPrice: Float
  carSpaces: Int!
  bikePrice: Float
  bikeSpaces: Int!
  truckPrice: Float
  truckSpaces: Int!
  description: String
  facilities: [ParkSpotFacility!]!
  mainImageId: ID!
}

input CreateOneParkOrderInput {
  """The record to create"""
  parkOrder: CreateParkOrderInput!
}

input CreateParkOrderInput {
  vehicleType: ParkSpotVehicleType!
  enterTime: DateTime!
  exitTime: DateTime!
  parkSpotId: ID!
  carSize: ParkSpotCarSize
  paymentMode: PaymentMode!
  paymentMethodId: ID!
}

input CreateOneParkOrderNoteInput {
  """The record to create"""
  parkOrderNote: CreateParkOrderNoteInput!
}

input CreateParkOrderNoteInput {
  parkOrderId: ID!
  note: String!
}

input CreateOneParkSpotNoteInput {
  """The record to create"""
  parkSpotNote: CreateParkSpotNoteInput!
}

input CreateParkSpotNoteInput {
  parkSpotId: ID!
  note: String!
}

input CreateOneParkingTransactionInput {
  """The record to create"""
  parkingTransaction: CreateParkingTransactionInput!
}

input CreateParkingTransactionInput {
  transactionDate: DateTime
  type: TransactionType!
  debitType: ParkingTransactionDebitType
  creditType: ParkingTransactionCreditType
  amount: Float!
  currency: String!
  documentNumber: String
  customerId: ID!
  description: String
}

input CreateOneSMSProviderInput {
  """The record to create"""
  sMSProvider: SMSProviderInput!
}

input SMSProviderInput {
  name: String
  type: SMSProviderType
  isDefault: Boolean
  accountId: String
  authToken: String
  fromNumber: String
  verificationTemplate: String
  smsType: String
}

input CreateManySMSProvidersInput {
  """Array of records to create"""
  sMSProviders: [SMSProviderInput!]!
}

input UpdateOneSMSProviderInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: SMSProviderInput!
}

input UpdateManySMSProvidersInput {
  """Filter used to find fields to update"""
  filter: SMSProviderUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: SMSProviderInput!
}

input SMSProviderUpdateFilter {
  and: [SMSProviderUpdateFilter!]
  or: [SMSProviderUpdateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  type: SMSProviderTypeFilterComparison
}

input DeleteOneSMSProviderInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManySMSProvidersInput {
  """Filter to find records to delete"""
  filter: SMSProviderDeleteFilter!
}

input SMSProviderDeleteFilter {
  and: [SMSProviderDeleteFilter!]
  or: [SMSProviderDeleteFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  type: SMSProviderTypeFilterComparison
}

input CreateOneSMSInput {
  """The record to create"""
  sMS: CreateSMS!
}

input CreateSMS {
  id: ID!
  countryIsoCode: String!
  to: String!
  from: String!
  message: String!
  status: SMSStatus!
  type: SMSType!
  providerId: ID!
}

input CreateManySMSInput {
  """Array of records to create"""
  sMS: [CreateSMS!]!
}

input UpdateOneSMSInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSMS!
}

input UpdateSMS {
  id: ID
  countryIsoCode: String
  to: String
  from: String
  message: String
  status: SMSStatus
  type: SMSType
  providerId: ID
}

input UpdateManySMSInput {
  """Filter used to find fields to update"""
  filter: SMSUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateSMS!
}

input SMSUpdateFilter {
  and: [SMSUpdateFilter!]
  or: [SMSUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneSMSInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManySMSInput {
  """Filter to find records to delete"""
  filter: SMSDeleteFilter!
}

input SMSDeleteFilter {
  and: [SMSDeleteFilter!]
  or: [SMSDeleteFilter!]
  id: IDFilterComparison
}

input AddFleetsToZonePriceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetFleetsOnZonePriceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input AddServicesToZonePriceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetServicesOnZonePriceInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input CreateOneZonePriceInput {
  """The record to create"""
  zonePrice: ZonePriceInput!
}

input ZonePriceInput {
  name: String!
  from: [[PointInput!]!]!
  to: [[PointInput!]!]!
  cost: Float!
  timeMultipliers: [TimeMultiplierInput!]!
}

input UpdateOneZonePriceInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: ZonePriceInput!
}

input DeleteOneZonePriceInput {
  """The id of the record to delete."""
  id: ID!
}

input CreateOneZonePriceCategoryInput {
  """The record to create"""
  zonePriceCategory: ZonePriceCategoryInput!
}

input ZonePriceCategoryInput {
  name: String!
}

input UpdateOneZonePriceCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: ZonePriceCategoryInput!
}

input DeleteOneZonePriceCategoryInput {
  """The id of the record to delete."""
  id: ID!
}

type Subscription {
  orderUpdated(orderId: ID!): Order!
  sosCreated: DistressSignal!
  complaintCreated: TaxiSupportRequest!
  notificationCreated: AdminNotificationUnion!
}